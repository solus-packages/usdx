From c6d2ceb4288c447f1d0526351b607de48928001a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Gl=C3=B6ckner?= <daniel-gl@gmx.net>
Date: Sun, 13 Jun 2021 23:09:54 +0200
Subject: [PATCH] Replace FFmpeg 4.0 units with minimal ones compatible up to
 4.4

---
 .../How to update the ffmpeg files.txt        |   20 -
 src/lib/ffmpeg-4.0/ToDo.txt                   |  112 -
 src/lib/ffmpeg-4.0/avcodec.pas                | 6986 +----------------
 src/lib/ffmpeg-4.0/avformat.pas               | 3275 +-------
 src/lib/ffmpeg-4.0/avio.pas                   | 1001 +--
 src/lib/ffmpeg-4.0/avutil.pas                 |  420 +-
 src/lib/ffmpeg-4.0/ff_api-defines.inc         |  169 -
 .../ffmpeg-4.0/libavcodec/audioconvert.pas    |  294 -
 src/lib/ffmpeg-4.0/libavutil/buffer.pas       |  310 -
 src/lib/ffmpeg-4.0/libavutil/cpu.pas          |  135 -
 src/lib/ffmpeg-4.0/libavutil/dict.pas         |  168 -
 src/lib/ffmpeg-4.0/libavutil/error.pas        |  169 -
 src/lib/ffmpeg-4.0/libavutil/frame.pas        |  928 ---
 src/lib/ffmpeg-4.0/libavutil/log.pas          |  530 --
 src/lib/ffmpeg-4.0/libavutil/mathematics.pas  |  222 -
 src/lib/ffmpeg-4.0/libavutil/mem.pas          |  578 --
 src/lib/ffmpeg-4.0/libavutil/opt.pas          |  507 --
 src/lib/ffmpeg-4.0/libavutil/pixfmt.pas       |  599 --
 src/lib/ffmpeg-4.0/libavutil/samplefmt.pas    |  287 -
 src/lib/ffmpeg-4.0/rational.pas               |  250 +-
 src/lib/ffmpeg-4.0/swresample.pas             |  434 +-
 src/lib/ffmpeg-4.0/swscale.pas                |  410 +-
 22 files changed, 496 insertions(+), 17308 deletions(-)
 delete mode 100644 src/lib/ffmpeg-4.0/How to update the ffmpeg files.txt
 delete mode 100644 src/lib/ffmpeg-4.0/ToDo.txt
 delete mode 100644 src/lib/ffmpeg-4.0/ff_api-defines.inc
 delete mode 100644 src/lib/ffmpeg-4.0/libavcodec/audioconvert.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/buffer.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/cpu.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/dict.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/error.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/frame.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/log.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/mathematics.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/mem.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/opt.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/pixfmt.pas
 delete mode 100644 src/lib/ffmpeg-4.0/libavutil/samplefmt.pas

diff --git a/src/lib/ffmpeg-4.0/How to update the ffmpeg files.txt b/src/lib/ffmpeg-4.0/How to update the ffmpeg files.txt
deleted file mode 100644
index ae65d4779..000000000
--- a/src/lib/ffmpeg-4.0/How to update the ffmpeg files.txt	
+++ /dev/null
@@ -1,20 +0,0 @@
-how to update the ffmpeg files:
-
-1)	buffer.pas
-	cpu.pas
-	dict.pas
-	error.pas
-	frame.pas
-	log.pas
-	mathematics.pas
-	mem.pas
-	opt.pas
-	pixfmt.pas
-	samplefmt.pas
-2)	rational.pas
-3)	avutil.pas
-4)	avcodec.pas
-5)	avio.pas
-	swscale.pas
-	swresample.pas
-6)	avformat.pas
\ No newline at end of file
diff --git a/src/lib/ffmpeg-4.0/ToDo.txt b/src/lib/ffmpeg-4.0/ToDo.txt
deleted file mode 100644
index b0bd305e7..000000000
--- a/src/lib/ffmpeg-4.0/ToDo.txt
+++ /dev/null
@@ -1,112 +0,0 @@
-1)	avutil.pas
-
-from mem.pas:
-inline function av_x_if_null
-inline function av_size_mult
-
-from log.pas:
-inline function av_log
-inline function av_log_set_callback
-inline function av_log_default_callback
-inline function av_dlog
-
-
-FFmpeg 3.0 changes:
-2016-02-10 - bc9a596 / 9f61abc - lavf 57.25.100 / 57.3.0 - avformat.h
-  Add AVFormatContext.opaque, io_open and io_close, allowing custom IO
-
-2016-02-01 - 1dba837 - lavf 57.24.100 - avformat.h, avio.h
-  Add protocol_whitelist to AVFormatContext, AVIOContext
-
-2016-01-31 - 66e9d2f - lavu 55.17.100 - frame.h
-  Add AV_FRAME_DATA_GOP_TIMECODE for exporting MPEG1/2 GOP timecodes.
-
-2016-01-01 - 5e8b053 / 2c68113 - lavc 57.21.100 / 57.12.0 - avcodec.h
-  Add AVCodecDescriptor.profiles and avcodec_profile_name().
-
-2015-12-28 - 1f9139b - lavf 57.21.100 - avformat.h
-  Add automatic bitstream filtering; add av_apply_bitstream_filters()
-
-2015-12-22 - 39a09e9 - lavfi 6.21.101 - avfilter.h
-  Deprecate avfilter_link_set_closed().
-  Applications are not supposed to mess with links,
-  they should close the sinks.
-
-2015-12-17 - lavc 57.18.100 / 57.11.0 - avcodec.h dirac.h
-  xxxxxxx - Add av_packet_add_side_data().
-  xxxxxxx - Add AVCodecContext.coded_side_data.
-  xxxxxxx - Add AVCPBProperties API.
-  xxxxxxx - Add a new public header dirac.h containing
-            av_dirac_parse_sequence_header()
-
-2015-12-11 - 676a93f - lavf 57.20.100 - avformat.h
-  Add av_program_add_stream_index()
-
-2015-11-29 - 93fb4a4 - lavc 57.16.101 - avcodec.h
-  Deprecate rtp_callback without replacement, i.e. it won't be possible to
-  get image slices before the full frame is encoded any more. The libavformat
-  rtpenc muxer can still be used for RFC-2190 packetization.
-
-2015-11-22 - fe20e34 - lavc 57.16.100 - avcodec.h
-  Add AV_PKT_DATA_FALLBACK_TRACK for making fallback associations between
-  streams.
-
-2015-11-22 - ad317c9 - lavf 57.19.100 - avformat.h
-  Add av_stream_new_side_data().
-
-2015-11-22 - e12f403 - lavu 55.8.100 - xtea.h
-    Add av_xtea_le_init and av_xtea_le_crypt
-
-2015-11-18 - lavu 55.7.100 - mem.h
-  Add av_fast_mallocz()
-
-2015-10-29 - lavc 57.12.100 / 57.8.0 - avcodec.h
-  xxxxxx - Deprecate av_free_packet(). Use av_packet_unref() as replacement,
-           it resets the packet in a more consistent way.
-  xxxxxx - Deprecate av_dup_packet(), it is a no-op for most cases.
-           Use av_packet_ref() to make a non-refcounted AVPacket refcounted.
-  xxxxxx - Add av_packet_alloc(), av_packet_clone(), av_packet_free().
-           They match the AVFrame functions with the same name.
-
-2015-10-27 - 1e477a9 - lavu 55.5.100 - cpu.h
-  Add AV_CPU_FLAG_AESNI.
-
-2015-10-22 - ee573b4 / a17a766 - lavc 57.9.100 / 57.5.0 - avcodec.h
-  Add data and linesize array to AVSubtitleRect, to be used instead of
-  the ones from the embedded AVPicture.
-
-2015-10-22 - 866a417 / dc923bc - lavc 57.8.100 / 57.0.0 - qsv.h
-  Add an API for allocating opaque surfaces.
-
-2015-10-15 - 2c2d162 - lavf 57.4.100
-  Remove the latm demuxer that was a duplicate of the loas demuxer.
-
-2015-10-14 - b994788 / 11c5f43 - lavu 55.4.100 / 55.2.0 - dict.h
-  Change return type of av_dict_copy() from void to int, so that a proper
-  error code can be reported.
-
-2015-09-29 - b01891a / 948f3c1 - lavc 57.3.100 / 57.2.0 - avcodec.h
-  Change type of AVPacket.duration from int to int64_t.
-
-2015-09-17 - 7c46f24 / e3d4784 - lavc 57.3.100 / 57.2.0 - d3d11va.h
-  Add av_d3d11va_alloc_context(). This function must from now on be used for
-  allocating AVD3D11VAContext.
-
-2015-09-15 - lavf 57.2.100 - avformat.h
-  probesize and max_analyze_duration switched to 64bit, both
-  are only accessible through AVOptions
-
-2015-09-15 - lavf 57.1.100 - avformat.h
-  bit_rate was changed to 64bit, make sure you update any
-  printf() or other type sensitive code
-
-2015-09-15 - lavc 57.2.100 - avcodec.h
-  bit_rate/rc_max_rate/rc_min_rate were changed to 64bit, make sure you update
-  any printf() or other type sensitive code
-
-2015-09-07 - lavu 55.0.100 / 55.0.0
-  c734b34 / b8b5d82 - Change type of AVPixFmtDescriptor.flags from uint8_t to uint64_t.
-  f53569a / 6b3ef7f - Change type of AVComponentDescriptor fields from uint16_t to int
-            and drop bit packing.
-  151aa2e / 2268db2 - Add step, offset, and depth to AVComponentDescriptor to replace
-            the deprecated step_minus1, offset_plus1, and depth_minus1.
\ No newline at end of file
diff --git a/src/lib/ffmpeg-4.0/avcodec.pas b/src/lib/ffmpeg-4.0/avcodec.pas
index cef8b16e4..053cd92a5 100644
--- a/src/lib/ffmpeg-4.0/avcodec.pas
+++ b/src/lib/ffmpeg-4.0/avcodec.pas
@@ -1,44 +1,13 @@
-(*
- * copyright (c) 2001 Fabrice Bellard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavcodec/avcodec.h
- * version: 56.1.100
- *
- *)
-
 unit avcodec;
 
 {$IFDEF FPC}
-  {$MODE DELPHI }
+  {$MODE DELPHI}
   {$PACKENUM 4}    (* use 4-byte enums *)
   {$PACKRECORDS C} (* C/C++-compatible record packing *)
 {$ELSE}
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I switches.inc}  (* for ffmpeg defines *)
-{$I ff_api-defines.inc}  (* FF_API_* defines *)
-
 {$IFDEF DARWIN}
   {$linklib libavcodec}
 {$ENDIF}
@@ -50,41 +19,12 @@ interface
   avutil,
   rational,
   SysUtils,
-  {$IFDEF UNIX}
-  BaseUnix,
-  {$ENDIF}
   UConfig;
 
 const
-  (*
-   * IMPORTANT: The official FFmpeg C headers change very quickly. Often some
-   * of the data structures are changed so that they become incompatible with
-   * older header files. The Pascal headers have to be adjusted to those changes,
-   * otherwise the application might crash randomly or strange bugs (not
-   * necessarily related to video or audio due to buffer overflows etc.) might
-   * occur.
-   *
-   * In the past users reported problems with USDX that took hours to fix and
-   * the problem was an unsupported version of FFmpeg. So we decided to disable
-   * support for future versions of FFmpeg until the headers are revised by us
-   * for that version as they otherwise most probably will break USDX.
-   *
-   * If the headers do not yet support your FFmpeg version you may want to
-   * adjust the max. version numbers manually but please note: it may work but
-   * in many cases it does not. The USDX team does NOT PROVIDE ANY SUPPORT
-   * for the game if the MAX. VERSION WAS CHANGED.
-   *
-   * The only safe way to support new versions of FFmpeg is to add the changes
-   * of the FFmpeg git repository C headers to the Pascal headers.
-   * You can accelerate this process by posting a patch with the git changes
-   * translated to Pascal to our bug tracker (please join our IRC chat before
-   * you start working on it). Simply adjusting the max. versions is NOT a valid
-   * fix.
-   *)
-
   (* Supported version by this header *)
   LIBAVCODEC_MAX_VERSION_MAJOR   = 58;
-  LIBAVCODEC_MAX_VERSION_MINOR   = 54;
+  LIBAVCODEC_MAX_VERSION_MINOR   = 134;
   LIBAVCODEC_MAX_VERSION_RELEASE = 100;
   LIBAVCODEC_MAX_VERSION = (LIBAVCODEC_MAX_VERSION_MAJOR * VERSION_MAJOR) +
                            (LIBAVCODEC_MAX_VERSION_MINOR * VERSION_MINOR) +
@@ -108,6698 +48,282 @@ interface
   {$MESSAGE Error 'Linked version of libavcodec is not yet supported!'}
 {$IFEND}
 
-{$IFNDEF FPC}
-type
-  // defines for Delphi
-  size_t = cardinal;
-{$ENDIF}
-
-type
-  FF_INTERNALC_MEM_TYPE = cuint;
-
 const
-  AV_NOPTS_VALUE: cint64  = $8000000000000000;
-  AV_TIME_BASE            = 1000000;
-  AV_TIME_BASE_Q: TAVRational = (num: 1; den: AV_TIME_BASE);
-
-(**
- * @ingroup libavc
- * @defgroup lavc_encdec send/receive encoding and decoding API overview
- * @{
- *
- * The avcodec_send_packet()/avcodec_receive_frame()/avcodec_send_frame()/
- * avcodec_receive_packet() functions provide an encode/decode API, which
- * decouples input and output.
- *
- * The API is very similar for encoding/decoding and audio/video, and works as
- * follows:
- * - Set up and open the AVCodecContext as usual.
- * - Send valid input:
- *   - For decoding, call avcodec_send_packet() to give the decoder raw
- *     compressed data in an AVPacket.
- *   - For encoding, call avcodec_send_frame() to give the encoder an AVFrame
- *     containing uncompressed audio or video.
- *   In both cases, it is recommended that AVPackets and AVFrames are
- *   refcounted, or libavcodec might have to copy the input data. (libavformat
- *   always returns refcounted AVPackets, and av_frame_get_buffer() allocates
- *   refcounted AVFrames.)
- * - Receive output in a loop. Periodically call one of the avcodec_receive_*()
- *   functions and process their output:
- *   - For decoding, call avcodec_receive_frame(). On success, it will return
- *     an AVFrame containing uncompressed audio or video data.
- *   - For encoding, call avcodec_receive_packet(). On success, it will return
- *     an AVPacket with a compressed frame.
- *   Repeat this call until it returns AVERROR(EAGAIN) or an error. The
- *   AVERROR(EAGAIN) return value means that new input data is required to
- *   return new output. In this case, continue with sending input. For each
- *   input frame/packet, the codec will typically return 1 output frame/packet,
- *   but it can also be 0 or more than 1.
- *
- * At the beginning of decoding or encoding, the codec might accept multiple
- * input frames/packets without returning a frame, until its internal buffers
- * are filled. This situation is handled transparently if you follow the steps
- * outlined above.
- *
- * In theory, sending input can result in EAGAIN - this should happen only if
- * not all output was received. You can use this to structure alternative decode
- * or encode loops other than the one suggested above. For example, you could
- * try sending new input on each iteration, and try to receive output if that
- * returns EAGAIN.
- *
- * End of stream situations. These require "flushing" (aka draining) the codec,
- * as the codec might buffer multiple frames or packets internally for
- * performance or out of necessity (consider B-frames).
- * This is handled as follows:
- * - Instead of valid input, send NULL to the avcodec_send_packet() (decoding)
- *   or avcodec_send_frame() (encoding) functions. This will enter draining
- *   mode.
- * - Call avcodec_receive_frame() (decoding) or avcodec_receive_packet()
- *   (encoding) in a loop until AVERROR_EOF is returned. The functions will
- *   not return AVERROR(EAGAIN), unless you forgot to enter draining mode.
- * - Before decoding can be resumed again, the codec has to be reset with
- *   avcodec_flush_buffers().
- *
- * Using the API as outlined above is highly recommended. But it is also
- * possible to call functions outside of this rigid schema. For example, you can
- * call avcodec_send_packet() repeatedly without calling
- * avcodec_receive_frame(). In this case, avcodec_send_packet() will succeed
- * until the codec's internal buffer has been filled up (which is typically of
- * size 1 per output frame, after initial input), and then reject input with
- * AVERROR(EAGAIN). Once it starts rejecting input, you have no choice but to
- * read at least some output.
- *
- * Not all codecs will follow a rigid and predictable dataflow; the only
- * guarantee is that an AVERROR(EAGAIN) return value on a send/receive call on
- * one end implies that a receive/send call on the other end will succeed, or
- * at least will not fail with AVERROR(EAGAIN). In general, no codec will
- * permit unlimited buffering of input or output.
- *
- * This API replaces the following legacy functions:
- * - avcodec_decode_video2() and avcodec_decode_audio4():
- *   Use avcodec_send_packet() to feed input to the decoder, then use
- *   avcodec_receive_frame() to receive decoded frames after each packet.
- *   Unlike with the old video decoding API, multiple frames might result from
- *   a packet. For audio, splitting the input packet into frames by partially
- *   decoding packets becomes transparent to the API user. You never need to
- *   feed an AVPacket to the API twice (unless it is rejected with AVERROR(EAGAIN) - then
- *   no data was read from the packet).
- *   Additionally, sending a flush/draining packet is required only once.
- * - avcodec_encode_video2()/avcodec_encode_audio2():
- *   Use avcodec_send_frame() to feed input to the encoder, then use
- *   avcodec_receive_packet() to receive encoded packets.
- *   Providing user-allocated buffers for avcodec_receive_packet() is not
- *   possible.
- * - The new API does not handle subtitles yet.
- *
- * Mixing new and old function calls on the same AVCodecContext is not allowed,
- * and will result in undefined behavior.
- *
- * Some codecs might require using the new API; using the old API will return
- * an error when calling it. All codecs support the new API.
- *
- * A codec is not allowed to return AVERROR(EAGAIN) for both sending and receiving. This
- * would be an invalid state, which could put the codec user into an endless
- * loop. The API has no concept of time either: it cannot happen that trying to
- * do avcodec_send_packet() results in AVERROR(EAGAIN), but a repeated call 1 second
- * later accepts the packet (with no other receive/flush API calls involved).
- * The API is a strict state machine, and the passage of time is not supposed
- * to influence it. Some timing-dependent behavior might still be deemed
- * acceptable in certain cases. But it must never result in both send/receive
- * returning EAGAIN at the same time at any point. It must also absolutely be
- * avoided that the current state is "unstable" and can "flip-flop" between
- * the send/receive APIs allowing progress. For example, it's not allowed that
- * the codec randomly decides that it actually wants to consume a packet now
- * instead of returning a frame, after it just returned AVERROR(EAGAIN) on an
- * avcodec_send_packet() call.
- * @}
- *)
-
-(**
- * @defgroup lavc_core Core functions/structures.
- * @ingroup libavc
- *
- * Basic definitions, functions for querying libavcodec capabilities,
- * allocating core structures, etc.
- * @
- *)
-
-(**
- * Identify the syntax and semantics of the bitstream.
- * The principle is roughly:
- * Two decoders with the same ID can decode the same streams.
- * Two encoders with the same ID can encode compatible streams.
- * There may be slight deviations from the principle due to implementation
- * details.
- *
- * If you add a codec ID to this list, add it so that
- * 1. no value of an existing codec ID changes (that would break ABI),
- * 2. it is as close as possible to similar codecs
- *
- * After adding new codec IDs, do not forget to add an entry to the codec
- * descriptor list and bump libavcodec minor version.
- *)
+  FF_BUG_AUTODETECT = 1;
 type
-  PAVCodecID = ^TAVCodecID;
   TAVCodecID = (
-    AV_CODEC_ID_NONE,
-
-    //* video codecs */
-    AV_CODEC_ID_MPEG1VIDEO,
-    AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
-    AV_CODEC_ID_H261,
-    AV_CODEC_ID_H263,
-    AV_CODEC_ID_RV10,
-    AV_CODEC_ID_RV20,
-    AV_CODEC_ID_MJPEG,
-    AV_CODEC_ID_MJPEGB,
-    AV_CODEC_ID_LJPEG,
-    AV_CODEC_ID_SP5X,
-    AV_CODEC_ID_JPEGLS,
-    AV_CODEC_ID_MPEG4,
-    AV_CODEC_ID_RAWVIDEO,
-    AV_CODEC_ID_MSMPEG4V1,
-    AV_CODEC_ID_MSMPEG4V2,
-    AV_CODEC_ID_MSMPEG4V3,
-    AV_CODEC_ID_WMV1,
-    AV_CODEC_ID_WMV2,
-    AV_CODEC_ID_H263P,
-    AV_CODEC_ID_H263I,
-    AV_CODEC_ID_FLV1,
-    AV_CODEC_ID_SVQ1,
-    AV_CODEC_ID_SVQ3,
-    AV_CODEC_ID_DVVIDEO,
-    AV_CODEC_ID_HUFFYUV,
-    AV_CODEC_ID_CYUV,
-    AV_CODEC_ID_H264,
-    AV_CODEC_ID_INDEO3,
-    AV_CODEC_ID_VP3,
-    AV_CODEC_ID_THEORA,
-    AV_CODEC_ID_ASV1,
-    AV_CODEC_ID_ASV2,
-    AV_CODEC_ID_FFV1,
-    AV_CODEC_ID_4XM,
-    AV_CODEC_ID_VCR1,
-    AV_CODEC_ID_CLJR,
-    AV_CODEC_ID_MDEC,
-    AV_CODEC_ID_ROQ,
-    AV_CODEC_ID_INTERPLAY_VIDEO,
-    AV_CODEC_ID_XAN_WC3,
-    AV_CODEC_ID_XAN_WC4,
-    AV_CODEC_ID_RPZA,
-    AV_CODEC_ID_CINEPAK,
-    AV_CODEC_ID_WS_VQA,
-    AV_CODEC_ID_MSRLE,
-    AV_CODEC_ID_MSVIDEO1,
-    AV_CODEC_ID_IDCIN,
-    AV_CODEC_ID_8BPS,
-    AV_CODEC_ID_SMC,
-    AV_CODEC_ID_FLIC,
-    AV_CODEC_ID_TRUEMOTION1,
-    AV_CODEC_ID_VMDVIDEO,
-    AV_CODEC_ID_MSZH,
-    AV_CODEC_ID_ZLIB,
-    AV_CODEC_ID_QTRLE,
-    AV_CODEC_ID_TSCC,
-    AV_CODEC_ID_ULTI,
-    AV_CODEC_ID_QDRAW,
-    AV_CODEC_ID_VIXL,
-    AV_CODEC_ID_QPEG,
-    AV_CODEC_ID_PNG,
-    AV_CODEC_ID_PPM,
-    AV_CODEC_ID_PBM,
-    AV_CODEC_ID_PGM,
-    AV_CODEC_ID_PGMYUV,
-    AV_CODEC_ID_PAM,
-    AV_CODEC_ID_FFVHUFF,
-    AV_CODEC_ID_RV30,
-    AV_CODEC_ID_RV40,
-    AV_CODEC_ID_VC1,
-    AV_CODEC_ID_WMV3,
-    AV_CODEC_ID_LOCO,
-    AV_CODEC_ID_WNV1,
-    AV_CODEC_ID_AASC,
-    AV_CODEC_ID_INDEO2,
-    AV_CODEC_ID_FRAPS,
-    AV_CODEC_ID_TRUEMOTION2,
-    AV_CODEC_ID_BMP,
-    AV_CODEC_ID_CSCD,
-    AV_CODEC_ID_MMVIDEO,
-    AV_CODEC_ID_ZMBV,
-    AV_CODEC_ID_AVS,
-    AV_CODEC_ID_SMACKVIDEO,
-    AV_CODEC_ID_NUV,
-    AV_CODEC_ID_KMVC,
-    AV_CODEC_ID_FLASHSV,
-    AV_CODEC_ID_CAVS,
-    AV_CODEC_ID_JPEG2000,
-    AV_CODEC_ID_VMNC,
-    AV_CODEC_ID_VP5,
-    AV_CODEC_ID_VP6,
-    AV_CODEC_ID_VP6F,
-    AV_CODEC_ID_TARGA,
-    AV_CODEC_ID_DSICINVIDEO,
-    AV_CODEC_ID_TIERTEXSEQVIDEO,
-    AV_CODEC_ID_TIFF,
-    AV_CODEC_ID_GIF,
-    AV_CODEC_ID_DXA,
-    AV_CODEC_ID_DNXHD,
-    AV_CODEC_ID_THP,
-    AV_CODEC_ID_SGI,
-    AV_CODEC_ID_C93,
-    AV_CODEC_ID_BETHSOFTVID,
-    AV_CODEC_ID_PTX,
-    AV_CODEC_ID_TXD,
-    AV_CODEC_ID_VP6A,
-    AV_CODEC_ID_AMV,
-    AV_CODEC_ID_VB,
-    AV_CODEC_ID_PCX,
-    AV_CODEC_ID_SUNRAST,
-    AV_CODEC_ID_INDEO4,
-    AV_CODEC_ID_INDEO5,
-    AV_CODEC_ID_MIMIC,
-    AV_CODEC_ID_RL2,
-    AV_CODEC_ID_ESCAPE124,
-    AV_CODEC_ID_DIRAC,
-    AV_CODEC_ID_BFI,
-    AV_CODEC_ID_CMV,
-    AV_CODEC_ID_MOTIONPIXELS,
-    AV_CODEC_ID_TGV,
-    AV_CODEC_ID_TGQ,
-    AV_CODEC_ID_TQI,
-    AV_CODEC_ID_AURA,
-    AV_CODEC_ID_AURA2,
-    AV_CODEC_ID_V210X,
-    AV_CODEC_ID_TMV,
-    AV_CODEC_ID_V210,
-    AV_CODEC_ID_DPX,
-    AV_CODEC_ID_MAD,
-    AV_CODEC_ID_FRWU,
-    AV_CODEC_ID_FLASHSV2,
-    AV_CODEC_ID_CDGRAPHICS,
-    AV_CODEC_ID_R210,
-    AV_CODEC_ID_ANM,
-    AV_CODEC_ID_BINKVIDEO,
-    AV_CODEC_ID_IFF_ILBM,
-    AV_CODEC_ID_IFF_BYTERUN1 = AV_CODEC_ID_IFF_ILBM,
-    AV_CODEC_ID_KGV1,
-    AV_CODEC_ID_YOP,
-    AV_CODEC_ID_VP8,
-    AV_CODEC_ID_PICTOR,
-    AV_CODEC_ID_ANSI,
-    AV_CODEC_ID_A64_MULTI,
-    AV_CODEC_ID_A64_MULTI5,
-    AV_CODEC_ID_R10K,
-    AV_CODEC_ID_MXPEG,
-    AV_CODEC_ID_LAGARITH,
-    AV_CODEC_ID_PRORES,
-    AV_CODEC_ID_JV,
-    AV_CODEC_ID_DFA,
-    AV_CODEC_ID_WMV3IMAGE,
-    AV_CODEC_ID_VC1IMAGE,
-    AV_CODEC_ID_UTVIDEO,
-    AV_CODEC_ID_BMV_VIDEO,
-    AV_CODEC_ID_VBLE,
-    AV_CODEC_ID_DXTORY,
-    AV_CODEC_ID_V410,
-    AV_CODEC_ID_XWD,
-    AV_CODEC_ID_CDXL,
-    AV_CODEC_ID_XBM,
-    AV_CODEC_ID_ZEROCODEC,
-    AV_CODEC_ID_MSS1,
-    AV_CODEC_ID_MSA1,
-    AV_CODEC_ID_TSCC2,
-    AV_CODEC_ID_MTS2,
-    AV_CODEC_ID_CLLC,
-    AV_CODEC_ID_MSS2,
-    AV_CODEC_ID_VP9,
-    AV_CODEC_ID_AIC,
-    AV_CODEC_ID_ESCAPE130,
-    AV_CODEC_ID_G2M,
-    AV_CODEC_ID_WEBP,
-    AV_CODEC_ID_HNM4_VIDEO,
-    AV_CODEC_ID_HEVC,
-    AV_CODEC_ID_FIC,
-    AV_CODEC_ID_ALIAS_PIX,
-    AV_CODEC_ID_BRENDER_PIX,
-    AV_CODEC_ID_PAF_VIDEO,
-    AV_CODEC_ID_EXR,
-    AV_CODEC_ID_VP7,
-    AV_CODEC_ID_SANM,
-    AV_CODEC_ID_SGIRLE,
-    AV_CODEC_ID_MVC1,
-    AV_CODEC_ID_MVC2,
-    AV_CODEC_ID_HQX,
-    AV_CODEC_ID_TDSC,
-    AV_CODEC_ID_HQ_HQA,
-    AV_CODEC_ID_HAP,
-    AV_CODEC_ID_DDS,
-    AV_CODEC_ID_DXV,
-    AV_CODEC_ID_SCREENPRESSO,
-    AV_CODEC_ID_RSCC,
-
-    AV_CODEC_ID_Y41P = $8000,
-    AV_CODEC_ID_AVRP,
-    AV_CODEC_ID_012V,
-    AV_CODEC_ID_AVUI,
-    AV_CODEC_ID_AYUV,
-    AV_CODEC_ID_TARGA_Y216,
-    AV_CODEC_ID_V308,
-    AV_CODEC_ID_V408,
-    AV_CODEC_ID_YUV4,
-    AV_CODEC_ID_AVRN,
-    AV_CODEC_ID_CPIA,
-    AV_CODEC_ID_XFACE,
-    AV_CODEC_ID_SNOW,
-    AV_CODEC_ID_SMVJPEG,
-    AV_CODEC_ID_APNG,
-    AV_CODEC_ID_DAALA,
-    AV_CODEC_ID_CFHD,
-    AV_CODEC_ID_TRUEMOTION2RT,
-    AV_CODEC_ID_M101,
-    AV_CODEC_ID_MAGICYUV,
-    AV_CODEC_ID_SHEERVIDEO,
-    AV_CODEC_ID_YLC,
-    AV_CODEC_ID_PSD,
-    AV_CODEC_ID_PIXLET,
-    AV_CODEC_ID_SPEEDHQ,
-    AV_CODEC_ID_FMVC,
-    AV_CODEC_ID_SCPR,
-    AV_CODEC_ID_CLEARVIDEO,
-    AV_CODEC_ID_XPM,
-    AV_CODEC_ID_AV1,
-    AV_CODEC_ID_BITPACKED,
-    AV_CODEC_ID_MSCC,
-    AV_CODEC_ID_SRGC,
-    AV_CODEC_ID_SVG,
-    AV_CODEC_ID_GDV,
-    AV_CODEC_ID_FITS,
-
-    //* various PCM "codecs" */
-    AV_CODEC_ID_FIRST_AUDIO = $10000,     ///< A dummy id pointing at the start of audio codecs
-    AV_CODEC_ID_PCM_S16LE = $10000,
-    AV_CODEC_ID_PCM_S16BE,
-    AV_CODEC_ID_PCM_U16LE,
-    AV_CODEC_ID_PCM_U16BE,
-    AV_CODEC_ID_PCM_S8,
-    AV_CODEC_ID_PCM_U8,
-    AV_CODEC_ID_PCM_MULAW,
-    AV_CODEC_ID_PCM_ALAW,
-    AV_CODEC_ID_PCM_S32LE,
-    AV_CODEC_ID_PCM_S32BE,
-    AV_CODEC_ID_PCM_U32LE,
-    AV_CODEC_ID_PCM_U32BE,
-    AV_CODEC_ID_PCM_S24LE,
-    AV_CODEC_ID_PCM_S24BE,
-    AV_CODEC_ID_PCM_U24LE,
-    AV_CODEC_ID_PCM_U24BE,
-    AV_CODEC_ID_PCM_S24DAUD,
-    AV_CODEC_ID_PCM_ZORK,
-    AV_CODEC_ID_PCM_S16LE_PLANAR,
-    AV_CODEC_ID_PCM_DVD,
-    AV_CODEC_ID_PCM_F32BE,
-    AV_CODEC_ID_PCM_F32LE,
-    AV_CODEC_ID_PCM_F64BE,
-    AV_CODEC_ID_PCM_F64LE,
-    AV_CODEC_ID_PCM_BLURAY,
-    AV_CODEC_ID_PCM_LXF,
-    AV_CODEC_ID_S302M,
-    AV_CODEC_ID_PCM_S8_PLANAR,
-    AV_CODEC_ID_PCM_S24LE_PLANAR,
-    AV_CODEC_ID_PCM_S32LE_PLANAR,
-    AV_CODEC_ID_PCM_S16BE_PLANAR,
-
-    AV_CODEC_ID_PCM_S64LE = $10800,
-    AV_CODEC_ID_PCM_S64BE,
-    AV_CODEC_ID_PCM_F16LE,
-    AV_CODEC_ID_PCM_F24LE,
-
-    //* various ADPCM codecs */
-    AV_CODEC_ID_ADPCM_IMA_QT = $11000,
-    AV_CODEC_ID_ADPCM_IMA_WAV,
-    AV_CODEC_ID_ADPCM_IMA_DK3,
-    AV_CODEC_ID_ADPCM_IMA_DK4,
-    AV_CODEC_ID_ADPCM_IMA_WS,
-    AV_CODEC_ID_ADPCM_IMA_SMJPEG,
-    AV_CODEC_ID_ADPCM_MS,
-    AV_CODEC_ID_ADPCM_4XM,
-    AV_CODEC_ID_ADPCM_XA,
-    AV_CODEC_ID_ADPCM_ADX,
-    AV_CODEC_ID_ADPCM_EA,
-    AV_CODEC_ID_ADPCM_G726,
-    AV_CODEC_ID_ADPCM_CT,
-    AV_CODEC_ID_ADPCM_SWF,
-    AV_CODEC_ID_ADPCM_YAMAHA,
-    AV_CODEC_ID_ADPCM_SBPRO_4,
-    AV_CODEC_ID_ADPCM_SBPRO_3,
-    AV_CODEC_ID_ADPCM_SBPRO_2,
-    AV_CODEC_ID_ADPCM_THP,
-    AV_CODEC_ID_ADPCM_IMA_AMV,
-    AV_CODEC_ID_ADPCM_EA_R1,
-    AV_CODEC_ID_ADPCM_EA_R3,
-    AV_CODEC_ID_ADPCM_EA_R2,
-    AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
-    AV_CODEC_ID_ADPCM_IMA_EA_EACS,
-    AV_CODEC_ID_ADPCM_EA_XAS,
-    AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
-    AV_CODEC_ID_ADPCM_IMA_ISS,
-    AV_CODEC_ID_ADPCM_G722,
-    AV_CODEC_ID_ADPCM_IMA_APC,
-    AV_CODEC_ID_ADPCM_VIMA,
-    AV_CODEC_ID_ADPCM_AFC  = $11800,
-    AV_CODEC_ID_ADPCM_IMA_OKI,
-    AV_CODEC_ID_ADPCM_DTK,
-    AV_CODEC_ID_ADPCM_IMA_RAD,
-    AV_CODEC_ID_ADPCM_G726LE,
-    AV_CODEC_ID_ADPCM_THP_LE,
-    AV_CODEC_ID_ADPCM_PSX,
-    AV_CODEC_ID_ADPCM_AICA,
-    AV_CODEC_ID_ADPCM_IMA_DAT4,
-    AV_CODEC_ID_ADPCM_MTAF,
-
-    //* AMR */
-    AV_CODEC_ID_AMR_NB = $12000,
-    AV_CODEC_ID_AMR_WB,
-
-    //* RealAudio codecs*/
-    AV_CODEC_ID_RA_144 = $13000,
-    AV_CODEC_ID_RA_288,
-
-    //* various DPCM codecs */
-    AV_CODEC_ID_ROQ_DPCM = $14000,
-    AV_CODEC_ID_INTERPLAY_DPCM,
-    AV_CODEC_ID_XAN_DPCM,
-    AV_CODEC_ID_SOL_DPCM,
-
-    AV_CODEC_ID_SDX2_DPCM = $14800,
-    AV_CODEC_ID_GREMLIN_DPCM,
-
-    //* audio codecs */
-    AV_CODEC_ID_MP2 = $15000,
-    AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
-    AV_CODEC_ID_AAC,
-    AV_CODEC_ID_AC3,
-    AV_CODEC_ID_DTS,
-    AV_CODEC_ID_VORBIS,
-    AV_CODEC_ID_DVAUDIO,
-    AV_CODEC_ID_WMAV1,
-    AV_CODEC_ID_WMAV2,
-    AV_CODEC_ID_MACE3,
-    AV_CODEC_ID_MACE6,
-    AV_CODEC_ID_VMDAUDIO,
-    AV_CODEC_ID_FLAC,
-    AV_CODEC_ID_MP3ADU,
-    AV_CODEC_ID_MP3ON4,
-    AV_CODEC_ID_SHORTEN,
-    AV_CODEC_ID_ALAC,
-    AV_CODEC_ID_WESTWOOD_SND1,
-    AV_CODEC_ID_GSM, ///< as in Berlin toast format
-    AV_CODEC_ID_QDM2,
-    AV_CODEC_ID_COOK,
-    AV_CODEC_ID_TRUESPEECH,
-    AV_CODEC_ID_TTA,
-    AV_CODEC_ID_SMACKAUDIO,
-    AV_CODEC_ID_QCELP,
-    AV_CODEC_ID_WAVPACK,
-    AV_CODEC_ID_DSICINAUDIO,
-    AV_CODEC_ID_IMC,
-    AV_CODEC_ID_MUSEPACK7,
-    AV_CODEC_ID_MLP,
-    AV_CODEC_ID_GSM_MS, { as found in WAV }
-    AV_CODEC_ID_ATRAC3,
-    AV_CODEC_ID_APE,
-    AV_CODEC_ID_NELLYMOSER,
-    AV_CODEC_ID_MUSEPACK8,
-    AV_CODEC_ID_SPEEX,
-    AV_CODEC_ID_WMAVOICE,
-    AV_CODEC_ID_WMAPRO,
-    AV_CODEC_ID_WMALOSSLESS,
-    AV_CODEC_ID_ATRAC3P,
-    AV_CODEC_ID_EAC3,
-    AV_CODEC_ID_SIPR,
-    AV_CODEC_ID_MP1,
-    AV_CODEC_ID_TWINVQ,
-    AV_CODEC_ID_TRUEHD,
-    AV_CODEC_ID_MP4ALS,
-    AV_CODEC_ID_ATRAC1,
-    AV_CODEC_ID_BINKAUDIO_RDFT,
-    AV_CODEC_ID_BINKAUDIO_DCT,
-    AV_CODEC_ID_AAC_LATM,
-    AV_CODEC_ID_QDMC,
-    AV_CODEC_ID_CELT,
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-    AV_CODEC_ID_BMV_AUDIO,
-    AV_CODEC_ID_RALF,
-    AV_CODEC_ID_IAC,
-    AV_CODEC_ID_ILBC,
-    AV_CODEC_ID_OPUS,
-    AV_CODEC_ID_COMFORT_NOISE,
-    AV_CODEC_ID_TAK,
-    AV_CODEC_ID_PAF_AUDIO,
-    AV_CODEC_ID_ON2AVC,
-    AV_CODEC_ID_DSS_SP,
-    AV_CODEC_ID_CODEC2,
-
-    AV_CODEC_ID_FFWAVESYNTH = $15800,
-    AV_CODEC_ID_SONIC,
-    AV_CODEC_ID_SONIC_LS,
-    AV_CODEC_ID_EVRC,
-    AV_CODEC_ID_SMV,
-    AV_CODEC_ID_DSD_LSBF,
-    AV_CODEC_ID_DSD_MSBF,
-    AV_CODEC_ID_DSD_LSBF_PLANAR,
-    AV_CODEC_ID_DSD_MSBF_PLANAR,
-    AV_CODEC_ID_4GV,
-    AV_CODEC_ID_INTERPLAY_ACM,
-    AV_CODEC_ID_XMA1,
-    AV_CODEC_ID_XMA2,
-    AV_CODEC_ID_DST,
-    AV_CODEC_ID_ATRAC3AL,
-    AV_CODEC_ID_ATRAC3PAL,
-    AV_CODEC_ID_DOLBY_E,
-    AV_CODEC_ID_APTX,
-    AV_CODEC_ID_APTX_HD,
-    AV_CODEC_ID_SBC,
-
-    //* subtitle codecs */
-    AV_CODEC_ID_FIRST_SUBTITLE = $17000,          ///< A dummy ID pointing at the start of subtitle codecs.
-    AV_CODEC_ID_DVD_SUBTITLE   = $17000,
-    AV_CODEC_ID_DVB_SUBTITLE,
-    AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
-    AV_CODEC_ID_XSUB,
-    AV_CODEC_ID_SSA,
-    AV_CODEC_ID_MOV_TEXT,
-    AV_CODEC_ID_HDMV_PGS_SUBTITLE,
-    AV_CODEC_ID_DVB_TELETEXT,
-    AV_CODEC_ID_SRT,
-    AV_CODEC_ID_MICRODVD   = $17800,
-    AV_CODEC_ID_EIA_608,
-    AV_CODEC_ID_JACOSUB,
-    AV_CODEC_ID_SAMI,
-    AV_CODEC_ID_REALTEXT,
-    AV_CODEC_ID_STL,
-    AV_CODEC_ID_SUBVIEWER1,
-    AV_CODEC_ID_SUBVIEWER,
-    AV_CODEC_ID_SUBRIP,
-    AV_CODEC_ID_WEBVTT,
-    AV_CODEC_ID_MPL2,
-    AV_CODEC_ID_VPLAYER,
-    AV_CODEC_ID_PJS,
-    AV_CODEC_ID_ASS,
-    AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
-
-    //* other specific kind of codecs (generally used for attachments) */
-    AV_CODEC_ID_FIRST_UNKNOWN = $18000,           ///< A dummy ID pointing at the start of various fake codecs.
-    AV_CODEC_ID_TTF = $18000,
-
-    AV_CODEC_ID_SCTE_35, ///< Contain timestamp estimated through PCR of program stream.
-    AV_CODEC_ID_BINTEXT    = $18800,
-    AV_CODEC_ID_XBIN,
-    AV_CODEC_ID_IDF,
-    AV_CODEC_ID_OTF,
-    AV_CODEC_ID_SMPTE_KLV,
-    AV_CODEC_ID_DVD_NAV,
-    AV_CODEC_ID_TIMED_ID3,
-    AV_CODEC_ID_BIN_DATA,
-
-    AV_CODEC_ID_PROBE = $19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
-
-    AV_CODEC_ID_MPEG2TS = $20000, (**< _FAKE_ codec to indicate a raw MPEG-2 TS
-                               * stream (only used by libavformat) *)
-    AV_CODEC_ID_MPEG4SYSTEMS = $20001, (**< _FAKE_ codec to indicate a MPEG-4 Systems
-                                 * stream (only used by libavformat) *)
-    AV_CODEC_ID_FFMETADATA = $21000,   ///< Dummy codec for streams containing only metadata information.
-    AV_CODEC_ID_WRAPPED_AVFRAME = $21001 ///< Passthrough codec, AVFrames wrapped in AVPacket
-  );
-
-type
-  TCodecType = TAVMediaType;
-
-const
-  CODEC_TYPE_UNKNOWN    = AVMEDIA_TYPE_UNKNOWN;
-  CODEC_TYPE_VIDEO      = AVMEDIA_TYPE_VIDEO;
-  CODEC_TYPE_AUDIO      = AVMEDIA_TYPE_AUDIO;
-  CODEC_TYPE_DATA       = AVMEDIA_TYPE_DATA;
-  CODEC_TYPE_SUBTITLE   = AVMEDIA_TYPE_SUBTITLE;
-  CODEC_TYPE_ATTACHMENT = AVMEDIA_TYPE_ATTACHMENT;
-  CODEC_TYPE_NB         = AVMEDIA_TYPE_NB;
-
-(**
- * This struct describes the properties of a single codec described by an
- * AVCodecID.
- * @see avcodec_descriptor_get()
- *)
-type
-
-  (**
-   * AVProfile.
-   *)
-  PAVProfile = ^TAVProfile;
-  TAVProfile = record
-    profile: cint;
-    name: {const} PAnsiChar; ///< short name for the profile
-  end; {TAVProfile}
-
-  PAVCodecHWConfig = ^TAVCodecHWConfig;
-  TAVCodecHWConfig = record
-    (**
-     * A hardware pixel format which the codec can use.
-     *)
-    pix_fmt: TAVPixelFormat;
-    (**
-     * Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
-     * setup methods which can be used with this configuration.
-     *)
-    methods: cint;
-    (**
-     * The device type associated with the configuration.
-     *
-     * Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
-     * AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
-     *)
-    device_type: pointer; {TAVHWDeviceType}
-  end; {TAVCodecHWConfig}
-
-  PAVCodecDescriptor = ^TAVCodecDescriptor;
-  TAVCodecDescriptor = record
-    id: TAVCodecID;
-    type_: TAVMediaType;
-    (**
-     * Name of the codec described by this descriptor. It is non-empty and
-     * unique for each codec descriptor. It should contain alphanumeric
-     * characters and '_' only.
-     *)
-    name: PAnsiChar;
-    (**
-     * A more descriptive name for this codec. May be NULL.
-     *)
-    long_name: PAnsiChar;
-    (**
-     * Codec properties, a combination of AV_CODEC_PROP_* flags.
-     *)
-    props: cint;
-
-    (**
-     * MIME type(s) associated with the codec.
-     * May be NULL; if not, a NULL-terminated array of MIME types.
-     * The first item is always non-NULL and is the preferred MIME type.
-     *)
-    mime_types: PAnsiChar;
-
-    (**
-     * If non-NULL, an array of profiles recognized for this codec.
-     * Terminated with FF_PROFILE_UNKNOWN.
-     *)
-    profiles: PAVProfile;
-  end;
-
-const
-(**
- * Codec uses only intra compression.
- * Video and audio codecs only.
- *)
-  AV_CODEC_PROP_INTRA_ONLY     = 1 << 0;
-(**
- * Codec supports lossy compression. Audio and video codecs only.
- * @note a codec may support both lossy and lossless
- * compression modes
- *)
-  AV_CODEC_PROP_LOSSY          = 1 << 1;
-(**
- * Codec supports lossless compression. Audio and video codecs only.
- *)
-  AV_CODEC_PROP_LOSSLESS       = 1 << 2;
-(**
- * Codec supports frame reordering. That is, the coded order (the order in which
- * the encoded packets are output by the encoders / stored / input to the
- * decoders) may be different from the presentation order of the corresponding
- * frames.
- *
- * For codecs that do not have this property set, PTS and DTS should always be
- * equal.
- *)
-  AV_CODEC_PROP_REORDER        = 1 << 3;
-(**
- * Subtitle codec is bitmap based
- * Decoded AVSubtitle data can be read from the AVSubtitleRect->pict field.
- *)
-  AV_CODEC_PROP_BITMAP_SUB     = 1 << 16;
-(**
- * Subtitle codec is text based.
- * Decoded AVSubtitle data can be read from the AVSubtitleRect->ass field.
- *)
-  AV_CODEC_PROP_TEXT_SUB       = 1 << 17;
-
-(**
- * @ingroup lavc_decoding
- * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
- * This is mainly needed because some optimized bitstream readers read
- * 32 or 64 bit at once and could read over the end.<br>
- * Note: If the first 23 bits of the additional bytes are not 0, then damaged
- * MPEG bitstreams could cause overread and segfault.
- *)
-  AV_INPUT_BUFFER_PADDING_SIZE = 64;
-
-(**
- * @ingroup lavc_decoding
- * minimum encoding buffer size.
- * Used to avoid some checks during header writing.
- *)
-  AV_INPUT_BUFFER_MIN_SIZE = 16384;
-
-type
-
-(**
- * @ingroup lavc_decoding
- *)
-  TAVDiscard = (
-    (* We leave some space between them for extensions (drop some
-     * keyframes for intra-only or drop just some bidir frames).
-     *)
-    AVDISCARD_NONE    = -16, ///< discard nothing
-    AVDISCARD_DEFAULT =   0, ///< discard useless packets like 0 size packets in avi
-    AVDISCARD_NONREF  =   8, ///< discard all non reference
-    AVDISCARD_BIDIR   =  16, ///< discard all bidirectional frames
-    AVDISCARD_NONINTRA=  24, ///< discard all non intra frames
-    AVDISCARD_NONKEY  =  32, ///< discard all frames except keyframes
-    AVDISCARD_ALL     =  48  ///< discard all
-  );
-
-{ removed, kept for the moment
-  TAVColorPrimaries = (
-    AVCOL_PRI_BT709       = 1, ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
-    AVCOL_PRI_UNSPECIFIED = 2,
-    AVCOL_PRI_BT470M      = 4,
-    AVCOL_PRI_BT470BG     = 5, ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
-    AVCOL_PRI_SMPTE170M   = 6, ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
-    AVCOL_PRI_SMPTE240M   = 7, ///< functionally identical to above
-    AVCOL_PRI_FILM        = 8,
-    AVCOL_PRI_BT2020      = 9, ///< ITU-R BT2020
-    AVCOL_PRI_NB               ///< Not part of ABI
-  );
-
-  TAVColorTransferCharacteristic = (
-    AVCOL_TRC_BT709        =  1, ///< also ITU-R BT1361
-    AVCOL_TRC_UNSPECIFIED  =  2,
-    AVCOL_TRC_GAMMA22      =  4, ///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
-    AVCOL_TRC_GAMMA28      =  5, ///< also ITU-R BT470BG
-    AVCOL_TRC_SMPTE170M    =  6, ///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
-    AVCOL_TRC_SMPTE240M    =  7,
-    AVCOL_TRC_LINEAR       =  8, ///< "Linear transfer characteristics"
-    AVCOL_TRC_LOG          =  9, ///< "Logarithmic transfer characteristic (100:1 range)"
-    AVCOL_TRC_LOG_SQRT     = 10, ///< "Logarithmic transfer characteristic (100 * Sqrt( 10 ) : 1 range)"
-    AVCOL_TRC_IEC61966_2_4 = 11, ///< IEC 61966-2-4
-    AVCOL_TRC_BT1361_ECG   = 12, ///< ITU-R BT1361 Extended Colour Gamut
-    AVCOL_TRC_IEC61966_2_1 = 13, ///< IEC 61966-2-1 (sRGB or sYCC)
-    AVCOL_TRC_BT2020_10    = 14, ///< ITU-R BT2020 for 10 bit system
-    AVCOL_TRC_BT2020_12    = 15, ///< ITU-R BT2020 for 12 bit system
-    AVCOL_TRC_NB                 ///< Not part of ABI
-  );
-
-(**
- *  X   X      3 4 X      X are luma samples,
- *             1 2        1-6 are possible chroma positions
- *  X   X      5 6 X      0 is undefined/unknown position
- *)
-  TAVChromaLocation = (
-    AVCHROMA_LOC_UNSPECIFIED = 0,
-    AVCHROMA_LOC_LEFT        = 1, ///< mpeg2/4, h264 default
-    AVCHROMA_LOC_CENTER      = 2, ///< mpeg1, jpeg, h263
-    AVCHROMA_LOC_TOPLEFT     = 3, ///< DV
-    AVCHROMA_LOC_TOP         = 4,
-    AVCHROMA_LOC_BOTTOMLEFT  = 5,
-    AVCHROMA_LOC_BOTTOM      = 6,
-    AVCHROMA_LOC_NB               ///< Not part of ABI
-  );
-}
-  TAVAudioServiceType =(
-    AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
-    AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
-    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
-    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
-    AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
-    AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
-    AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
-    AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
-    AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
-    AV_AUDIO_SERVICE_TYPE_NB                     ///< Not part of ABI
-  );
-
-(**
- * @ingroup lavc_decoding
- *)
-  PRcOverride = ^TRcOverride;
-  TRcOverride = record {16}
-    start_frame:    cint;
-    end_frame:      cint;
-    qscale:         cint; // if this is 0 then quality_factor will be used instead
-    quality_factor: cfloat;
-  end;
-
-const
-(* encoding support
-   These flags can be passed in AVCodecContext.flags before initialization.
-   Note: Not everything is supported yet.
-*)
-
-(**
- * Allow decoders to produce frames with data planes that are not aligned
- * to CPU requirements (e.g. due to cropping).
- *)
-  AV_CODEC_FLAG_UNALIGNED      = $0001; // (1 <<  0)
-(**
- * Use fixed qscale.
- *)
-  AV_CODEC_FLAG_QSCALE         = $0002; // (1 <<  1)
-(**
- * 4 MV per MB allowed / advanced prediction for H.263.
- *)
-  AV_CODEC_FLAG_4MV            = $0004; // (1 <<  2)
-(**
- * Output even those frames that might be corrupted.
- *)
-  AV_CODEC_FLAG_OUTPUT_CORRUPT = $0008; // (1 <<  3)
-(**
- * Use qpel MC.
- *)
-  AV_CODEC_FLAG_QPEL           = $0010; // (1 <<  4)
-(**
- * Use internal 2pass ratecontrol in first pass mode.
- *)
-  AV_CODEC_FLAG_PASS1          = $0200; // (1 <<  9)
-(**
- * Use internal 2pass ratecontrol in second pass mode.
- *)
-  AV_CODEC_FLAG_PASS2          = $0400; // (1 << 10)
-(**
- * loop filter.
- *)
-  AV_CODEC_FLAG_LOOP_FILTER    = $0800; // (1 << 11)
-(**
- * Only decode/encode grayscale.
- *)
-  AV_CODEC_FLAG_GRAY           = $2000; // (1 << 13)
-(**
- * error[?] variables will be set during encoding.
- *)
-  AV_CODEC_FLAG_PSNR           = $8000; // (1 << 15)
-(**
- * Input bitstream might be truncated at a random location
- * instead of only at frame boundaries.
- *)
-  AV_CODEC_FLAG_TRUNCATED      = $10000; // (1 << 16)
-(**
- * Use interlaced DCT.
- *)
-  AV_CODEC_FLAG_INTERLACED_DCT = $40000; // (1 << 18)
-(**
- * Force low delay.
- *)
-  AV_CODEC_FLAG_LOW_DELAY      = $80000; // (1 << 19)
-(**
- * Place global headers in extradata instead of every keyframe.
- *)
-  AV_CODEC_FLAG_GLOBAL_HEADER  = $400000; // (1 << 22)
-(**
- * Use only bitexact stuff (except (I)DCT).
- *)
-  AV_CODEC_FLAG_BITEXACT       = $800000; // (1 << 23)
-(* Fx : Flag for H.263+ extra options *)
-(**
- * H.263 advanced intra coding / MPEG-4 AC prediction
- *)
-  AV_CODEC_FLAG_AC_PRED        = $1000000; // (1 << 24)
-(**
- * interlaced motion estimation
- *)
-  AV_CODEC_FLAG_INTERLACED_ME  = $20000000; // (1 << 29)
-  AV_CODEC_FLAG_CLOSED_GOP     = $80000000; // (1U << 31)
-
-(**
- * Allow non spec compliant speedup tricks.
- *)
-  AV_CODEC_FLAG2_FAST          = $0001; // (1 <<  0)
-(**
- * Skip bitstream encoding.
- *)
-  AV_CODEC_FLAG2_NO_OUTPUT     = $0004; // (1 <<  2)
-(**
- * Place global headers at every keyframe instead of in extradata.
- *)
-  AV_CODEC_FLAG2_LOCAL_HEADER  = $0008; // (1 <<  3)
-
-(**
- * timecode is in drop frame format. DEPRECATED!!!!
- *)
-  AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = $2000; // (1 << 13)
-
-(**
- * Input bitstream might be truncated at a packet boundaries
- * instead of only at frame boundaries.
- *)
-  AV_CODEC_FLAG2_CHUNKS        = $8000; // (1 << 15)
-(**
- * Discard cropping information from SPS.
- *)
-  AV_CODEC_FLAG2_IGNORE_CROP   = $10000; // (1 << 16)
-
-(**
- * Show all frames before the first keyframe
- *)
-  AV_CODEC_FLAG2_SHOW_ALL      = $400000; // (1 << 22)
-(**
- * Export motion vectors through frame side data
- *)
-  AV_CODEC_FLAG2_EXPORT_MVS    = $10000000; // (1 << 28)
-(**
- * Do not skip samples and export skip information as frame side data
- *)
-  AV_CODEC_FLAG2_SKIP_MANUAL   = $20000000; // (1 << 29)
-(**
- * Do not reset ASS ReadOrder field on flush (subtitles decoding)
- *)
-  AV_CODEC_FLAG2_RO_FLUSH_NOOP = $40000000;
-
-(* Unsupported options :
- *              Syntax Arithmetic coding (SAC)
- *              Reference Picture Selection
- *              Independent Segment Decoding *)
-(* /Fx *)
-(* codec capabilities *)
-
-(**
- * Decoder can use draw_horiz_band callback.
- *)
-  AV_CODEC_CAP_DRAW_HORIZ_BAND = $0001; // (1 <<  0)
-(**
- * Codec uses get_buffer() for allocating buffers and supports custom allocators.
- * If not set, it might not use get_buffer() at all or use operations that
- * assume the buffer was allocated by avcodec_default_get_buffer.
- *)
-  AV_CODEC_CAP_DR1             = $0002; // (1 <<  1)
-  AV_CODEC_CAP_TRUNCATED       = $0008; // (1 <<  3)
-(**
- * Encoder or decoder requires flushing with NULL input at the end in order to
- * give the complete and correct output.
- *
- * NOTE: If this flag is not set, the codec is guaranteed to never be fed with
- *       with NULL data. The user can still send NULL data to the public encode
- *       or decode function, but libavcodec will not pass it along to the codec
- *       unless this flag is set.
- *
- * Decoders:
- * The decoder has a non-zero delay and needs to be fed with avpkt->data=NULL,
- * avpkt->size=0 at the end to get the delayed data until the decoder no longer
- * returns frames.
- *
- * Encoders:
- * The encoder needs to be fed with NULL data at the end of encoding until the
- * encoder no longer returns data.
- *
- * NOTE: For encoders implementing the AVCodec.encode2() function, setting this
- *       flag also means that the encoder must set the pts and duration for
- *       each output packet. If this flag is not set, the pts and duration will
- *       be determined by libavcodec from the input frame.
- *)
-  AV_CODEC_CAP_DELAY           = $0020; // (1 <<  5)
-(**
- * Codec can be fed a final frame with a smaller size.
- * This can be used to prevent truncation of the last audio samples.
- *)
-  AV_CODEC_CAP_SMALL_LAST_FRAME = $0040; // (1 <<  6)
-
-(**
- * Codec can output multiple frames per AVPacket
- * Normally demuxers return one frame at a time, demuxers which do not do
- * are connected to a parser to split what they return into proper frames.
- * This flag is reserved to the very rare category of codecs which have a
- * bitstream that cannot be split into frames without timeconsuming
- * operations like full decoding. Demuxers carrying such bitstreams thus
- * may return multiple frames in a packet. This has many disadvantages like
- * prohibiting stream copy in many cases thus it should only be considered
- * as a last resort.
- *)
-  AV_CODEC_CAP_SUBFRAMES       = $0100; // (1 <<  8)
-(**
- * Codec is experimental and is thus avoided in favor of non experimental
- * encoders
- *)
-  AV_CODEC_CAP_EXPERIMENTAL    = $0200; // (1 <<  9)
-(**
- * Codec should fill in channel configuration and samplerate instead of container
- *)
-  AV_CODEC_CAP_CHANNEL_CONF    = $0400; // (1 << 10)
-(**
- * Codec supports frame-level multithreading.
- *)
-  AV_CODEC_CAP_FRAME_THREADS   = $1000; // (1 << 12)
-(**
- * Codec supports slice-based (or partition-based) multithreading.
- *)
-  AV_CODEC_CAP_SLICE_THREADS   = $2000; // (1 << 13)
-(**
- * Codec supports changed parameters at any point.
- *)
-  AV_CODEC_CAP_PARAM_CHANGE    = $4000; // (1 << 14)
-(**
- * Codec supports avctx->thread_count == 0 (auto).
- *)
-  AV_CODEC_CAP_AUTO_THREADS    = $8000; // (1 << 15)
-(**
- * Audio encoder supports receiving a different number of samples in each call.
- *)
-  AV_CODEC_CAP_VARIABLE_FRAME_SIZE = $10000; // (1 << 16)
-(**
- * Decoder is not a preferred choice for probing.
- * This indicates that the decoder is not a good choice for probing.
- * It could for example be an expensive to spin up hardware decoder,
- * or it could simply not provide a lot of useful information about
- * the stream.
- * A decoder marked with this flag should only be used as last resort
- * choice for probing.
- *)
-  AV_CODEC_CAP_AVOID_PROBING   = $20000;  // (1 << 17)
-
-(**
- * Codec is intra only.
- *)
-  AV_CODEC_CAP_INTRA_ONLY    = $40000000;
-(**
- * Codec is lossless.
- *)
-  AV_CODEC_CAP_LOSSLESS      = $80000000;
-
-(**
- * Codec is backed by a hardware implementation. Typically used to
- * identify a non-hwaccel hardware decoder. For information about hwaccels, use
- * avcodec_get_hw_config() instead.
- *)
-  AV_CODEC_CAP_HARDWARE      = $40000;
-
-(**
- * Codec is potentially backed by a hardware implementation, but not
- * necessarily. This is used instead of AV_CODEC_CAP_HARDWARE, if the
- * implementation provides some sort of internal fallback.
- *)
-  AV_CODEC_CAP_HYBRID        = $80000;
-
-(** Note bits 24-31 are reserved for codec specific use (H.264 ref0, MPEG-1 0mv, ...) *)
-
-(**
- * The decoder will keep a reference to the frame and may reuse it later.
- *)
-  AV_GET_BUFFER_FLAG_REF = 1 << 0;
-
-  FF_COMPRESSION_DEFAULT = -1;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-  FF_PRED_LEFT   = 0;
-  FF_PRED_PLANE  = 1;
-  FF_PRED_MEDIAN = 2;
-{$ENDIF}
-
-  FF_CMP_SAD        = 0;
-  FF_CMP_SSE        = 1;
-  FF_CMP_SATD       = 2;
-  FF_CMP_DCT        = 3;
-  FF_CMP_PSNR       = 4;
-  FF_CMP_BIT        = 5;
-  FF_CMP_RD         = 6;
-  FF_CMP_ZERO       = 7;
-  FF_CMP_VSAD       = 8;
-  FF_CMP_VSSE       = 9;
-  FF_CMP_NSSE       = 10;
-  FF_CMP_W53        = 11;
-  FF_CMP_W97        = 12;
-  FF_CMP_DCTMAX     = 13;
-  FF_CMP_DCT264     = 14;
-  FF_CMP_MEDIAN_SAD = 15;
-  FF_CMP_CHROMA     = 256;
-
-{$IFDEF FF_API_QUANT_BIAS}
-  FF_DEFAULT_QUANT_BIAS   = 999999;
-{$ENDIF}
-
-  SLICE_FLAG_CODED_ORDER    = $0001; ///< draw_horiz_band() is called in coded order instead of display
-  SLICE_FLAG_ALLOW_FIELD    = $0002; ///< allow draw_horiz_band() with field slices (MPEG-2 field pics)
-  SLICE_FLAG_ALLOW_PLANE    = $0004; ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
-
-  FF_MB_DECISION_SIMPLE = 0;        ///< uses mb_cmp
-  FF_MB_DECISION_BITS   = 1;        ///< chooses the one which needs the fewest bits
-  FF_MB_DECISION_RD     = 2;        ///< rate distortion
-
-{$IFDEF FF_API_CODER_TYPE}
-  FF_CODER_TYPE_VLC       = 0;
-  FF_CODER_TYPE_AC        = 1;
-  FF_CODER_TYPE_RAW       = 2;
-  FF_CODER_TYPE_RLE       = 3;
-{$ENDIF}
-  FF_BUG_AUTODETECT       = 1;  ///< autodetection
-  FF_BUG_XVID_ILACE       = 4;
-  FF_BUG_UMP4             = 8;
-  FF_BUG_NO_PADDING       = 16;
-  FF_BUG_AMV              = 32;
-  FF_BUG_QPEL_CHROMA      = 64;
-  FF_BUG_STD_QPEL         = 128;
-  FF_BUG_QPEL_CHROMA2     = 256;
-  FF_BUG_DIRECT_BLOCKSIZE = 512;
-  FF_BUG_EDGE             = 1024;
-  FF_BUG_HPEL_CHROMA      = 2048;
-  FF_BUG_DC_CLIP          = 4096;
-  FF_BUG_MS               = 8192; ///< workaround various bugs in microsofts broken decoders
-  FF_BUG_TRUNCATED        = 16384;
-  FF_BUG_IEDGE            = 32768;
-
-  FF_COMPLIANCE_VERY_STRICT   =  2; ///< strictly conform to an older more strict version of the spec or reference software
-  FF_COMPLIANCE_STRICT        =  1; ///< strictly conform to all the things in the spec no matter what consequences
-  FF_COMPLIANCE_NORMAL        =  0;
-  FF_COMPLIANCE_UNOFFICIAL    = -1; ///< Allow unofficial extensions
-  FF_COMPLIANCE_EXPERIMENTAL  = -2; ///< Allow nonstandardized experimental things.
-
-  FF_EC_GUESS_MVS   = 1;
-  FF_EC_DEBLOCK     = 2;
-  FF_EC_FAVOR_INTER = 256;
-
-  FF_DEBUG_PICT_INFO    = 1;
-  FF_DEBUG_RC           = 2;
-  FF_DEBUG_BITSTREAM    = 4;
-  FF_DEBUG_MB_TYPE      = 8;
-  FF_DEBUG_QP           = 16;
-{$IFDEF FF_API_DEBUG_MV}
-(**
- * @deprecated this option does nothing
- *)
-  FF_DEBUG_MV           = 32;
-{$ENDIF}
-  FF_DEBUG_DCT_COEFF    = $00000040;
-  FF_DEBUG_SKIP         = $00000080;
-  FF_DEBUG_STARTCODE    = $00000100;
-  FF_DEBUG_ER           = $00000400;
-  FF_DEBUG_MMCO         = $00000800;
-  FF_DEBUG_BUGS         = $00001000;
-{$IFDEF FF_API_DEBUG_MV}
-  FF_DEBUG_VIS_QP       = $00002000;
-  FF_DEBUG_VIS_MB_TYPE  = $00004000;
-{$ENDIF}
-  FF_DEBUG_BUFFERS      = $00008000;
-  FF_DEBUG_THREADS      = $00010000;
-  FF_DEBUG_GREEN_MD     = $00800000;
-  FF_DEBUG_NOMC         = $01000000;
-
-  FF_DEBUG_VIS_MV_P_FOR  = $00000001; // visualize forward predicted MVs of P-frames
-  FF_DEBUG_VIS_MV_B_FOR  = $00000002; // visualize forward predicted MVs of B-frames
-  FF_DEBUG_VIS_MV_B_BACK = $00000004; // visualize backward predicted MVs of B-frames
-
-(**
- * Verify checksums embedded in the bitstream (could be of either encoded or
- * decoded data, depending on the codec) and print an error message on mismatch.
- * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
- * decoder returning an error.
- *)
-  AV_EF_CRCCHECK  = 1;
-  AV_EF_BITSTREAM = 2;          ///< detect bitstream specification deviations
-  AV_EF_BUFFER    = 4;          ///< detect improper bitstream length
-  AV_EF_EXPLODE   = 8;          ///< abort decoding on minor error detection
-
-  AV_EF_IGNORE_ERR = 32768;     ///< ignore errors and continue
-  AV_EF_CAREFUL    = 65536;     ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
-  AV_EF_COMPLIANT  = 131072;    ///< consider all spec non compliances as errors
-  AV_EF_AGGRESSIVE = 262144;    ///< consider things that a sane encoder should not do as an error
-
-  FF_DCT_AUTO    = 0;
-  FF_DCT_FASTINT = 1;
-  FF_DCT_INT     = 2;
-  FF_DCT_MMX     = 3;
-  FF_DCT_MLIB    = 4;
-  FF_DCT_ALTIVEC = 5;
-  FF_DCT_FAAN    = 6;
-
-  FF_IDCT_AUTO         = 0;
-  FF_IDCT_INT          = 1;
-  FF_IDCT_SIMPLE       = 2;
-  FF_IDCT_SIMPLEMMX    = 3;
-  FF_IDCT_ARM          = 7;
-  FF_IDCT_ALTIVEC      = 8;
-  FF_IDCT_SIMPLEARM    = 10;
-  FF_IDCT_XVID         = 14;
-  FF_IDCT_SIMPLEARMV5TE= 16;
-  FF_IDCT_SIMPLEARMV6  = 17;
-  FF_IDCT_FAAN         = 20;
-  FF_IDCT_SIMPLENEON   = 22;
-  FF_IDCT_NONE         = 24; (* Used by XvMC to extract IDCT coefficients with FF_IDCT_PERM_NONE *)
-  FF_IDCT_SIMPLEAUTO   = 128;
-
-  FF_THREAD_FRAME   = 1; ///< Decode more than one frame at once
-  FF_THREAD_SLICE   = 2; ///< Decode more than one part of a single frame at once
-
-  FF_PROFILE_UNKNOWN  = -99;
-  FF_PROFILE_RESERVED = -100;
-
-  FF_PROFILE_AAC_MAIN = 0;
-  FF_PROFILE_AAC_LOW  = 1;
-  FF_PROFILE_AAC_SSR  = 2;
-  FF_PROFILE_AAC_LTP  = 3;
-  FF_PROFILE_AAC_HE   = 4;
-  FF_PROFILE_AAC_HE_V2 = 28;
-  FF_PROFILE_AAC_LD   = 22;
-  FF_PROFILE_AAC_ELD  = 38;
-  FF_PROFILE_MPEG2_AAC_LOW = 128;
-  FF_PROFILE_MPEG2_AAC_HE  = 131;
-
-  FF_PROFILE_DNXHD     = 0;
-  FF_PROFILE_DNXHR_LB  = 1;
-  FF_PROFILE_DNXHR_SQ  = 2;
-  FF_PROFILE_DNXHR_HQ  = 3;
-  FF_PROFILE_DNXHR_HQX = 4;
-  FF_PROFILE_DNXHR_444 = 5;
-
-  FF_PROFILE_DTS         = 20;
-  FF_PROFILE_DTS_ES      = 30;
-  FF_PROFILE_DTS_96_24   = 40;
-  FF_PROFILE_DTS_HD_HRA  = 50;
-  FF_PROFILE_DTS_HD_MA   = 60;
-  FF_PROFILE_DTS_EXPRESS = 70;
-
-  FF_PROFILE_MPEG2_422   =  0;
-  FF_PROFILE_MPEG2_HIGH  =  1;
-  FF_PROFILE_MPEG2_SS    =  2;
-  FF_PROFILE_MPEG2_SNR_SCALABLE = 3;
-  FF_PROFILE_MPEG2_MAIN  =  4;
-  FF_PROFILE_MPEG2_SIMPLE=  5;
-
-  FF_PROFILE_H264_CONSTRAINED  = (1 shl 9);  // 8+1; constraint_set1_flag
-  FF_PROFILE_H264_INTRA        = (1 shl 11); // 8+3; constraint_set3_flag
-
-  FF_PROFILE_H264_BASELINE             = 66;
-  FF_PROFILE_H264_CONSTRAINED_BASELINE = (66 or FF_PROFILE_H264_CONSTRAINED);
-  FF_PROFILE_H264_MAIN                 = 77;
-  FF_PROFILE_H264_EXTENDED             = 88;
-  FF_PROFILE_H264_HIGH                 = 100;
-  FF_PROFILE_H264_HIGH_10              = 110;
-  FF_PROFILE_H264_HIGH_10_INTRA        = (110 or FF_PROFILE_H264_INTRA);
-  FF_PROFILE_H264_MULTIVIEW_HIGH       = 118;
-  FF_PROFILE_H264_HIGH_422             = 122;
-  FF_PROFILE_H264_HIGH_422_INTRA       = (122 or FF_PROFILE_H264_INTRA);
-  FF_PROFILE_H264_STEREO_HIGH          = 128;
-  FF_PROFILE_H264_HIGH_444             = 144;
-  FF_PROFILE_H264_HIGH_444_PREDICTIVE  = 244;
-  FF_PROFILE_H264_HIGH_444_INTRA       = (244 or FF_PROFILE_H264_INTRA);
-  FF_PROFILE_H264_CAVLC_444            = 44;
-
-  FF_PROFILE_VC1_SIMPLE   = 0;
-  FF_PROFILE_VC1_MAIN     = 1;
-  FF_PROFILE_VC1_COMPLEX  = 2;
-  FF_PROFILE_VC1_ADVANCED = 3;
-
-  FF_PROFILE_MPEG4_SIMPLE                    = 0;
-  FF_PROFILE_MPEG4_SIMPLE_SCALABLE           = 1;
-  FF_PROFILE_MPEG4_CORE                      = 2;
-  FF_PROFILE_MPEG4_MAIN                      = 3;
-  FF_PROFILE_MPEG4_N_BIT                     = 4;
-  FF_PROFILE_MPEG4_SCALABLE_TEXTURE          = 5;
-  FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION     = 6;
-  FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE    = 7;
-  FF_PROFILE_MPEG4_HYBRID                    = 8;
-  FF_PROFILE_MPEG4_ADVANCED_REAL_TIME        = 9;
-  FF_PROFILE_MPEG4_CORE_SCALABLE             = 10;
-  FF_PROFILE_MPEG4_ADVANCED_CODING           = 11;
-  FF_PROFILE_MPEG4_ADVANCED_CORE             = 12;
-  FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;
-  FF_PROFILE_MPEG4_SIMPLE_STUDIO             = 14;
-  FF_PROFILE_MPEG4_ADVANCED_SIMPLE           = 15;
-
-  FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0  = 1;
-  FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1  = 2;
-  FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768;
-  FF_PROFILE_JPEG2000_DCINEMA_2K             = 3;
-  FF_PROFILE_JPEG2000_DCINEMA_4K             = 4;
-
-  FF_PROFILE_VP9_0                           = 0;
-  FF_PROFILE_VP9_1                           = 1;
-  FF_PROFILE_VP9_2                           = 2;
-  FF_PROFILE_VP9_3                           = 3;
-
-  FF_PROFILE_HEVC_MAIN                       = 1;
-  FF_PROFILE_HEVC_MAIN_10                    = 2;
-  FF_PROFILE_HEVC_MAIN_STILL_PICTURE         = 3;
-  FF_PROFILE_HEVC_REXT                       = 4;
-
-  FF_PROFILE_AV1_MAIN                        = 0;
-  FF_PROFILE_AV1_HIGH                        = 1;
-  FF_PROFILE_AV1_PROFESSIONAL                = 2;
-
-  FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT            = 192;
-  FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 193;
-  FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT         = 194;
-  FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS                = 195;
-  FF_PROFILE_MJPEG_JPEG_LS                         = 247;
-
-  FF_PROFILE_SBC_MSBC                        = 1;
-
-
-  FF_LEVEL_UNKNOWN    = -99;
-
-type
-
-  (**
-   * This structure describes the bitrate properties of an encoded bitstream. It
-   * roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
-   * parameters for H.264/HEVC.
-   *)
-  PAVCPBProperties = ^TAVCPBProperties;
-  TAVCPBProperties = record
-    (**
-     * Maximum bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     *)
-    max_bitrate: cint;
-    (**
-     * Minimum bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     *)
-    min_bitrate: cint;
-    (**
-     * Average bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     *)
-    avg_bitrate: cint;
-
-    (**
-     * The size of the buffer to which the ratecontrol is applied, in bits.
-     * Zero if unknown or unspecified.
-     *)
-    buffer_size: cint;
-
-    (**
-     * The delay between the time the packet this structure is associated with
-     * is received and the time when it should be decoded, in periods of a 27MHz
-     * clock.
-     *
-     * UINT64_MAX when unknown or unspecified.
-     *)
-    vbv_delay: cuint64;
-  end; {TAVCPBProperties}
-
-  TAVPacketSideDataType = (
-    (**
-     * An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
-     * bytes worth of palette. This side data signals that a new palette is
-     * present.
-     *)
-    AV_PKT_DATA_PALETTE,
-
-    (**
-     * The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
-     * that the extradata buffer was changed and the receiving side should
-     * act upon it appropriately. The new extradata is embedded in the side
-     * data buffer and should be immediately used for processing the current
-     * frame or packet.
-     *)
-    AV_PKT_DATA_NEW_EXTRADATA,
-
-    (**
-     * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
-     * @code
-     * u32le param_flags
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
-     *     s32le channel_count
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
-     *     u64le channel_layout
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
-     *     s32le sample_rate
-     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
-     *     s32le width
-     *     s32le height
-     * @endcode
-     *)
-    AV_PKT_DATA_PARAM_CHANGE,
-
-    (**
-     * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
-     * structures with info about macroblocks relevant to splitting the
-     * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
-     * That is, it does not necessarily contain info about all macroblocks,
-     * as long as the distance between macroblocks in the info is smaller
-     * than the target payload size.
-     * Each MB info structure is 12 bytes, and is laid out as follows:
-     * @code
-     * u32le bit offset from the start of the packet
-     * u8    current quantizer at the start of the macroblock
-     * u8    GOB number
-     * u16le macroblock address within the GOB
-     * u8    horizontal MV predictor
-     * u8    vertical MV predictor
-     * u8    horizontal MV predictor for block number 3
-     * u8    vertical MV predictor for block number 3
-     * @endcode
-     *)
-    AV_PKT_DATA_H263_MB_INFO,
-
-    (**
-     * This side data should be associated with an audio stream and contains
-     * ReplayGain information in form of the AVReplayGain struct.
-     *)
-    AV_PKT_DATA_REPLAYGAIN,
-
-    (**
-     * This side data contains a 3x3 transformation matrix describing an affine
-     * transformation that needs to be applied to the decoded video frames for
-     * correct presentation.
-     *
-     * See libavutil/display.h for a detailed description of the data.
-     *)
-    AV_PKT_DATA_DISPLAYMATRIX,
-
-    (**
-     * This side data should be associated with a video stream and contains
-     * Stereoscopic 3D information in form of the AVStereo3D struct.
-     *)
-    AV_PKT_DATA_STEREO3D,
-
-    (**
-     * This side data should be associated with an audio stream and corresponds
-     * to enum AVAudioServiceType.
-     *)
-    AV_PKT_DATA_AUDIO_SERVICE_TYPE,
-
-    (**
-     * This side data contains quality related information from the encoder.
-     * @code
-     * u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
-     * u8    picture type
-     * u8    error count
-     * u16   reserved
-     * u64le[error count] sum of squared differences between encoder in and output
-     * @endcode
-     *)
-    AV_PKT_DATA_QUALITY_STATS,
-
-    (**
-     * This side data contains an integer value representing the stream index
-     * of a "fallback" track.  A fallback track indicates an alternate
-     * track to use when the current track can not be decoded for some reason.
-     * e.g. no decoder available for codec.
-     *)
-    AV_PKT_DATA_FALLBACK_TRACK,
-
-    (**
-     * This side data corresponds to the AVCPBProperties struct.
-     *)
-    AV_PKT_DATA_CPB_PROPERTIES,
-
-    (**
-     * Recommmends skipping the specified number of samples
-     * @code
-     * u32le number of samples to skip from start of this packet
-     * u32le number of samples to skip from end of this packet
-     * u8    reason for start skip
-     * u8    reason for end   skip (0=padding silence, 1=convergence)
-     * @endcode
-     *)
-    AV_PKT_DATA_SKIP_SAMPLES,
-
-    (**
-     * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
-     * the packet may contain "dual mono" audio specific to Japanese DTV
-     * and if it is true, recommends only the selected channel to be used.
-     * @code
-     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)
-     * @endcode
-     *)
-    AV_PKT_DATA_JP_DUALMONO,
-
-    (**
-     * A list of zero terminated key/value strings. There is no end marker for
-     * the list, so it is required to rely on the side data size to stop.
-     *)
-    AV_PKT_DATA_STRINGS_METADATA,
-
-    (**
-     * Subtitle event position
-     * @code
-     * u32le x1
-     * u32le y1
-     * u32le x2
-     * u32le y2
-     * @endcode
-     *)
-    AV_PKT_DATA_SUBTITLE_POSITION,
-
-    (**
-     * Data found in BlockAdditional element of matroska container. There is
-     * no end marker for the data, so it is required to rely on the side data
-     * size to recognize the end. 8 byte id (as found in BlockAddId) followed
-     * by data.
-     *)
-    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
-
-    (**
-     * The optional first identifier line of a WebVTT cue.
-     *)
-    AV_PKT_DATA_WEBVTT_IDENTIFIER,
-
-    (**
-     * The optional settings (rendering instructions) that immediately
-     * follow the timestamp specifier of a WebVTT cue.
-     *)
-    AV_PKT_DATA_WEBVTT_SETTINGS,
-
-    (**
-     * A list of zero terminated key/value strings. There is no end marker for
-     * the list, so it is required to rely on the side data size to stop. This
-     * side data includes updated metadata which appeared in the stream.
-     *)
-    AV_PKT_DATA_METADATA_UPDATE,
-
-    (**
-     * MPEGTS stream ID, this is required to pass the stream ID
-     * information from the demuxer to the corresponding muxer.
-     *)
-    AV_PKT_DATA_MPEGTS_STREAM_ID,
-
-    (**
-     * Mastering display metadata (based on SMPTE-2086:2014). This metadata
-     * should be associated with a video stream and contains data in the form
-     * of the AVMasteringDisplayMetadata struct.
-     *)
-    AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
-
-    (**
-     * This side data should be associated with a video stream and corresponds
-     * to the AVSphericalMapping structure.
-     *)
-    AV_PKT_DATA_SPHERICAL,
-
-    (**
-     * Content light level (based on CTA-861.3). This metadata should be
-     * associated with a video stream and contains data in the form of the
-     * AVContentLightMetadata struct.
-     *)
-    AV_PKT_DATA_CONTENT_LIGHT_LEVEL,
-
-    (**
-     * ATSC A53 Part 4 Closed Captions. This metadata should be associated with
-     * a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
-     * The number of bytes of CC data is AVPacketSideData.size.
-     *)
-    AV_PKT_DATA_A53_CC,
-
-    (**
-     * This side data is encryption initialization data.
-     * The format is not part of ABI, use av_encryption_init_info_* methods to
-     * access.
-     */
-    AV_PKT_DATA_ENCRYPTION_INIT_INFO,
-
-    /**
-     * This side data contains encryption info for how to decrypt the packet.
-     * The format is not part of ABI, use av_encryption_info_* methods to access.
-     */
-    AV_PKT_DATA_ENCRYPTION_INFO,
-
-    /**
-     * The number of side data types.
-     * This is not part of the public API/ABI in the sense that it may
-     * change when new side data types are added.
-     * This must stay the last enum value.
-     * If its value becomes huge, some code using it
-     * needs to be updated as it assumes it to be smaller than other limits.
-     *)
-    AV_PKT_DATA_NB
+    AV_CODEC_ID_NONE
   );
-
-  PAVPacketSideData = ^TAVPacketSideData;
-  TAVPacketSideData = record
-    data:  PByte;
-    size:  cint;
-    type_: TAVPacketSideDataType;
+  PAVPicture = ^TAVPicture;
+  TAVPicture = record
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-(**
- * This structure stores compressed data. It is typically exported by demuxers
- * and then passed as input to decoders, or received as output from encoders and
- * then passed to muxers.
- *
- * For video, it should typically contain one compressed frame. For audio it may
- * contain several compressed frames. Encoders are allowed to output empty
- * packets, with no compressed data, containing only side data
- * (e.g. to update some stream parameters at the end of encoding).
- *
- * AVPacket is one of the few structs in FFmpeg, whose size is a part of public
- * ABI. Thus it may be allocated on stack and no new fields can be added to it
- * without libavcodec and libavformat major bump.
- *
- * The semantics of data ownership depends on the buf field.
- * If it is set, the packet data is dynamically allocated and is
- * valid indefinitely until a call to av_packet_unref() reduces the
- * reference count to 0.
- *
- * If the buf field is not set av_packet_ref() would make a copy instead
- * of increasing the reference count.
- *
- * The side data is always allocated with av_malloc(), copied by
- * av_packet_ref() and freed by av_packet_unref().
- *
- * @see av_packet_ref
- * @see av_packet_unref
- *)
-  PPAVPacket= ^PAVPacket;
   PAVPacket = ^TAVPacket;
   TAVPacket = record
-    (**
-     * A reference to the reference-counted buffer where the packet data is
-     * stored.
-     * May be NULL, then the packet data is not reference-counted.
-     *)
-    buf:          PAVBufferRef;
-    (*
-     * Presentation timestamp in AVStream->time_base units; the time at which
-     * the decompressed packet will be presented to the user.
-     * Can be AV_NOPTS_VALUE if it is not stored in the file.
-     * pts MUST be larger or equal to dts as presentation cannot happen before
-     * decompression, unless one wants to view hex dumps. Some formats misuse
-     * the terms dts and pts/cts to mean something different. Such timestamps
-     * must be converted to true pts/dts before they are stored in AVPacket.
-     *)
-    pts:          cint64;
-    (*
-     * Decompression timestamp in AVStream->time_base units; the time at which
-     * the packet is decompressed.
-     * Can be AV_NOPTS_VALUE if it is not stored in the file.
-     *)
-    dts:          cint64;
-    data:         PByteArray;
-    size:         cint;
-    stream_index: cint;
-    (**
-     * A combination of AV_PKT_FLAG values
-     *)
-    flags:        cint;
-    (**
-     * Additional packet data that can be provided by the container.
-     * Packet can contain several types of side information.
-     *)
-    side_data: PAVPacketSideData;
-    side_data_elems: cint;
-
-    (*
-     * Duration of this packet in AVStream->time_base units, 0 if unknown.
-     * Equals next_pts - this_pts in presentation order.
-     *)
-    duration:     cint64;
-
-    pos:          cint64;       // byte position in stream, -1 if unknown
-
-{$IFDEF FF_API_CONVERGENCE_DURATION}
-    (*
-     * @deprecated Same as the duration field, but as int64_t. This was required
-     * for Matroska subtitles, whose duration values could overflow when the
-     * duration field was still an int.
-     *)
-    convergence_duration: cint64; {deprecated}
-{$ENDIF}
-  end; {TAVPacket}
-
-const
-  AV_PKT_FLAG_KEY     = $0001; ///< The packet contains a keyframe
-  AV_PKT_FLAG_CORRUPT = $0002; ///< The packet content is corrupted
-  (**
-   * Flag is used to discard packets which are required to maintain valid
-   * decoder state but are not required for output and should be dropped
-   * after decoding.
-   **)
-  AV_PKT_FLAG_DISCARD = $0004;
-  (**
-   * The packet comes from a trusted source.
-   *
-   * Otherwise-unsafe constructs such as arbitrary pointers to data
-   * outside the packet may be followed.
-   *)
-  AV_PKT_FLAG_TRUSTED = $0008;
-  (**
-   * Flag is used to indicate packets that contain frames that can
-   * be discarded by the decoder.  I.e. Non-reference frames.
-   *)
-  AV_PKT_FLAG_DISPOSABLE = $0010;
-
-  AV_NUM_DATA_POINTERS = 8;
-
-  AV_PKT_DATA_QUALITY_FACTOR = AV_PKT_DATA_QUALITY_STATS; //DEPRECATED
-
-type
-  AVSideDataParamChangeFlags = (
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = $0001,
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = $0002,
-    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = $0004,
-    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = $0008
-  );
-
-{ This is removed in avcodec.h. For the time being (2013) only commented
-const
-  FF_DECODE_ERROR_INVALID_BITSTREAM = 1;
-  FF_DECODE_ERROR_MISSING_REFERENCE = 2;
-}
-
-
-{ This is removed in avcodec.h. For the time being (2013) only commented
-(**
- * This structure describes decoded (raw) audio or video data.
- *
- * AVFrame must be allocated using avcodec_alloc_frame() and freed with
- * avcodec_free_frame(). Note that this allocates only the AVFrame itself. The
- * buffers for the data must be managed through other means.
- *
- * AVFrame is typically allocated once and then reused multiple times to hold
- * different data (e.g. a single AVFrame to hold frames received from a
- * decoder). In such a case, avcodec_get_frame_defaults() should be used to
- * reset the frame to its original clean state before it is reused again.
- *
- * sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
- * to the end with a minor bump.
- * Similarly fields that are marked as to be only accessed by
- * av_opt_ptr() can be reordered. This allows 2 forks to add fields
- * without breaking compatibility with each other.
- *)
-  PAVFrame = ^TAVFrame;
-  TAVFrame = record
-    (**
-     * pointer to the picture/channel planes.
-     * This might be different from the first allocated byte
-     * - encoding: Set by user
-     * - decoding: set by AVCodecContext.get_buffer()
-     *)
-    data: array [0..AV_NUM_DATA_POINTERS - 1] of pbyte;
-
-    (**
-     * Size, in bytes, of the data for each picture/channel plane.
-     *
-     * For audio, only linesize[0] may be set. For planar audio, each channel
-     * plane must be the same size.
-     *
-     * - encoding: Set by user
-     * - decoding: set by AVCodecContext.get_buffer()
-     *)
-    linesize: array [0..AV_NUM_DATA_POINTERS - 1] of cint;
-
-    (**
-     * pointers to the data planes/channels.
-     *
-     * For video, this should simply point to data[].
-     *
-     * For planar audio, each channel has a separate data pointer, and
-     * linesize[0] contains the size of each channel buffer.
-     * For packed audio, there is just one data pointer, and linesize[0]
-     * contains the total size of the buffer for all channels.
-     *
-     * Note: Both data and extended_data will always be set by get_buffer(),
-     * but for planar audio with more channels that can fit in data,
-     * extended_data must be used by the decoder in order to access all
-     * channels.
-     *
-     * encoding: set by user
-     * decoding: set by AVCodecContext.get_buffer()
-     *)
-    extended_data: pointer of pbyte;
-
-    (**
-     * width and height of the video frame
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    width, height: cint;
-
-    (**
-     * number of audio samples (per channel) described by this frame
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    nb_samples: cint;
-
-    (**
-     * format of the frame, -1 if unknown or unset
-     * Values correspond to enum AVPixelFormat for video frames,
-     * enum AVSampleFormat for audio)
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    format: cint;
-
-    (**
-     * 1 -> keyframe, 0-> not
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    key_frame: cint;
-
-    (**
-     * Picture type of the frame, see ?_TYPE below.
-     * - encoding: Set by libavcodec. for coded_picture (and set by user for input).
-     * - decoding: Set by libavcodec.
-     *)
-    pict_type: TAVPictureType;
-
-    (**
-     * pointer to the first allocated byte of the picture. Can be used in get_buffer/release_buffer.
-     * This isn't used by libavcodec unless the default get/release_buffer() is used.
-     * - encoding:
-     * - decoding:
-     *)
-    base: array [0..AV_NUM_DATA_POINTERS - 1] of pbyte;
-
-    (**
-     * sample aspect ratio for the video frame, 0/1 if unknown/unspecified
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    sample_aspect_ratio: TAVRational;
-
-    (**
-     * presentation timestamp in time_base units (time when frame should be shown to user)
-     * If AV_NOPTS_VALUE then frame_rate = 1/time_base will be assumed.
-     * - encoding: MUST be set by user.
-     * - decoding: Set by libavcodec.
-     *)
+    we_do_not_use_buf: pointer;
     pts: cint64;
-
-    (**
-     * pts copied from the AVPacket that was decoded to produce this frame
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    pkt_pts: cint64;
-
-    (**
-     * dts copied from the AVPacket that triggered returning this frame
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    pkt_dts: cint64;
-
-    (**
-     * picture number in bitstream order
-     * - encoding: set by
-     * - decoding: Set by libavcodec.
-     *)
-    coded_picture_number: cint;
-
-    (**
-     * picture number in display order
-     * - encoding: set by
-     * - decoding: Set by libavcodec.
-     *)
-    display_picture_number: cint;
-
-    (**
-     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
-     * - encoding: Set by libavcodec. for coded_picture (and set by user for input).
-     * - decoding: Set by libavcodec.
-     *)
-    quality: cint;
-
-    (**
-     * is this picture used as reference
-     * The values for this are the same as the MpegEncContext.picture_structure
-     * variable, that is 1->top field, 2->bottom field, 3->frame/both fields.
-     * Set to 4 for delayed, non-reference frames.
-     * - encoding: unused
-     * - decoding: Set by libavcodec. (before get_buffer() call)).
-     *)
-    reference: cint;
-
-    (**
-     * QP table
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    qscale_table: PShortint;
-
-    (**
-     * QP store stride
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    qstride: cint;
-
-    (**
-     *
-     *)
-    qscale_type: cint;
-
-    (**
-     * mbskip_table[mb]>=1 if MB didn't change
-     * stride= mb_width = (width+15)>>4
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    mbskip_table: pbyte;
-
-    (**
-     * motion vector table
-     * @code
-     * example:
-     * int mv_sample_log2= 4 - motion_subsample_log2;
-     * int mb_width= (width+15)>>4;
-     * int mv_stride= (mb_width << mv_sample_log2) + 1;
-     * motion_val[direction][x + y*mv_stride][0->mv_x, 1->mv_y];
-     * @endcode
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    //int16_t (*motion_val[2])[2];
-    motion_val: array [0..1] of pointer;
-
-    (**
-     * macroblock type table
-     * mb_type_base + mb_width + 2
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    mb_type: PCuint;
-
-    (**
-     * DCT coefficients
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    dct_coeff: PsmallInt;
-
-    (**
-     * motion reference frame index
-     * the order in which these are stored can depend on the codec.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    ref_index: array [0..1] of PShortint;
-
-    (**
-     * for some private data of the user
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    opaque: pointer;
-
-    (**
-     * error
-     * - encoding: Set by libavcodec. if flags&CODEC_FLAG_PSNR.
-     * - decoding: unused
-     *)
-    error: array [0..AV_NUM_DATA_POINTERS - 1] of cuint64;
-
-    (**
-     * type of the buffer (to keep track of who has to deallocate data[*])
-     * - encoding: Set by the one who allocates it.
-     * - decoding: Set by the one who allocates it.
-     * Note: User allocated (direct rendering) & internal buffers cannot coexist currently.
-     *)
-    type_: cint;
-
-    (**
-     * When decoding, this signals how much the picture must be delayed.
-     * extra_delay = repeat_pict / (2*fps)
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    repeat_pict: cint;
-
-    (**
-     * The content of the picture is interlaced.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec. (default 0)
-     *)
-    interlaced_frame: cint;
-
-    (**
-     * If the content is interlaced, is top field displayed first.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    top_field_first: cint;
-
-    (**
-     * Tell user application that palette has changed from previous frame.
-     * - encoding: ??? (no palette-enabled encoder yet)
-     * - decoding: Set by libavcodec. (default 0).
-     *)
-    palette_has_changed: cint;
-
-    (**
-     * codec suggestion on buffer type if != 0
-     * - encoding: unused
-     * - decoding: Set by libavcodec. (before get_buffer() call)).
-     *)
-    buffer_hints: cint;
-
-    (**
-     * Pan scan.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    pan_scan: PAVPanScan;
-
-    (**
-     * reordered opaque 64bit number (generally a PTS) from AVCodecContext.reordered_opaque
-     * PTS but can be anything).
-     * The user sets AVCodecContext.reordered_opaque to represent the input at
-     * that time,
-     * the decoder reorders values as needed and sets AVFrame.reordered_opaque
-     * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
-     * @deprecated in favor of pkt_pts
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    reordered_opaque: cint64;
-
-    (**
-     * hardware accelerator private data (FFmpeg allocated)
-     * - encoding: unused
-     * - decoding: Set by libavcodec
-     *)
-    hwaccel_picture_private: pointer;
-
-    (**
-     * the AVCodecContext which ff_thread_get_buffer() was last called on
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    owner: PAVCodecContext;
-
-    (**
-     * used by multithreading to store frame-specific info
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    thread_opaque: pointer;
-
-    (**
-     * log2 of the size of the block which a single vector in motion_val represents:
-     * (4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2)
-     * - encoding: unused
-     * - decoding: Set by libavcodec.
-     *)
-    motion_subsample_log2: cuint8;
-
-    (**
-     * Sample rate of the audio data.
-     *
-     * - encoding: unused
-     * - decoding: read by user
-     *)
-    sample_rate: cint;
-
-    (**
-     * Channel layout of the audio data.
-     *
-     * - encoding: unused
-     * - decoding: read by user.
-     *)
-    channel_layout: cuint64;
-
-    (**
-     * frame timestamp estimated using various heuristics, in stream time base
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_best_effort_timestamp(frame)
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-     best_effort_timestamp: cint64;
-
-    (**
-     * reordered pos from the last AVPacket that has been input into the decoder
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_pkt_pos(frame)
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-     pkt_pos: cint64;
-
-    (**
-     * duration of the corresponding packet, expressed in
-     * AVStream->time_base units, 0 if unknown.
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_pkt_duration(frame)
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-     pkt_duration: cint64;
-
-    (**
-     * metadata.
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_metadata(frame)
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-     metadata: PAVDictionary;
-
-    (**
-     * decode error flags of the frame, set to a combination of
-     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
-     * were errors during the decoding.
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_decode_error_flags(frame)
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-     decode_error_flags: cint;
-
-    (**
-     * number of audio channels, only used for audio.
-     * Code outside libavcodec should access this field using:
-     * av_frame_get_channels(frame)
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-     channels: cint;
-
-    (**
-     * size of the corresponding packet containing the compressed
-     * frame. It must be accessed using av_frame_get_pkt_size() and
-     * av_frame_set_pkt_size().
-     * It is set to a negative value if unknown.
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-     pkt_size: cint;
-  end; (** TAVFrame **)
-
-(**
- * Accessors for some AVFrame fields.
- * The position of these field in the structure is not part of the ABI,
- * they should not be accessed directly outside libavcodec.
- *)
-function  av_frame_get_best_effort_timestamp(frame: {const PAVFrame): cint64;
-  cdecl; external av__codec;
-procedure av_frame_set_best_effort_timestamp(frame: PAVFrame; val: cint64);
-  cdecl; external av__codec;
-function  av_frame_get_pkt_duration         (frame: {const PAVFrame): cint64;
-  cdecl; external av__codec;
-procedure av_frame_get_pkt_duration         (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec;
-function  av_frame_get_pkt_pos              (frame: {const PAVFrame): cint64;
-  cdecl; external av__codec;
-procedure av_frame_get_pkt_pos              (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec;
-function  av_frame_get_channel_layout       (frame: {const PAVFrame): cint64;
-  cdecl; external av__codec;
-procedure av_frame_get_channel_layout       (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec;
-function  av_frame_get_channels             (frame: {const PAVFrame): cint;
-  cdecl; external av__codec;
-procedure av_frame_set_channels             (frame: PAVFrame; val: cint);
-  cdecl; external av__codec;
-function  av_frame_get_sample_rate          (frame: {const PAVFrame): cint;
-  cdecl; external av__codec;
-procedure av_frame_set_sample_rate          (frame: PAVFrame; val: cint);
-  cdecl; external av__codec;
-function  av_frame_get_metadata             (frame: {const PAVFrame): PAVDictionary;
-  cdecl; external av__codec;
-procedure av_frame_set_metadata             (frame: PAVFrame; val: PAVDictionary);
-  cdecl; external av__codec;
-function  av_frame_get_decode_error_flags   (frame: {const PAVFrame): cint;
-  cdecl; external av__codec;
-procedure av_frame_set_decode_error_flags   (frame: PAVFrame; val: cint);
-  cdecl; external av__codec;
-function  av_frame_get_pkt_size(frame: {const PAVFrame): cint;
-  cdecl; external av__codec;
-procedure av_frame_set_pkt_size(frame: PAVFrame; val: cint);
-  cdecl; external av__codec;
-}
-
-type
-  TAVCodecInternal = record
+    we_do_not_use_dts: cint64;
+    data: PByteArray;
+    size: cint;
+    stream_index: cint;
+    flags: cint;
+    we_do_not_use_side_data: pointer;
+    we_do_not_use_side_data_elems: cint;
+    we_do_not_use_duration: cint64;
+    we_do_not_use_pos: cint64;
+    we_do_not_use_convergence_duration: cint64;
+  end;
+  PAVCodecDescriptor = ^TAVCodecDescriptor;
+  TAVCodecDescriptor = record
+    we_do_not_use_id: TAVCodecID;
+    we_do_not_use_type: TAVMediaType;
+    name: ^AnsiChar;
+    long_name: ^AnsiChar;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  PAVCodecParameters = ^TAVCodecParameters;
+  TAVCodecParameters = record
+    codec_type: TAVMediaType;
+    codec_id: TAVCodecID;
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-  PAVCodecInternal = ^TAVCodecInternal;
   PAVCodecContext = ^TAVCodecContext;
-
-  PAVClass = ^TAVClass;
-
-  PPAVCodec = ^PAVCodec;
+  PPAVCodecContext = ^PAVCodecContext;
   PAVCodec = ^TAVCodec;
-
-  // int[4]
-  PAVNDPArray = ^TAVNDPArray;
-  TAVNDPArray = array [0..AV_NUM_DATA_POINTERS - 1] of cint;
-  // int (*func)(struct AVCodecContext *c2, void *arg)
-  TExecuteFunc = function(c2: PAVCodecContext; arg: Pointer): cint; cdecl;
-  // int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr)
-  TExecute2Func = function(c2: PAVCodecContext; arg: Pointer; jobnr: cint; threadnr: cint): cint; cdecl;
-
-  TAVFieldOrder = (
-    AV_FIELD_UNKNOWN,
-    AV_FIELD_PROGRESSIVE,
-    AV_FIELD_TT,          //< Top coded_first, top displayed first
-    AV_FIELD_BB,          //< Bottom coded first, bottom displayed first
-    AV_FIELD_TB,          //< Top coded first, bottom displayed first
-    AV_FIELD_BT          //< Bottom coded first, top displayed first
-    );
-
-  PMpegEncContext = ^TMpegEncContext;
-  // To be expanded if needed.
-  TMpegEncContext = record
-  end;
-
-(**
- * @defgroup lavc_hwaccel AVHWAccel
- *
- * @note  Nothing in this structure should be accessed by the user.  At some
- *        point in future it will not be externally visible at all.
- *
- * @{
- *)
-  PAVHWAccel = ^TAVHWAccel;
-  TAVHWAccel = record
-    (**
-     * Name of the hardware accelerated codec.
-     * The name is globally unique among encoders and among decoders (but an
-     * encoder and a decoder can share the same name).
-     *)
-    name: PAnsiChar;
-
-    (**
-     * Type of codec implemented by the hardware accelerator.
-     *
-     * See AVMediaType_xxx
-     *)
+  TAVCodec = record
+    name: ^AnsiChar;
+    we_do_not_use_long_name: ^AnsiChar;
     type_: TAVMediaType;
-
-    (**
-     * Codec implemented by the hardware accelerator.
-     *
-     * See AV_CODEC_ID_xxx
-     *)
     id: TAVCodecID;
-
-    (**
-     * Supported pixel format.
-     *
-     * Only hardware accelerated formats are supported here.
-     *)
-    pix_fmt: PAVPixelFormat;
-
-    (**
-     * Hardware accelerated codec capabilities.
-     * see AV_HWACCEL_CODEC_CAP_*
-     *)
-    capabilities: cint;
-
-    (*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-
-    (**
-     * Allocate a custom buffer
-     *)
-    alloc_frame: function (avctx: PAVCodecContext; frame: PAVFrame): cint; cdecl;
-
-    (**
-     * Called at the beginning of each frame or field picture.
-     *
-     * Meaningful frame information (codec specific) is guaranteed to
-     * be parsed at this point. This function is mandatory.
-     * The only exception is XvMC, that works on MB level.
-     *
-     * Note that buf can be NULL along with buf_size set to 0.
-     * Otherwise, this means the whole frame is available at this point.
-     *
-     * @param avctx the codec context
-     * @param buf the frame data buffer base
-     * @param buf_size the size of the frame in bytes
-     * @return zero if successful, a negative value otherwise
-     *)
-    start_frame: function (avctx:       PAVCodecContext;
-                           buf: {const} PByteArray;
-                           buf_size:    cuint): cint; cdecl;
-
-    (**
-     * Callback for parameter data (SPS/PPS/VPS etc).
-     *
-     * Useful for hardware decoders which keep persistent state about the
-     * video parameters, and need to receive any changes to update that state.
-     *
-     * @param avctx the codec context
-     * @param type the nal unit type
-     * @param buf the nal unit data buffer
-     * @param buf_size the size of the nal unit in bytes
-     * @return zero if successful, a negative value otherwise
-     *)
-    decode_params: function(avctx: PAVCodecContext; type_: cint; buf: Pcuint8 {const}; buf_size: cuint32): PCint;
-
-    (**
-     * Callback for each slice.
-     *
-     * Meaningful slice information (codec specific) is guaranteed to
-     * be parsed at this point. This function is mandatory.
-     *
-     * @param avctx the codec context
-     * @param buf the slice data buffer base
-     * @param buf_size the size of the slice in bytes
-     * @return zero if successful, a negative value otherwise
-     *)
-    decode_slice: function (avctx:       PAVCodecContext;
-                            buf: {const} PByteArray;
-                            buf_size:    cuint): cint; cdecl;
-
-    (**
-     * Called at the end of each frame or field picture.
-     *
-     * The whole picture is parsed at this point and can now be sent
-     * to the hardware accelerator. This function is mandatory.
-     *
-     * @param avctx the codec context
-     * @return zero if successful, a negative value otherwise
-     *)
-    end_frame: function (avctx: PAVCodecContext): cint; cdecl;
-
-    (**
-     * Size of per-frame hardware accelerator private data.
-     *
-     * Private data is allocated with av_mallocz() before
-     * AVCodecContext.get_buffer() and deallocated after
-     * AVCodecContext.release_buffer().
-     *)
-    frame_priv_data_size: cint;
-
-    (**
-     * Called for every Macroblock in a slice.
-     *
-     * XvMC uses it to replace the mpv_reconstruct_mb().
-     * Instead of decoding to raw picture, MB parameters are
-     * stored in an array provided by the video driver.
-     *
-     * @param s the mpeg context
-     *)
-    decode_mb: procedure(s: PMpegEncContext); cdecl;
-
-    (**
-     * Initialize the hwaccel private data.
-     *
-     * This will be called from ff_get_format(), after hwaccel and
-     * hwaccel_context are set and the hwaccel private data in AVCodecInternal
-     * is allocated.
-     *)
-    init: function (avctx: PAVCodecContext): cint; cdecl;
-
-    (**
-     * Uninitialize the hwaccel private data.
-     *
-     * This will be called from get_format() or avcodec_close(), after hwaccel
-     * and hwaccel_context are already uninitialized.
-     *)
-    uninit: function (avctx: PAVCodecContext): cint; cdecl;
-
-    (**
-     * Size of the private data to allocate in
-     * AVCodecInternal.hwaccel_priv_data.
-     *)
-    priv_data_size: cint;
-
-    (**
-     * Internal hwaccel capabilities.
-     *)
-    caps_internal: cint;
-
-    (**
-     * Fill the given hw_frames context with current codec parameters. Called
-     * from get_format. Refer to avcodec_get_hw_frames_parameters() for
-     * details.
-     *
-     * This CAN be called before AVHWAccel.init is called, and you must assume
-     * that avctx->hwaccel_priv_data is invalid.
-     *)
-    frame_params: function(avctx: PAVCodecContext; hw_frames_ctx: PAVBufferRef): Pcint;
-  end; {TAVHWAccel}
-
-(**
- * main external API structure.
- * New fields can be added to the end with minor version bumps.
- * Removal, reordering and changes to existing fields require a major
- * version bump.
- * You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
- * applications.
- * The name string for AVOptions options matches the associated command line
- * parameter name and can be found in libavcodec/options_table.h
- * The AVOption/command line parameter names differ in some cases from the C
- * structure field names for historic reasons or brevity.
- * sizeof(AVCodecContext) must not be used outside libav*.
- *)
-  TAVCodecContext = record {720}
-    (**
-     * information on struct for av_log
-     * - set by avcodec_alloc_context3
-     *)
-    av_class: PAVClass;
-    log_level_offset: cint;
-
-    codec_type: TAVMediaType; (* see AVMEDIA_TYPE_xxx *)
-    codec:      PAVCodec;
-    codec_id:   TAVCodecID; (* see AV_CODEC_ID_xxx *)
-
-    (**
-     * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
-     * This is used to work around some encoder bugs.
-     * A demuxer should set this to what is stored in the field used to identify the codec.
-     * If there are multiple such fields in a container then the demuxer should choose the one
-     * which maximizes the information about the used codec.
-     * If the codec tag field in a container is larger than 32 bits then the demuxer should
-     * remap the longer ID to 32 bits with a table or other structure. Alternatively a new
-     * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
-     * first.
-     * - encoding: Set by user, if not then the default based on codec_id will be used.
-     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
-     *)
-    codec_tag: cuint;
-
-    priv_data: pointer;
-
-    (**
-     * Private context used for internal data.
-     *
-     * Unlike priv_data, this is not codec-specific. It is used in general
-     * libavcodec functions.
-     *)
-    internal: PAVCodecInternal;
-
-    (**
-     * Private data of the user, can be used to carry app specific stuff.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    opaque: pointer;
-
-    (**
-     * the average bitrate
-     * - encoding: Set by user; unused for constant quantizer encoding.
-     * - decoding: Set by user, may be overwritten by libavcodec
-     *             if this info is available in the stream
-     *)
-    bit_rate: cint64;
-
-    (**
-     * number of bits the bitstream is allowed to diverge from the reference.
-     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
-     * - encoding: Set by user; unused for constant quantizer encoding.
-     * - decoding: unused
-     *)
-    bit_rate_tolerance: cint;
-
-    (**
-     * Global quality for codecs which cannot change it per frame.
-     * This should be proportional to MPEG-1/2/4 qscale.
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    global_quality: cint;
-
-    (**
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    compression_level: cint;
-
-    (**
-     * AV_CODEC_FLAG_*.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    flags: cint;
-
-    (**
-     * AV_CODEC_FLAG2_*
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    flags2: cint;
-
-    (**
-     * some codecs need / can use extradata like Huffman tables.
-     * MJPEG: Huffman tables
-     * rv10: additional flags
-     * MPEG-4: global headers (they can be in the bitstream or here)
-     * The allocated memory should be AV_FF_INPUT_BUFFER_PADDING_SIZE bytes larger
-     * than extradata_size to avoid problems if it is read with the bitstream reader.
-     * The bytewise contents of extradata must not depend on the architecture or CPU endianness.
-     * - encoding: Set/allocated/freed by libavcodec.
-     * - decoding: Set/allocated/freed by user.
-     *)
-    extradata: pbyte;
-    extradata_size: cint;
-
-    (**
-     * This is the fundamental unit of time (in seconds) in terms
-     * of which frame timestamps are represented. For fixed-fps content,
-     * timebase should be 1/framerate and timestamp increments should be
-     * identically 1.
-     * This often, but not always is the inverse of the frame rate or field rate
-     * for video. 1/time_base is not the average frame rate if the frame rate is not
-     * constant.
-     *
-     * Like containers, elementary streams also can store timestamps, 1/time_base
-     * is the unit in which these timestamps are specified.
-     * As example of such codec time base see ISO/IEC 14496-2:2001(E)
-     * vop_time_increment_resolution and fixed_vop_rate
-     * (fixed_vop_rate == 0 implies that it is different from the framerate)
-     *
-     * - encoding: MUST be set by user.
-     * - decoding: the use of this field for decoding is deprecated.
-     *             Use framerate instead.
-     *)
+    we_do_not_use_capabilities: cint;
+    we_do_not_use_supported_framerates: ^TAVRational;
+    pix_fmts: ^TAVPixelFormat;
+    we_do_not_use_supported_samplerates: pcint;
+    we_do_not_use_sample_fmts: ^TAVSampleFormat;
+    we_do_not_use_channel_layouts: pcuint64;
+    we_do_not_use_max_lowres: cuint8;
+    we_do_not_use_priv_class: pointer;
+    we_do_not_use_profiles: pointer;
+    we_do_not_use_wrapper_name: ^AnsiChar;
+    we_do_not_use_priv_data_size: cint;
+    we_do_not_use_next: PAVCodec;
+{$IF LIBAVCODEC_VERSION < 58079100}
+    we_do_not_use_init_thread_copy: cfunctionpointer;
+{$ENDIF}
+    we_do_not_use_update_thread_context: cfunctionpointer;
+    we_do_not_use_defaults: pointer;
+    we_do_not_use_init_static_data: cfunctionpointer;
+    we_do_not_use_init: cfunctionpointer;
+    we_do_not_use_encode_sub: cfunctionpointer;
+    we_do_not_use_encode2: cfunctionpointer;
+    we_do_not_use_decode: cfunctionpointer;
+    we_do_not_use_close: cfunctionpointer;
+{$IF LIBAVCODEC_VERSION < 58093100}
+    we_do_not_use_send_frame: cfunctionpointer;
+{$ENDIF}
+    we_do_not_use_receive_packet: cfunctionpointer;
+    we_do_not_use_receive_frame: cfunctionpointer;
+    flush: procedure(avctx: PAVCodecContext); cdecl;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  TAVCodecContext = record
+    we_do_not_use_av_class: pointer;
+    we_do_not_use_log_level_offset: cint;
+    codec_type: TAVMediaType;
+    codec: ^TAVCodec;
+    codec_id: TAVCodecID;
+    we_do_not_use_codec_tag: cuint;
+    we_do_not_use_priv_data: pointer;
+    we_do_not_use_internal: pointer;
+    we_do_not_use_opaque: pointer;
+    we_do_not_use_bit_rate: cint64;
+    we_do_not_use_bit_rate_tolerance: cint;
+    we_do_not_use_global_quality: cint;
+    we_do_not_use_compression_level: cint;
+    we_do_not_use_flags: cint;
+    we_do_not_use_flags2: cint;
+    we_do_not_use_extradata: pcuint8;
+    we_do_not_use_extradata_size: cint;
     time_base: TAVRational;
-
-    (**
-     * For some codecs, the time base is closer to the field rate than the frame rate.
-     * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
-     * if no telecine is used ...
-     *
-     * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
-     *)
-    ticks_per_frame: cint;
-
-    (**
-     * Codec delay.
-     *
-     * Encoding: Number of frames delay there will be from the encoder input to
-     *           the decoder output. (we assume the decoder matches the spec)
-     * Decoding: Number of frames delay in addition to what a standard decoder
-     *           as specified in the spec would produce.
-     *
-     * Video:
-     *   Number of frames the decoded output will be delayed relative to the
-     *   encoded input.
-     *
-     * Audio:
-     *   For encoding, this field is unused (see initial_padding).
-     *
-     *   For decoding, this is the number of samples the decoder needs to
-     *   output before the decoder's output is valid. When seeking, you should
-     *   start decoding this many samples prior to your desired seek point.
-     *
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    delay: cint;
-
-    (* video only *)
-    (**
-     * picture width / height.
-     *
-     * @note Those fields may not match the values of the last
-     * AVFrame output by avcodec_decode_video2 due frame
-     * reordering.
-     *
-     * - encoding: MUST be set by user.
-     * - decoding: May be set by the user before opening the decoder if known e.g.
-     *             from the container. Some decoders will require the dimensions
-     *             to be set by the caller. During decoding, the decoder may
-     *             overwrite those values as required while parsing the data.
-     *)
-    width, height: cint;
-
-    (**
-     * Bitstream width / height, may be different from width/height e.g. when
-     * the decoded frame is cropped before being output or lowres is enabled.
-     *
-     * @note Those field may not match the value of the last
-     * AVFrame output by avcodec_receive_frame() due frame
-     * reordering.
-     *
-     * - encoding: unused
-     * - decoding: May be set by the user before opening the decoder if known
-     *             e.g. from the container. During decoding, the decoder may
-     *             overwrite those values as required while parsing the data.
-     *)
-    coded_width, coded_height: cint;
-
-    (**
-     * the number of pictures in a group of pictures, or 0 for intra_only
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    gop_size: cint;
-
-    (**
-     * Pixel format, see AV_PIX_FMT_xxx.
-     * May be set by the demuxer if known from headers.
-     * May be overridden by the decoder if it knows better.
-     *
-     * @note This field may not match the value of the last
-     * AVFrame output by avcodec_receive_frame() due frame
-     * reordering.
-     *
-     * - encoding: Set by user.
-     * - decoding: Set by user if known, overridden by libavcodec while
-     *             parsing the data.
-     *)
+    we_do_not_use_ticks_per_frame: cint;
+    we_do_not_use_delay: cint;
+    width: cint;
+    height: cint;
+    we_do_not_use_coded_width: cint;
+    we_do_not_use_coded_height: cint;
+    we_do_not_use_gop_size: cint;
     pix_fmt: TAVPixelFormat;
-
-    (**
-     * If non NULL, 'draw_horiz_band' is called by the libavcodec
-     * decoder to draw a horizontal band. It improves cache usage. Not
-     * all codecs can do that. You must check the codec capabilities
-     * beforehand.
-     * The function is also used by hardware acceleration APIs.
-     * It is called at least once during frame decoding to pass
-     * the data needed for hardware render.
-     * In that mode instead of pixel data, AVFrame points to
-     * a structure specific to the acceleration API. The application
-     * reads the structure and can change some fields to indicate progress
-     * or mark state.
-     * - encoding: unused
-     * - decoding: Set by user.
-     * @param height the height of the slice
-     * @param y the y position of the slice
-     * @param type 1->top field, 2->bottom field, 3->frame
-     * @param offset offset into the AVFrame.data from which the slice should be read
-     *)
-    draw_horiz_band: procedure (s: PAVCodecContext;
-                                src: {const} PAVFrame; offset: PAVNDPArray;
-                                y: cint; type_: cint; height: cint); cdecl;
-
-    (**
-     * callback to negotiate the pixelFormat
-     * @param fmt is the list of formats which are supported by the codec,
-     * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
-     * The first is always the native one.
-     * @note The callback may be called again immediately if initialization for
-     * the selected (hardware-accelerated) pixel format failed.
-     * @warning Behavior is undefined if the callback returns a value not
-     * in the fmt list of formats.
-     * @return the chosen format
-     * - encoding: unused
-     * - decoding: Set by user, if not set the native format will be chosen.
-     *)
-    get_format: function (s: PAVCodecContext; fmt: {const} PAVPixelFormat): TAVPixelFormat; cdecl;
-
-    (**
-     * maximum number of B-frames between non-B-frames
-     * Note: The output will be delayed by max_b_frames+1 relative to the input.
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    max_b_frames: cint;
-
-    (**
-     * qscale factor between IP and B-frames
-     * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
-     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    b_quant_factor: cfloat;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    b_frame_strategy: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * qscale offset between IP and B-frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    b_quant_offset: cfloat;
-
-    (**
-     * Size of the frame reordering buffer in the decoder.
-     * For MPEG-2 it is 1 IPB or 0 low delay IP.
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    has_b_frames: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    mpeg_quant: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * qscale factor between P- and I-frames
-     * If > 0 then the last P- frame quantizer will be used (q = lastp_q * factor + offset).
-     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    i_quant_factor: cfloat;
-
-    (**
-     * qscale offset between P and I-frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    i_quant_offset: cfloat;
-
-    (**
-     * luminance masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    lumi_masking: cfloat;
-
-    (**
-     * temporary complexity masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    temporal_cplx_masking: cfloat;
-
-    (**
-     * spatial complexity masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    spatial_cplx_masking: cfloat;
-
-    (**
-     * p block masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    p_masking: cfloat;
-
-    (**
-     * darkness masking (0-> disabled)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    dark_masking: cfloat;
-
-    (**
-     * slice count
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by user (or 0).
-     *)
-    slice_count: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    prediction_method: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * slice offsets in the frame in bytes
-     * - encoding: Set/allocated by libavcodec.
-     * - decoding: Set/allocated by user (or NULL).
-     *)
-    slice_offset: PCint;
-
-    (**
-     * sample aspect ratio (0 if unknown)
-     * That is the width of a pixel divided by the height of the pixel.
-     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
+    we_do_not_use_draw_horiz_band: cfunctionpointer;
+    get_format: function(s: PAVCodecContext; fmt: PAVPixelFormat): TAVPixelFormat; cdecl;
+    we_do_not_use_max_b_frames: cint;
+    we_do_not_use_b_quant_factor: cfloat;
+    we_do_not_use_b_frame_strategy: cint;
+    we_do_not_use_b_quant_offset: cfloat;
+    we_do_not_use_has_b_frames: cint;
+    we_do_not_use_mpeg_quant: cint;
+    we_do_not_use_i_quant_factor: cfloat;
+    we_do_not_use_i_quant_offset: cfloat;
+    we_do_not_use_lumi_masking: cfloat;
+    we_do_not_use_temporal_cplx_masking: cfloat;
+    we_do_not_use_spatial_cplx_masking: cfloat;
+    we_do_not_use_p_masking: cfloat;
+    we_do_not_use_dark_masking: cfloat;
+    we_do_not_use_slice_count: cint;
+    we_do_not_use_prediction_method: cint;
+    we_do_not_use_slice_offset: pcint;
     sample_aspect_ratio: TAVRational;
-
-    (**
-     * motion estimation comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    me_cmp: cint;
-
-    (**
-     * subpixel motion estimation comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    me_sub_cmp: cint;
-    (**
-     * macroblock comparison function (not supported yet)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    mb_cmp: cint;
-    (**
-     * interlaced DCT comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    ildct_cmp: cint;
-
-    (**
-     * ME diamond size & shape
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    dia_size: cint;
-
-    (**
-     * amount of previous MV predictors (2a+1 x 2a+1 square)
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    last_predictor_count: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    pre_me: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * motion estimation prepass comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    me_pre_cmp: cint;
-
-    (**
-     * ME prepass diamond size & shape
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    pre_dia_size: cint;
-
-    (**
-     * subpel ME quality
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    me_subpel_quality: cint;
-
-{$IFDEF FF_API_AFD}
-    (**
-     * DTG active format information (additional aspect ratio
-     * information only used in DVB MPEG-2 transport streams)
-     * 0 if not set.
-     *
-     * - encoding: unused
-     * - decoding: Set by decoder.
-     * @deprecated Deprecated in favor of AVSideData
-     *)
-    {attribute_deprecated}
-    dtg_active_format: cint;
-{$IFEND}
-
-    (**
-     * maximum motion estimation search range in subpel units
-     * If 0 then no limit.
-     *
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    me_range: cint;
-
-    (**
-     * slice flags
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    slice_flags: cint;
-
-    (**
-     * macroblock decision mode
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    mb_decision: cint;
-
-    (**
-     * custom intra quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: Set by libavcodec.
-     *)
-    intra_matrix: PWord;
-
-    (**
-     * custom inter quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: Set by libavcodec.
-     *)
-    inter_matrix: PWord;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    scenechange_threshold: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    noise_reduction: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * precision of the intra DC coefficient - 8
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec
-     *)
-    intra_dc_precision: cint;
-
-    (**
-     * Number of macroblock rows at the top which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    skip_top: cint;
-
-    (**
-     * Number of macroblock rows at the bottom which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    skip_bottom: cint;
-
-    (**
-     * minimum MB Lagrange multiplier
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    mb_lmin: cint;
-
-    (**
-     * maximum MB Lagrange multiplier
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    mb_lmax: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (**
-     * @deprecated use encoder private options instead
-     *)
-    me_penalty_compensation: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    bidir_refine: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    brd_scale: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * minimum GOP size
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    keyint_min: cint;
-
-    (**
-     * number of reference frames
-     * - encoding: Set by user.
-     * - decoding: Set by lavc.
-     *)
-    refs: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    chromaoffset: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * Note: Value depends upon the compare function used for fullpel ME.
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    mv0_threshold: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    b_sensitivity: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * Chromaticity coordinates of the source primaries.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    color_primaries: TAVColorPrimaries;
-
-    (**
-     * Color Transfer Characteristic.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    color_trc: TAVColorTransferCharacteristic;
-
-    (**
-     * YUV colorspace type.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    colorspace: TAVColorSpace;
-
-    (**
-     * MPEG vs JPEG YUV range.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    color_range: TAVColorRange;
-
-    (**
-     * This defines the location of chroma samples.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-     chroma_sample_location: TAVChromaLocation;
-
-    (**
-     * Number of slices.
-     * Indicates number of picture subdivisions. Used for parallelized
-     * decoding.
-     * - encoding: Set by user
-     * - decoding: unused
-     *)
-    slices: cint;
-
-    (** Field order
-     * - encoding: set by libavcodec
-     * - decoding: Set by user.
-     *)
-    field_order: TAVFieldOrder;
-
-    (* audio only *)
-    sample_rate: cint; ///< samples per second
-    channels: cint;    ///< number of audio channels
-
-    (**
-     * audio sample format
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    sample_fmt: TAVSampleFormat;  ///< sample format
-
-    (* The following data should not be initialized. *)
-    (**
-     * Number of samples per channel in an audio frame.
-     *
-     * - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
-     *   except the last must contain exactly frame_size samples per channel.
-     *   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
-     *   frame size is not restricted.
-     * - decoding: may be set by some decoders to indicate constant frame size
-     *)
-    frame_size: cint;
-
-    (**
-     * Frame counter, set by libavcodec.
-     *
-     * - decoding: total number of frames returned from the decoder so far.
-     * - encoding: total number of frames passed to the encoder so far.
-     *
-     *   @note the counter is not incremented if encoding/decoding resulted in
-     *   an error.
-     *)
-    frame_number: cint;   ///< audio or video frame number
-
-    (**
-     * number of bytes per packet if constant and known or 0
-     * Used by some WAV based audio codecs.
-     *)
-    block_align: cint;
-
-    (**
-     * Audio cutoff bandwidth (0 means "automatic")
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    cutoff: cint;
-
-    (**
-     * Audio channel layout.
-     * - encoding: set by user.
-     * - decoding: set by user, may be overwritten by libavcodec.
-     *)
+    we_do_not_use_me_cmp: cint;
+    we_do_not_use_me_sub_cmp: cint;
+    we_do_not_use_mb_cmp: cint;
+    we_do_not_use_ildct_cmp: cint;
+    we_do_not_use_dia_size: cint;
+    we_do_not_use_last_predictor_count: cint;
+    we_do_not_use_pre_me: cint;
+    we_do_not_use_me_pre_cmp: cint;
+    we_do_not_use_pre_dia_size: cint;
+    we_do_not_use_me_subpel_quality: cint;
+    we_do_not_use_me_range: cint;
+    we_do_not_use_slice_flags: cint;
+    we_do_not_use_mb_decision: cint;
+    we_do_not_use_intra_matrix: pcuint16;
+    we_do_not_use_inter_matrix: pcuint16;
+    we_do_not_use_scenechange_threshold: cint;
+    we_do_not_use_noise_reduction: cint;
+    we_do_not_use_intra_dc_precision: cint;
+    we_do_not_use_skip_top: cint;
+    we_do_not_use_skip_bottom: cint;
+    we_do_not_use_mb_lmin: cint;
+    we_do_not_use_mb_lmax: cint;
+    we_do_not_use_me_penalty_compensation: cint;
+    we_do_not_use_bidir_refine: cint;
+    we_do_not_use_brd_scale: cint;
+    we_do_not_use_keyint_min: cint;
+    we_do_not_use_refs: cint;
+    we_do_not_use_chromaoffset: cint;
+    we_do_not_use_mv0_threshold: cint;
+    we_do_not_use_b_sensitivity: cint;
+    we_do_not_use_color_primaries: cenum;
+    we_do_not_use_color_trc: cenum;
+    we_do_not_use_colorspace: cenum;
+    we_do_not_use_color_range: cenum;
+    we_do_not_use_chroma_sample_location: cenum;
+    we_do_not_use_slices: cint;
+    we_do_not_use_field_order: cenum;
+    sample_rate: cint;
+    channels: cint;
+    sample_fmt: TAVSampleFormat;
+    we_do_not_use_frame_size: cint;
+    we_do_not_use_frame_number: cint;
+    we_do_not_use_block_align: cint;
+    we_do_not_use_cutoff: cint;
     channel_layout: cuint64;
-
-    (**
-     * Request decoder to use this channel layout if it can (0 for default)
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
     request_channel_layout: cuint64;
-
-    (**
-     * Type of service that the audio stream conveys.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    audio_service_type: TAVAudioServiceType;
-
-    (**
-     * desired sample format
-     * - encoding: Not used.
-     * - decoding: Set by user.
-     * Decoder will decode to this format if it can.
-     *)
+    we_do_not_use_audio_service_type: cenum;
     request_sample_fmt: TAVSampleFormat;
-
-    (**
-     * This callback is called at the beginning of each frame to get data
-     * buffer(s) for it. There may be one contiguous buffer for all the data or
-     * there may be a buffer per each data plane or anything in between. What
-     * this means is, you may set however many entries in buf[] you feel necessary.
-     * Each buffer must be reference-counted using the AVBuffer API (see description
-     * of buf[] below).
-     *
-     * The following fields will be set in the frame before this callback is
-     * called:
-     * - format
-     * - width, height (video only)
-     * - sample_rate, channel_layout, nb_samples (audio only)
-     * Their values may differ from the corresponding values in
-     * AVCodecContext. This callback must use the frame values, not the codec
-     * context values, to calculate the required buffer size.
-     *
-     * This callback must fill the following fields in the frame:
-     * - data[]
-     * - linesize[]
-     * - extended_data:
-     *   * if the data is planar audio with more than 8 channels, then this
-     *     callback must allocate and fill extended_data to contain all pointers
-     *     to all data planes. data[] must hold as many pointers as it can.
-     *     extended_data must be allocated with av_malloc() and will be freed in
-     *     av_frame_unref().
-     *   * otherwise extended_data must point to data
-     * - buf[] must contain one or more pointers to AVBufferRef structures. Each of
-     *   the frame's data and extended_data pointers must be contained in these. That
-     *   is, one AVBufferRef for each allocated chunk of memory, not necessarily one
-     *   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
-     *   and av_buffer_ref().
-     * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
-     *   this callback and filled with the extra buffers if there are more
-     *   buffers than buf[] can hold. extended_buf will be freed in
-     *   av_frame_unref().
-     *
-     * If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
-     * avcodec_default_get_buffer2() instead of providing buffers allocated by
-     * some other means.
-     *
-     * Each data plane must be aligned to the maximum required by the target
-     * CPU.
-     *
-     * @see avcodec_default_get_buffer2()
-     *
-     * Video:
-     *
-     * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
-     * (read and/or written to if it is writable) later by libavcodec.
-     *
-     * avcodec_align_dimensions2() should be used to find the required width and
-     * height, as they normally need to be rounded up to the next multiple of 16.
-     *
-     * Some decoders do not support linesizes changing between frames.
-     *
-     * If frame multithreading is used and thread_safe_callbacks is set,
-     * this callback may be called from a different thread, but not from more
-     * than one at once. Does not need to be reentrant.
-     *
-     * @see avcodec_align_dimensions2()
-     *
-     * Audio:
-     *
-     * Decoders request a buffer of a particular size by setting
-     * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
-     * however, utilize only part of the buffer by setting AVFrame.nb_samples
-     * to a smaller value in the output frame.
-     *
-     * As a convenience, av_samples_get_buffer_size() and
-     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
-     * functions to find the required data size and to fill data pointers and
-     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
-     * since all planes must be the same size.
-     *
-     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
-     *
-     * - encoding: unused
-     * - decoding: Set by libavcodec, user can override.
-     *)
-    get_buffer2: function (s: PAVCodecContext; frame: PAVFrame; flags: cint): cint; cdecl;
-
-    (**
-     * If non-zero, the decoded audio and video frames returned from
-     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
-     * and are valid indefinitely. The caller must free them with
-     * av_frame_unref() when they are not needed anymore.
-     * Otherwise, the decoded frames must not be freed by the caller and are
-     * only valid until the next decode call.
-     *
-     * This is always automatically enabled if avcodec_receive_frame() is used.
-     *
-     * - encoding: unused
-     * - decoding: set by the caller before avcodec_open2().
-     *)
-    {attribute_deprecated}
-    refcounted_frames: cint;
-
-    (* - encoding parameters *)
-    qcompress: cfloat;  ///< amount of qscale change between easy & hard scenes (0.0-1.0)
-    qblur: cfloat;      ///< amount of qscale smoothing over time (0.0-1.0)
-
-    (**
-     * minimum quantizer
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    qmin: cint;
-
-   (**
-     * maximum quantizer
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-   qmax: cint;
-
-    (**
-     * maximum quantizer difference between frames
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    max_qdiff: cint;
-
-    (**
-     * decoder bitstream buffer size
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    rc_buffer_size: cint;
-    (**
-     * ratecontrol override, see RcOverride
-     * - encoding: Allocated/set/freed by user.
-     * - decoding: unused
-     *)
-    rc_override_count: cint;
-    rc_override: PRcOverride;
-
-    (**
-     * maximum bitrate
-     * - encoding: Set by user.
-     * - decoding: Set by user, may be overwritten by libavcodec.
-     *)
-    rc_max_rate: cint64;
-
-    (**
-     * minimum bitrate
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    rc_min_rate: cint64;
-
-    (**
-     * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
-     * - encoding: Set by user.
-     * - decoding: unused.
-     *)
-    rc_max_available_vbv_use: cfloat;
-
-    (**
-     * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
-     * - encoding: Set by user.
-     * - decoding: unused.
-     *)
-    rc_min_vbv_overflow_use: cfloat;
-
-    (**
-     * Number of bits which should be loaded into the rc buffer before decoding starts.
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    rc_initial_buffer_occupancy: cint;
-
-{$IFDEF FF_API_CODER_TYPE}
-    (**
-     * @deprecated use encoder private options instead
-     *)
-    coder_type: cint; {deprecated}
-{$ENDIF}
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    context_model: cint; {deprecated}
-{$ENDIF}
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    frame_skip_threshold: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    frame_skip_factor: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    frame_skip_exp: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    frame_skip_cmp: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * trellis RD quantization
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    trellis: cint;
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    (** @deprecated use encoder private options instead *)
-    min_prediction_order: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    max_prediction_order: cint; {deprecated}
-
-    (** @deprecated use encoder private options instead *)
-    timecode_frame_start: cint64; {deprecated}
-{$ENDIF}
-
-{$IFDEF FF_API_RTP_CALLBACK}
-    (**
-     * @deprecated unused
-     *)
-    (* The RTP callback: This function is called   *)
-    (* every time the encoder has a packet to send *)
-    (* Depends on the encoder if the data starts   *)
-    (* with a Start Code (it should) H.263 does.   *)
-    (* mb_nb contains the number of macroblocks    *)
-    (* encoded in the RTP payload                  *)
-    rtp_callback: procedure (avctx: PAVCodecContext; data: pointer;
-                             size: cint; mb_nb: cint); cdecl; {deprecated}
-{$ENDIF}
-
-{$IFDEF FF_API_PRIVATE_OPT}
-    rtp_payload_size: cint; {deprecated} (* The size of the RTP payload: the coder will  *)
-                                         (* do it's best to deliver a chunk with size    *)
-                                         (* below rtp_payload_size, the chunk will start *)
-                                         (* with a start code on some codecs like H.263  *)
-                                         (* This doesn't take account of any particular  *)
-                                         (* headers inside the transmited RTP payload    *)
-{$ENDIF}
-
-{$IFDEF FF_API_STAT_BITS}
-    (* statistics, used for 2-pass encoding *)
-    mv_bits: cint;  {deprecated}
-    header_bits: cint; {deprecated}
-    i_tex_bits: cint; {deprecated}
-    p_tex_bits: cint; {deprecated}
-    i_count: cint; {deprecated}
-    p_count: cint; {deprecated}
-    skip_count: cint; {deprecated}
-    misc_bits: cint; {deprecated}
-
-    (** @deprecated this field is unused *)
-    frame_bits: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * pass1 encoding statistics output buffer
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     *)
-    stats_out: PAnsiChar;
-
-    (**
-     * pass2 encoding statistics input buffer
-     * Concatenated stuff from stats_out of pass1 should be placed here.
-     * - encoding: Allocated/set/freed by user.
-     * - decoding: unused
-     *)
-    stats_in: PAnsiChar;
-
-    (**
-     * Work around bugs in encoders which sometimes cannot be detected automatically.
-     * - encoding: Set by user
-     * - decoding: Set by user
-     *)
+    we_do_not_use_get_buffer2: cfunctionpointer;
+    we_do_not_use_refcounted_frames: cint;
+    we_do_not_use_qcompress: cfloat;
+    we_do_not_use_qblur: cfloat;
+    we_do_not_use_qmin: cint;
+    we_do_not_use_qmax: cint;
+    we_do_not_use_max_qdiff: cint;
+    we_do_not_use_rc_buffer_size: cint;
+    we_do_not_use_rc_override_count: cint;
+    we_do_not_use_rc_override: pointer;
+    we_do_not_use_rc_max_rate: cint64;
+    we_do_not_use_rc_min_rate: cint64;
+    we_do_not_use_rc_max_available_vbv_use: cfloat;
+    we_do_not_use_rc_min_vbv_overflow_use: cfloat;
+    we_do_not_use_rc_initial_buffer_occupancy: cint;
+    we_do_not_use_coder_type: cint;
+    we_do_not_use_context_model: cint;
+    we_do_not_use_frame_skip_threshold: cint;
+    we_do_not_use_frame_skip_factor: cint;
+    we_do_not_use_frame_skip_exp: cint;
+    we_do_not_use_frame_skip_cmp: cint;
+    we_do_not_use_trellis: cint;
+    we_do_not_use_min_prediction_order: cint;
+    we_do_not_use_max_prediction_order: cint;
+    we_do_not_use_timecode_frame_start: cint64;
+    we_do_not_use_rtp_callback: cfunctionpointer;
+    we_do_not_use_rtp_payload_size: cint;
+    we_do_not_use_mv_bits: cint;
+    we_do_not_use_header_bits: cint;
+    we_do_not_use_i_tex_bits: cint;
+    we_do_not_use_p_tex_bits: cint;
+    we_do_not_use_i_count: cint;
+    we_do_not_use_p_count: cint;
+    we_do_not_use_skip_count: cint;
+    we_do_not_use_misc_bits: cint;
+    we_do_not_use_frame_bits: cint;
+    we_do_not_use_stats_out: pcchar;
+    we_do_not_use_stats_in: pcchar;
     workaround_bugs: cint;
-
-    (**
-     * strictly follow the standard (MPEG-4, ...).
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     * Setting this to STRICT or higher means the encoder and decoder will
-     * generally do stupid things, whereas setting it to unofficial or lower
-     * will mean the encoder might produce output that is not supported by all
-     * spec-compliant decoders. Decoders don't differentiate between normal,
-     * unofficial and experimental (that is, they always try to decode things
-     * when they can) unless they are explicitly asked to behave stupidly
-     * (=strictly conform to the specs)
-     *)
-    strict_std_compliance: cint;
-
-    (**
-     * error concealment flags
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    error_concealment: cint;
-
-    (**
-     * debug
-     * Code outside libavcodec should access this field using AVOptions
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
+    we_do_not_use_strict_std_compliance: cint;
+    we_do_not_use_error_concealment: cint;
     debug: cint;
-
-{$IFDEF FF_API_DEBUG_MV}
-    (**
-     * debug
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    debug_mv: cint;
-{$ENDIF}
-
-    (**
-     * Error recognition; may misdetect some more or less valid parts as errors.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    err_recognition: cint;
-
-    (**
-     * opaque 64-bit number (generally a PTS) that will be reordered and
-     * output in AVFrame.reordered_opaque
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    reordered_opaque: cint64;
-
-    (**
-     * Hardware accelerator in use
-     * - encoding: unused.
-     * - decoding: Set by libavcodec
-     *)
-    hwaccel: {const} PAVHWAccel;
-
-    (**
-     * Hardware accelerator context.
-     * For some hardware accelerators, a global context needs to be
-     * provided by the user. In that case, this holds display-dependent
-     * data FFmpeg cannot instantiate itself. Please refer to the
-     * FFmpeg HW accelerator documentation to know how to fill this
-     * is. e.g. for VA API, this is a struct vaapi_context.
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    hwaccel_context: pointer;
-
-    (**
-     * error
-     * - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
-     * - decoding: unused
-     *)
-    error: array [0..AV_NUM_DATA_POINTERS - 1] of cuint64;
-
-    (**
-     * DCT algorithm, see FF_DCT_* below
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    dct_algo: cint;
-
-    (**
-     * IDCT algorithm, see FF_IDCT_* below.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    idct_algo: cint;
-
-    (**
-     * bits per sample/pixel from the demuxer (needed for huffyuv).
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by user.
-     *)
-    bits_per_coded_sample: cint;
-
-    (**
-     * Bits per sample/pixel of internal libavcodec pixel/sample format.
-     * - encoding: set by user.
-     * - decoding: set by libavcodec.
-     *)
-    bits_per_raw_sample: cint;
-
-{$IFDEF FF_API_LOWRES}
-    (**
-     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    lowres: cint;
-{$ENDIF}
-
-{$IFDEF FF_API_CODED_FRAME}
-    (**
-     * the picture in the bitstream
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     *
-     * @deprecated use the quality factor packet side data instead
-     *)
-    {attribute_deprecated}
-    coded_frame: PAVFrame;
-{$ENDIF}
-
-    (**
-     * thread count
-     * is used to decide how many independent tasks should be passed to execute()
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    thread_count: cint;
-
-    (**
-     * Which multithreading methods to use.
-     * Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
-     * so clients which cannot provide future frames should not use it.
-     *
-     * - encoding: Set by user, otherwise the default is used.
-     * - decoding: Set by user, otherwise the default is used.
-     *)
-    thread_type: cint;
-
-    (**
-     * Which multithreading methods are in use by the codec.
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     *)
-    active_thread_type: cint;
-
-    (**
-     * Set by the client if its custom get_buffer() callback can be called
-     * from another thread, which allows faster multithreaded decoding.
-     * draw_horiz_band() will be called from other threads regardless of this setting.
-     * Ignored if the default get_buffer() is used.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    thread_safe_callbacks: cint;
-
-    (**
-     * The codec may call this to execute several independent things.
-     * It will return only after finishing all tasks.
-     * The user may replace this with some multithreaded implementation,
-     * the default implementation will execute the parts serially.
-     * @param count the number of things to execute
-     * - encoding: Set by libavcodec, user can override.
-     * - decoding: Set by libavcodec, user can override.
-     *)
-    execute: function (c: PAVCodecContext; func: TExecuteFunc; arg: Pointer; ret: PCint; count: cint; size: cint): cint; cdecl;
-
-    (**
-     * The codec may call this to execute several independent things.
-     * It will return only after finishing all tasks.
-     * The user may replace this with some multithreaded implementation,
-     * the default implementation will execute the parts serially.
-     * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
-     * @param c context passed also to func
-     * @param count the number of things to execute
-     * @param arg2 argument passed unchanged to func
-     * @param ret return values of executed functions, must have space for "count" values. May be NULL.
-     * @param func function that will be called count times, with jobnr from 0 to count-1.
-     *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
-     *             two instances of func executing at the same time will have the same threadnr.
-     * @return always 0 currently, but code should handle a future improvement where when any call to func
-     *         returns < 0 no further calls to func may be done and < 0 is returned.
-     * - encoding: Set by libavcodec, user can override.
-     * - decoding: Set by libavcodec, user can override.
-     *)
-    execute2: function (c: PAVCodecContext; func: TExecute2Func; arg2: Pointer; ret: Pcint; count: cint): cint; cdecl;
-
-    (**
-     * noise vs. sse weight for the nsse comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     *)
-    nsse_weight: cint;
-
-    (**
-     * profile
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    profile: cint;
-
-    (**
-     * level
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    level: cint;
-
-    (**
-     * Skip loop filtering for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    skip_loop_filter: TAVDiscard;
-
-    (**
-     * Skip IDCT/dequantization for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    skip_idct: TAVDiscard;
-
-    (**
-     * Skip decoding for selected frames.
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    skip_frame: TAVDiscard;
-
-    (**
-     * Header containing style information for text subtitles.
-     * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
-     * [Script Info] and [V4+ Styles] section, plus the [Events] line and
-     * the Format line following. It shouldn't include any Dialogue line.
-     * - encoding: Set/allocated/freed by user (before avcodec_open2())
-     * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
-     *)
-    subtitle_header: Pcuint8;
-    subtitle_header_size: cint;
-
-{$IFDEF FF_API_VBV_DELAY}
-    (**
-     * VBV delay coded in the last frame (in periods of a 27 MHz clock).
-     * Used for compliant TS muxing.
-     * - encoding: Set by libavcodec.
-     * - decoding: unused.
-     * @deprecated this value is now exported as a part of
-     * AV_PKT_DATA_CPB_PROPERTIES packet side data
-     *)
-    vbv_delay: cuint64; {deprecated}
-{$ENDIF}
-
-{$IFDEF FF_API_SIDEDATA_ONLY_PKT}
-    (**
-     * Encoding only and set by default. Allow encoders to output packets
-     * that do not contain any encoded data, only side data.
-     *
-     * Some encoders need to output such packets, e.g. to update some stream
-     * parameters at the end of encoding.
-     *
-     * @deprecated this field disables the default behaviour and
-     *             it is kept only for compatibility.
-     *)
-    side_data_only_packets: cint; {deprecated}
-{$ENDIF}
-
-    (**
-     * Audio only. The number of "priming" samples (padding) inserted by the
-     * encoder at the beginning of the audio. I.e. this number of leading
-     * decoded samples must be discarded by the caller to get the original audio
-     * without leading padding.
-     *
-     * - decoding: unused
-     * - encoding: Set by libavcodec. The timestamps on the output packets are
-     *             adjusted by the encoder so that they always refer to the
-     *             first sample of the data actually contained in the packet,
-     *             including any added padding.  E.g. if the timebase is
-     *             1/samplerate and the timestamp of the first input sample is
-     *             0, the timestamp of the first output packet will be
-     *             -initial_padding.
-     *)
-    initial_padding: cint;
-
-    (**
-     * - decoding: For codecs that store a framerate value in the compressed
-     *             bitstream, the decoder may export it here. { 0, 1} when
-     *             unknown.
-     * - encoding: May be used to signal the framerate of CFR content to an
-     *             encoder.
-     *)
+    we_do_not_use_err_recognition: cint;
+    we_do_not_use_reordered_opaque: cint64;
+    we_do_not_use_hwaccel: pointer;
+    we_do_not_use_hwaccel_context: pointer;
+    we_do_not_use_error: array [0..AV_NUM_DATA_POINTERS-1] of cuint64;
+    we_do_not_use_dct_algo: cint;
+    we_do_not_use_idct_algo: cint;
+    we_do_not_use_bits_per_coded_sample: cint;
+    we_do_not_use_bits_per_raw_sample: cint;
+    we_do_not_use_lowres: cint;
+    we_do_not_use_coded_frame: PAVFrame;
+    we_do_not_use_thread_count: cint;
+    we_do_not_use_thread_type: cint;
+    we_do_not_use_active_thread_type: cint;
+    we_do_not_use_thread_safe_callbacks: cint;
+    we_do_not_use_execute: cfunctionpointer;
+    we_do_not_use_execute2: cfunctionpointer; 
+    we_do_not_use_nsse_weight: cint;
+    we_do_not_use_profile: cint;
+    we_do_not_use_level: cint;
+    we_do_not_use_skip_loop_filter: cenum;
+    we_do_not_use_skip_idct: cenum;
+    we_do_not_use_skip_frame: cenum;
+    we_do_not_use_subtitle_header: pcuint8;
+    we_do_not_use_subtitle_header_size: cint;
+    we_do_not_use_vbv_delay: cuint64;
+    we_do_not_use_side_data_only_packets: cint;
+    we_do_not_use_initial_padding: cint;
     framerate: TAVRational;
-
-    (**
-     * Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
-     * - encoding: unused.
-     * - decoding: Set by libavcodec before calling get_format()
-     *)
-    sw_pix_fmt: TAVPixelFormat;
-
-    (**
-     * Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
-     * - encoding unused.
-     * - decoding set by user
-     *)
-    pkt_timebase: TAVRational;
-
-    (**
-     * AVCodecDescriptor
-     * - encoding: unused.
-     * - decoding: set by libavcodec.
-     *)
-    codec_descriptor: PAVCodecDescriptor;
-
-{$IFNDEF FF_API_LOWRES}
-    (**
-     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
-     * - encoding: unused
-     * - decoding: Set by user.
-     *)
-    lowres: cint;
-{$ENDIF}
-
-    (**
-     * Current statistics for PTS correction.
-     * - decoding: maintained and used by libavcodec, not intended to be used by user apps
-     * - encoding: unused
-     *)
-    pts_correction_num_faulty_pts: cint64; /// Number of incorrect PTS values so far
-    pts_correction_num_faulty_dts: cint64; /// Number of incorrect DTS values so far
-    pts_correction_last_pts: cint64;       /// PTS of the last frame
-    pts_correction_last_dts: cint64;       /// DTS of the last frame
-
-    (**
-     * Character encoding of the input subtitles file.
-     * - decoding: set by user
-     * - encoding: unused
-     *)
-    sub_charenc: PAnsiChar;
-
-    (**
-     * Subtitles character encoding mode. Formats or codecs might be adjusting
-     * this setting (if they are doing the conversion themselves for instance).
-     * - decoding: set by libavcodec
-     * - encoding: unused
-     *)
-    sub_charenc_mode: cint;
-
-    (**
-     * Skip processing alpha if supported by codec.
-     * Note that if the format uses pre-multiplied alpha (common with VP6,
-     * and recommended due to better video quality/compression)
-     * the image will look as if alpha-blended onto a black background.
-     * However for formats that do not use pre-multiplied alpha
-     * there might be serious artefacts (though e.g. libswscale currently
-     * assumes pre-multiplied alpha anyway).
-     *
-     * - decoding: set by user
-     * - encoding: unused
-     *)
-    skip_alpha: cint;
-
-    (**
-     * Number of samples to skip after a discontinuity
-     * - decoding: unused
-     * - encoding: set by libavcodec
-     *)
-    seek_preroll: cint;
-
-{$IFNDEF FF_API_DEBUG_MV}
-    (**
-     * debug motion vectors
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
+    we_do_not_use_sw_pix_fmt: TAVPixelFormat;
+    we_do_not_use_pkt_timebase: TAVRational;
+    we_do_not_use_codec_descriptor: PAVCodecDescriptor;
+    we_do_not_use_pts_correction_num_faulty_pts: cint64;
+    we_do_not_use_pts_correction_num_faulty_dts: cint64;
+    we_do_not_use_pts_correction_last_pts: cint64;
+    we_do_not_use_pts_correction_last_dts: cint64;
+    we_do_not_use_sub_charenc: pcchar;
+    we_do_not_use_sub_charenc_mode: cint;
+    we_do_not_use_skip_alpha: cint;
+    we_do_not_use_seek_preroll: cint;
     debug_mv: cint;
-{$ENDIF}
-
-    (**
-     * custom intra quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: unused.
-     *)
-    chroma_intra_matrix: PWord;
-
-    (**
-     * dump format separator.
-     * can be ", " or "\n      " or anything else
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *)
-    dump_separator: Pcuint8;
-
-    (**
-     * ',' separated list of allowed decoders.
-     * If NULL then all are allowed
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    codec_whitelist: PAnsiChar;
-
-    (**
-     * Properties of the stream that gets decoded
-     * - encoding: unused
-     * - decoding: set by libavcodec
-     *)
-    properties: cuint;
-
-    (**
-     * Additional data associated with the entire coded stream.
-     *
-     * - decoding: unused
-     * - encoding: may be set by libavcodec after avcodec_open2().
-     *)
-    coded_side_data: PAVPacketSideData;
-    nb_coded_side_data: cint;
-
-    (**
-     * A reference to the AVHWFramesContext describing the input (for encoding)
-     * or output (decoding) frames. The reference is set by the caller and
-     * afterwards owned (and freed) by libavcodec - it should never be read by
-     * the caller after being set.
-     *
-     * - decoding: This field should be set by the caller from the get_format()
-     *             callback. The previous reference (if any) will always be
-     *             unreffed by libavcodec before the get_format() call.
-     *
-     *             If the default get_buffer2() is used with a hwaccel pixel
-     *             format, then this AVHWFramesContext will be used for
-     *             allocating the frame buffers.
-     *
-     * - encoding: For hardware encoders configured to use a hwaccel pixel
-     *             format, this field should be set by the caller to a reference
-     *             to the AVHWFramesContext describing input frames.
-     *             AVHWFramesContext.format must be equal to
-     *             AVCodecContext.pix_fmt.
-     *
-     *             This field should be set before avcodec_open2() is called.
-     *)
-    hw_frames_ctx: PAVBufferRef;
-
-    (**
-     * Control the form of AVSubtitle.rects[N]->ass
-     * - decoding: set by user
-     * - encoding: unused
-     *)
-    sub_text_format: cint;
-
-    (**
-     * Audio only. The amount of padding (in samples) appended by the encoder to
-     * the end of the audio. I.e. this number of decoded samples must be
-     * discarded by the caller from the end of the stream to get the original
-     * audio without any trailing padding.
-     *
-     * - decoding: unused
-     * - encoding: unused
-     *)
-    trailing_padding: cint;
-
-    (**
-     * The number of pixels per image to maximally accept.
-     *
-     * - decoding: set by user
-     * - encoding: set by user
-     *)
-    max_pixels: cint64;
-
-    (**
-     * A reference to the AVHWDeviceContext describing the device which will
-     * be used by a hardware encoder/decoder.  The reference is set by the
-     * caller and afterwards owned (and freed) by libavcodec.
-     *
-     * This should be used if either the codec device does not require
-     * hardware frames or any that are used are to be allocated internally by
-     * libavcodec.  If the user wishes to supply any of the frames used as
-     * encoder input or decoder output then hw_frames_ctx should be used
-     * instead.  When hw_frames_ctx is set in get_format() for a decoder, this
-     * field will be ignored while decoding the associated stream segment, but
-     * may again be used on a following one after another get_format() call.
-     *
-     * For both encoders and decoders this field should be set before
-     * avcodec_open2() is called and must not be written to thereafter.
-     *
-     * Note that some decoders may require this field to be set initially in
-     * order to support hw_frames_ctx at all - in that case, all frames
-     * contexts used must be created on the same device.
-     *)
-    hw_device_ctx: PAVBufferRef;
-
-    (**
-     * Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
-     * decoding (if active).
-     * - encoding: unused
-     * - decoding: Set by user (either before avcodec_open2(), or in the
-     *             AVCodecContext.get_format callback)
-     *)
-    hwaccel_flags: cint;
-
-    (**
-     * Video decoding only. Certain video codecs support cropping, meaning that
-     * only a sub-rectangle of the decoded frame is intended for display.  This
-     * option controls how cropping is handled by libavcodec.
-     *
-     * When set to 1 (the default), libavcodec will apply cropping internally.
-     * I.e. it will modify the output frame width/height fields and offset the
-     * data pointers (only by as much as possible while preserving alignment, or
-     * by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
-     * the frames output by the decoder refer only to the cropped area. The
-     * crop_* fields of the output frames will be zero.
-     *
-     * When set to 0, the width/height fields of the output frames will be set
-     * to the coded dimensions and the crop_* fields will describe the cropping
-     * rectangle. Applying the cropping is left to the caller.
-     *
-     * @warning When hardware acceleration with opaque output frames is used,
-     * libavcodec is unable to apply cropping from the top/left border.
-     *
-     * @note when this option is set to zero, the width/height fields of the
-     * AVCodecContext and output AVFrames have different meanings. The codec
-     * context fields store display dimensions (with the coded dimensions in
-     * coded_width/height), while the frame fields store the coded dimensions
-     * (with the display dimensions being determined by the crop_* fields).
-     *)
-    apply_cropping: cint;
-
-    (*
-     * Video decoding only.  Sets the number of extra hardware frames which
-     * the decoder will allocate for use by the caller.  This must be set
-     * before avcodec_open2() is called.
-     *
-     * Some hardware decoders require all frames that they will use for
-     * output to be defined in advance before decoding starts.  For such
-     * decoders, the hardware frame pool must therefore be of a fixed size.
-     * The extra frames set here are on top of any number that the decoder
-     * needs internally in order to operate normally (for example, frames
-     * used as reference pictures).
-     *)
-    extra_hw_frames: cint;
-  end; {TAVCodecContext}
-
-  TAVSubtitleType = (
-    SUBTITLE_NONE,
-
-    SUBTITLE_BITMAP,                ///< A bitmap, pict will be set
-
-    (**
-     * Plain text, the text field must be set by the decoder and is
-     * authoritative. ass and pict fields may contain approximations.
-     *)
-    SUBTITLE_TEXT,
-
-    (**
-     * Formatted text, the ass field must be set by the decoder and is
-     * authoritative. pict and text fields may contain approximations.
-     *)
-    SUBTITLE_ASS
-  ); {TAVSubtitleType}
-
-{$IFDEF FF_API_AVPICTURE}
-  (**
-   * @defgroup lavc_picture AVPicture
-   *
-   * Functions for working with AVPicture
-   * @{
-   *)
-
-  (**
-    * Picture data structure.
-    *
-    * Up to four components can be stored into it, the last component is
-    * alpha.
-    * @deprecated use AVFrame or imgutils functions instead
-    *)
-    PAVPicture = ^TAVPicture;
-    TAVPicture = record
-      data: array [0..AV_NUM_DATA_POINTERS - 1] of PByteArray; {deprecated}
-      linesize: array [0..AV_NUM_DATA_POINTERS - 1] of cint; {deprecated} ///< number of bytes per line
-    end; {TAVPicture}
-{$ENDIF}
-
-  PPAVSubtitleRect = ^PAVSubtitleRect;
-  PAVSubtitleRect = ^TAVSubtitleRect;
-  TAVSubtitleRect = record
-    x: cint;        ///< top left corner  of pict, undefined when pict is not set
-    y: cint;        ///< top left corner  of pict, undefined when pict is not set
-    w: cint;        ///< width            of pict, undefined when pict is not set
-    h: cint;        ///< height           of pict, undefined when pict is not set
-    nb_colors: cint; ///< number of colors in pict, undefined when pict is not set
-
-{$IFDEF FF_API_AVPICTURE}
-    (**
-     * @deprecated unused
-     *)
-    pict: TAVPicture; {deprecated}
-{$ENDIF}
-    (**
-     * data+linesize for the bitmap of this subtitle.
-     * Can be set for text/ass as well once they are rendered.
-     *)
-    data: Array [0..4] of PByte;
-    linesize: Array [0..4] of cint;
-
-    type_: TAVSubtitleType;
-
-    text: PAnsiChar;                     ///< 0 terminated plain UTF-8 text
-
-    (**
-     * 0 terminated ASS/SSA compatible event line.
-     * The presentation of this is unaffected by the other values in this
-     * struct.
-     *)
-    ass: PAnsiChar;
-
-    flags: cint;
-  end; {TAVSubtitleRect}
-
-  PPAVSubtitle = ^PAVSubtitle;
-  PAVSubtitle = ^TAVSubtitle;
-  TAVSubtitle = record
-    format: cuint16; (* 0 = graphics *)
-    start_display_time: cuint32; (* relative to packet pts, in ms *)
-    end_display_time: cuint32; (* relative to packet pts, in ms *)
-    num_rects: cuint;
-    rects: PPAVSubtitleRect;
-    pts: cint64;     ///< Same as packet pts, in AV_TIME_BASE
-  end; {TAVSubtitle}
-
-  (**
-   * This struct describes the properties of an encoded stream.
-   *
-   * sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
-   * be allocated with avcodec_parameters_alloc() and freed with
-   * avcodec_parameters_free().
-   *)
-  PPAVCodecParameters = ^PAVCodecParameters;
-  PAVCodecParameters  = ^TAVCodecParameters;
-  TAVCodecParameters = record
-    (**
-     * General type of the encoded data.
-     *)
-    codec_type: TAVMediaType;
-    (**
-     * Specific type of the encoded data (the codec used).
-     *)
-    codec_id: TAVCodecID;
-    (**
-     * Additional information about the codec (corresponds to the AVI FOURCC).
-     *)
-    codec_tag: cuint32;
-
-    (**
-     * Extra binary data needed for initializing the decoder, codec-dependent.
-     *
-     * Must be allocated with av_malloc() and will be freed by
-     * avcodec_parameters_free(). The allocated size of extradata must be at
-     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
-     * bytes zeroed.
-     *)
-    extradata: Pcuint8;
-    (**
-     * Size of the extradata content in bytes.
-     *)
-    extradata_size: cint;
-
-    (**
-     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
-     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
-     *)
-    format: cint;
-
-    (**
-     * The average bitrate of the encoded data (in bits per second).
-     *)
-    bit_rate: cint64;
-
-    (**
-     * The number of bits per sample in the codedwords.
-     *
-     * This is basically the bitrate per sample. It is mandatory for a bunch of
-     * formats to actually decode them. It's the number of bits for one sample in
-     * the actual coded bitstream.
-     *
-     * This could be for example 4 for ADPCM
-     * For PCM formats this matches bits_per_raw_sample
-     * Can be 0
-     *)
-    bits_per_coded_sample: cint;
-
-    (**
-     * This is the number of valid bits in each output sample. If the
-     * sample format has more bits, the least significant bits are additional
-     * padding bits, which are always 0. Use right shifts to reduce the sample
-     * to its actual size. For example, audio formats with 24 bit samples will
-     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
-     * To get the original sample use "(int32_t)sample >> 8"."
-     *
-     * For ADPCM this might be 12 or 16 or similar
-     * Can be 0
-     *)
-    bits_per_raw_sample: cint;
-
-    (**
-     * Codec-specific bitstream restrictions that the stream conforms to.
-     *)
-    profile: cint;
-    level: cint;
-
-    (**
-     * Video only. The dimensions of the video frame in pixels.
-     *)
-    width: cint;
-    height: cint;
-
-    (**
-     * Video only. The aspect ratio (width / height) which a single pixel
-     * should have when displayed.
-     *
-     * When the aspect ratio is unknown / undefined, the numerator should be
-     * set to 0 (the denominator may have any value).
-     *)
-    sample_aspect_ratio: TAVRational;
-
-    (**
-     * Video only. The order of the fields in interlaced video.
-     *)
-    field_order: TAVFieldOrder;
-
-    (**
-     * Video only. Additional colorspace characteristics.
-     *)
-    color_range: TAVColorRange;
-    color_primaries: TAVColorPrimaries;
-    color_trc: TAVColorTransferCharacteristic;
-    color_space: TAVColorSpace;
-    chroma_location: TAVChromaLocation;
-
-    (**
-     * Video only. Number of delayed frames.
-     *)
-    video_delay: cint;
-
-    (**
-     * Audio only. The channel layout bitmask. May be 0 if the channel layout is
-     * unknown or unspecified, otherwise the number of bits set must be equal to
-     * the channels field.
-     *)
-    channel_layout: cuint64;
-    (**
-     * Audio only. The number of audio channels.
-     *)
-    channels: cint;
-    (**
-     * Audio only. The number of audio samples per second.
-     *)
-    sample_rate: cint;
-    (**
-     * Audio only. The number of bytes per coded audio frame, required by some
-     * formats.
-     *
-     * Corresponds to nBlockAlign in WAVEFORMATEX.
-     *)
-    block_align: cint;
-    (**
-     * Audio only. Audio frame size, if known. Required by some formats to be static.
-     *)
-    frame_size: cint;
-
-    (**
-     * Audio only. The amount of padding (in samples) inserted by the encoder at
-     * the beginning of the audio. I.e. this number of leading decoded samples
-     * must be discarded by the caller to get the original audio without leading
-     * padding.
-     *)
-    initial_padding: cint;
-    (**
-     * Audio only. The amount of padding (in samples) appended by the encoder to
-     * the end of the audio. I.e. this number of decoded samples must be
-     * discarded by the caller from the end of the stream to get the original
-     * audio without any trailing padding.
-     *)
-    trailing_padding: cint;
-    (**
-     * Audio only. Number of samples to skip after a discontinuity.
-     *)
-    seek_preroll: cint;
-  end; {TAVCodecParameters}
-
-(**
- * AVCodec.
- *)
-  TAVCodec = record
-    (**
-     * Name of the codec implementation.
-     * The name is globally unique among encoders and among decoders (but an
-     * encoder and a decoder can share the same name).
-     * This is the primary way to find a codec from the user perspective.
-     *)
-    name: PAnsiChar;
-    (**
-     * Descriptive name for the codec, meant to be more human readable than name.
-     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
-     *)
-    long_name: {const} PAnsiChar;
-    type_: TAVMediaType;
-    id: TAVCodecID;
-    (**
-     * Codec capabilities.
-     * see AV_CODEC_CAP_*
-     *)
-    capabilities: cint;
-    supported_framerates: {const} PAVRational; ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
-    pix_fmts: {const} PAVPixelFormat;          ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
-    supported_samplerates: {const} PCint;      ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
-    sample_fmts: {const} PAVSampleFormatArray; ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
-    channel_layouts: {const} PCuint64;         ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
-    max_lowres: byte;                          ///< maximum value for lowres supported by the decoder
-    priv_class: {const} PAVClass;              ///< AVClass for the private context
-    profiles: {const} PAVProfile;              ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
-
-    (**
-     * Group name of the codec implementation.
-     * This is a short symbolic name of the wrapper backing this codec. A
-     * wrapper uses some kind of external implementation for the codec, such
-     * as an external library, or a codec implementation provided by the OS or
-     * the hardware.
-     * If this field is NULL, this is a builtin, libavcodec native codec.
-     * If non-NULL, this will be the suffix in AVCodec.name in most cases
-     * (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
-     *)
-    wrapper_name: PAnsiChar {const};
-
-    (*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-    priv_data_size: cint;
-    next: PAVCodec;
-    (**
-     * @name Frame-level threading support functions
-     * @{
-     *)
-    (**
-     * If defined, called on thread contexts when they are created.
-     * If the codec allocates writable tables in init(), re-allocate them here.
-     * priv_data will be set to a copy of the original.
-     *)
-    init_thread_copy: function (avctx: PAVCodecContext): Pcint; cdecl;
-    (**
-     * Copy necessary context variables from a previous thread context to the current one.
-     * If not defined, the next thread will start automatically; otherwise, the codec
-     * must call ff_thread_finish_setup().
-     *
-     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
-     *)
-    update_thread_context: function (dst: PAVCodecContext; src: {const} PAVCodecContext): cint; cdecl;
-    (** @} *)
-
-    (**
-     * Private codec-specific defaults.
-     *)
-    defaults: {const} pointer;
-
-    (**
-     * Initialize codec static data, called from avcodec_register().
-     *
-     * This is not intended for time consuming operations as it is
-     * run for every codec regardless of that codec being used.
-     *)
-    init_static_data: procedure (codec: PAVCodec); cdecl;
-
-    init: function (avctx: PAVCodecContext): cint; cdecl;
-    encode_sub: function (avctx: PAVCodecContext; buf: PByteArray; buf_size: cint;
-                          sub: {const} PAVSubtitle): cint; cdecl;
-    (**
-     * Encode data to an AVPacket.
-     *
-     * @param      avctx          codec context
-     * @param      avpkt          output AVPacket (may contain a user-provided buffer)
-     * @param[in]  frame          AVFrame containing the raw data to be encoded
-     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
-     *                            non-empty packet was returned in avpkt.
-     * @return 0 on success, negative error code on failure
-     *)
-    encode2: function (avctx: PAVCodecContext; avpkt: PAVPacket; frame: {const} PAVFrame;
-                   got_packet_ptr: Pcint): cint; cdecl;
-    decode: function (avctx: PAVCodecContext; outdata: pointer; var outdata_size: cint; avpkt: PAVPacket): cint; cdecl;
-    close: function (avctx: PAVCodecContext): cint; cdecl;
-    (**
-     * Encode API with decoupled packet/frame dataflow. The API is the
-     * same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except
-     * that:
-     * - never called if the codec is closed or the wrong type,
-     * - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent,
-     * - only one drain frame is ever passed down,
-     *)
-    send_frame: function(avctx: PAVCodecContext; frame: {const} PAVFrame): cint; cdecl;
-    receive_packet: function(avctx: PAVCodecContext; avpkt: PAVPacket): cint; cdecl;
-
-    (**
-     * Decode API with decoupled packet/frame dataflow. This function is called
-     * to get one output frame. It should call ff_decode_get_packet() to obtain
-     * input data.
-     *)
-    receive_frame: function(avctx: PAVCodecContext; frame: PAVFrame): cint; cdecl;
-    (**
-     * Flush buffers.
-     * Will be called when seeking
-     *)
-    flush: procedure (avctx: PAVCodecContext); cdecl;
-    (**
-     * Internal codec capabilities.
-     * See FF_CODEC_CAP_* in internal.h
-     *)
-    caps_internal: cint;
-
-    (**
-     * Decoding only, a comma-separated list of bitstream filters to apply to
-     * packets before decoding.
-     *)
-    bsfs: {const} PAnsiChar;
-
-    (**
-     * Array of pointers to hardware configurations supported by the codec,
-     * or NULL if no hardware supported.  The array is terminated by a NULL
-     * pointer.
-     *
-     * The user can only access this field via avcodec_get_hw_config().
-     *)
-    //const struct AVCodecHWConfigInternal **hw_configs;
-    hw_configs: Ppointer {const};
-  end; {TAVCodec}
-
-(**
- * Retrieve supported hardware configurations for a codec.
- *
- * Values of index from zero to some maximum return the indexed configuration
- * descriptor; all other values return NULL.  If the codec does not support
- * any hardware configurations then it will always return NULL.
- *)
-  function avcodec_get_hw_config(codec: PAVCodec {const}; index: cint): PAVCodecHWConfig;
-    cdecl; external av__codec; deprecated; {const}
-
-const
-  (**
-   * HWAccel is experimental and is thus avoided in favor of non experimental
-   * codecs
-   *)
-  AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = $0200;
-
-  (**
-   * Hardware acceleration should be used for decoding even if the codec level
-   * used is unknown or higher than the maximum supported level reported by the
-   * hardware driver.
-   *
-   * It's generally a good idea to pass this flag unless you have a specific
-   * reason not to, as hardware tends to under-report supported levels.
-   *)
-  AV_HWACCEL_FLAG_IGNORE_LEVEL 	  = (1 << 0);
-
-  (**
-   * Hardware acceleration can output YUV pixel formats with a different chroma
-   * sampling than 4:2:0 and/or other than 8 bits per component.
-   *)
-  AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (1 << 1);
-
-  (**
-   * Hardware acceleration should still be attempted for decoding when the
-   * codec profile does not match the reported capabilities of the hardware.
-   *
-   * For example, this can be used to try to decode baseline profile H.264
-   * streams in hardware - it will often succeed, because many streams marked
-   * as baseline profile actually conform to constrained baseline profile.
-   *
-   * @warning If the stream is actually not supported then the behaviour is
-   *          undefined, and may include returning entirely incorrect output
-   *          while indicating success.
-   *)
-   AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = (1 << 2);
-
-  FF_SUB_CHARENC_MODE_DO_NOTHING  = -1;  ///< do nothing (demuxer outputs a stream supposed to be already in UTF-8, or the codec is bitmap for instance)
-  FF_SUB_CHARENC_MODE_AUTOMATIC   = 0;   ///< libavcodec will select the mode itself
-  FF_SUB_CHARENC_MODE_PRE_DECODER = 1;   ///< the AVPacket data needs to be recoded to UTF-8 before being fed to the decoder, requires iconv
-  FF_SUB_CHARENC_MODE_IGNORE      = 2;   ///< neither convert the subtitles, nor check them for valid UTF-8
-
-  FF_CODEC_PROPERTY_LOSSLESS        = $00000001;
-  FF_CODEC_PROPERTY_CLOSED_CAPTIONS = $00000002;
-  FF_SUB_TEXT_FMT_ASS               = 0;
-{$IFDEF FF_API_ASS_TIMING}
-  FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS  = 1;
-{$ENDIF}
-
-{$IFDEF FF_API_CODEC_GET_SET}
-  (**
-   * Accessors for some AVCodecContext fields. These used to be provided for ABI
-   * compatibility, and do not need to be used anymore.
-   *)
-  function  av_codec_get_pkt_timebase(avctx: {const} PAVCodecContext): TAVRational;
-    cdecl; external av__codec; deprecated;
-  procedure av_codec_set_pkt_timebase(avctx: {const} PAVCodecContext; val: TAVRational);
-    cdecl; external av__codec; deprecated;
-
-  function  av_codec_get_codec_descriptor(avctx: {const} PAVCodecContext): PAVCodecDescriptor;
-    cdecl; external av__codec; deprecated;
-  procedure av_codec_set_codec_descriptor(avctx: {const} PAVCodecContext; desc: {const} PAVCodecDescriptor);
-    cdecl; external av__codec; deprecated;
-
-  function av_codec_get_codec_properties(avctx: {const} PAVCodecContext): cuint;
-    cdecl; external av__codec; deprecated;
-
-{$IFDEF FF_API_LOWRES}
-  function  av_codec_get_lowres(avctx: {const} PAVCodecContext): cint;
-    cdecl; external av__codec; deprecated;
-  procedure av_codec_set_lowres(avctx: PAVCodecContext; val: cint);
-    cdecl; external av__codec; deprecated;
-{$ENDIF} {FF_API_LOWRES}
-
-  function av_codec_get_seek_preroll(avctx: {const} PAVCodecContext): cint;
-    cdecl; external av__codec; deprecated;
-  procedure av_codec_set_seek_preroll(avctx: PAVCodecContext; val: cint);
-    cdecl; external av__codec; deprecated;
-
-{$IFDEF FF_API_CODEC_GET_SET}
-  function av_codec_get_max_lowres(codec: {const} PAVCodec): cint;
-    cdecl; external av__codec; deprecated;
-{$ENDIF} {FF_API_CODEC_GET_SET}
-
-  function av_codec_get_chroma_intra_matrix(avctx: {const} PAVCodecContext): PWord;
-    cdecl; external av__codec; deprecated;
-  procedure av_codec_set_chroma_intra_matrix(avctx: PAVCodecContext; val: PWord);
-    cdecl; external av__codec; deprecated;
-{$ENDIF} {FF_API_CODEC_GET_SET}
-
-(**
- * @
- *)
-
-const
-  AV_SUBTITLE_FLAG_FORCED = $00000001;
-
-(**
- * Iterate over all registered codecs.
- *
- * @param opaque a pointer where libavcodec will store the iteration state. Must
- *               point to NULL to start the iteration.
- *
- * @return the next registered codec or NULL when the iteration is
- *         finished
- *)
-function av_codec_iterate(opaque: pointer): PAVCodec;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_NEXT}
-(**
- * If c is NULL, returns the first registered codec,
- * if c is non-NULL, returns the next registered codec after c,
- * or NULL if c is the last one.
- *)
-function av_codec_next(c: {const} PAVCodec): PAVCodec;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Return the LIBAVCODEC_VERSION_INT constant.
- *)
-function avcodec_version(): cuint;
-  cdecl; external av__codec;
-
-(**
- * Return the libavcodec build-time configuration.
- *)
-function avcodec_configuration(): PAnsiChar;
-  cdecl; external av__codec;
-
-(**
- * Return the libavcodec license.
- *)
-function avcodec_license(): PAnsiChar;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_NEXT}
-(**
- * Register the codec codec and initialize libavcodec.
- *
- * @warning either this function or avcodec_register_all() must be called
- * before any other libavcodec functions.
- *
- * @see avcodec_register_all()
- *)
-procedure avcodec_register(codec: PAVCodec);
-  cdecl; external av__codec; deprecated;
-
-(**
- * Register all the codecs, parsers and bitstream filters which were enabled at
- * configuration time. If you do not call this function you can select exactly
- * which formats you want to support, by using the individual registration
- * functions.
- *
- * @see register_avcodec
- * @see avcodec_register
- * @see av_register_codec_parser
- * @see av_register_bitstream_filter
- *)
-procedure avcodec_register_all();
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Allocate an AVCodecContext and set its fields to default values. The
- * resulting struct should be freed with avcodec_free_context().
- *
- * @param codec if non-NULL, allocate private data and initialize defaults
- *              for the given codec. It is illegal to then call avcodec_open2()
- *              with a different codec.
- *
- * @return An AVCodecContext filled with default values or NULL on failure.
- *)
-function avcodec_alloc_context3(codec: {const} PAVCodec): PAVCodecContext;
-  cdecl; external av__codec;
-
-(**
- * Free the codec context and everything associated with it and write NULL to
- * the provided pointer.
- *)
-procedure avcodec_free_context(var avctx: PAVCodecContext);
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_GET_CONTEXT_DEFAULTS}
-(**
- * @deprecated This function should not be used, as closing and opening a codec
- * context multiple time is not supported. A new codec context should be
- * allocated for each new use.
- *)
-procedure avcodec_get_context_defaults3(s: PAVCodecContext; codec: {const} PAVCodec);
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Get the AVClass for AVCodecContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function avcodec_get_class(): {const} PAVClass;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_COPY_CONTEXT}
-(**
- * Get the AVClass for AVFrame. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function avcodec_get_frame_class(): {const} PAVClass;
-  cdecl; external av__codec;
-
-(**
- * Get the AVClass for AVSubtitleRect. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function avcodec_get_subtitle_rect_class(): {const} PAVClass;
-  cdecl; external av__codec;
-
-(**
- * Copy the settings of the source AVCodecContext into the destination
- * AVCodecContext. The resulting destination codec context will be
- * unopened, i.e. you are required to call avcodec_open2() before you
- * can use this AVCodecContext to decode/encode video/audio data.
- *
- * @param dest target codec context, should be initialized with
- *             avcodec_alloc_context3(), but otherwise uninitialized
- * @param src source codec context
- * @return AVERROR() on error (e.g. memory allocation error), 0 on success
- *
- * @deprecated The semantics of this function are ill-defined and it should not
- * be used. If you need to transfer the stream parameters from one codec context
- * to another, use an intermediate AVCodecParameters instance and the
- * avcodec_parameters_from_context() / avcodec_parameters_to_context()
- * functions.
- *)
-function avcodec_copy_context(dest: PAVCodecContext; src: {const} PAVCodecContext): cint;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Allocate a new AVCodecParameters and set its fields to default values
- * (unknown/invalid/0). The returned struct must be freed with
- * avcodec_parameters_free().
- *)
-function avcodec_parameters_alloc(): PAVCodecParameters;
-  cdecl; external av__codec;
-
-(**
- * Free an AVCodecParameters instance and everything associated with it and
- * write NULL to the supplied pointer.
- *)
-procedure avcodec_parameters_free(par: PPAVCodecParameters);
-  cdecl; external av__codec;
-
-(**
- * Copy the contents of src to dst. Any allocated fields in dst are freed and
- * replaced with newly allocated duplicates of the corresponding fields in src.
- *
- * @return >= 0 on success, a negative AVERROR code on failure.
- *)
-function avcodec_parameters_copy(dst: PAVCodecParameters; src: {const} PAVCodecParameters): cint;
-  cdecl; external av__codec;
-
-(**
- * Fill the parameters struct based on the values from the supplied codec
- * context. Any allocated fields in par are freed and replaced with duplicates
- * of the corresponding fields in codec.
- *
- * @return >= 0 on success, a negative AVERROR code on failure
- *)
-function avcodec_parameters_from_context(par: PAVCodecParameters;
-                                         codec: {const} PAVCodecContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Fill the codec context based on the values from the supplied codec
- * parameters. Any allocated fields in codec that have a corresponding field in
- * par are freed and replaced with duplicates of the corresponding field in par.
- * Fields in codec that do not have a counterpart in par are not touched.
- *
- * @return >= 0 on success, a negative AVERROR code on failure.
- *)
-function avcodec_parameters_to_context(codec: PAVCodecContext;
-                                       par: {const} PAVCodecParameters): cint;
-  cdecl; external av__codec;
-
-(**
- * Initialize the AVCodecContext to use the given AVCodec. Prior to using this
- * function the context has to be allocated with avcodec_alloc_context3().
- *
- * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
- * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
- * retrieving a codec.
- *
- * @warning This function is not thread safe!
- *
- * @note Always call this function before using decoding routines (such as
- * @ref avcodec_receive_frame()).
- *
- * @code
- * avcodec_register_all();
- * av_dict_set(&opts, "b", "2.5M", 0);
- * codec = avcodec_find_decoder(AV_CODEC_ID_H264);
- * if (!codec)
- *     exit(1);
- *
- * context = avcodec_alloc_context3(codec);
- *
- * if (avcodec_open2(context, codec, opts) < 0)
- *     exit(1);
- * @endcode
- *
- * @param avctx The context to initialize.
- * @param codec The codec to open this context for. If a non-NULL codec has been
- *              previously passed to avcodec_alloc_context3() or
- *              for this context, then this parameter MUST be either NULL or
- *              equal to the previously passed codec.
- * @param options A dictionary filled with AVCodecContext and codec-private options.
- *                On return this object will be filled with options that were not found.
- *
- * @return zero on success, a negative value on error
- * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
- *      av_dict_set(), av_opt_find().
- *)
-function avcodec_open2(avctx: PAVCodecContext; codec: {const} PAVCodec; options: PPAVDictionary): cint;
-  cdecl; external av__codec;
-
-(**
- * Close a given AVCodecContext and free all the data associated with it
- * (but not the AVCodecContext itself).
- *
- * Calling this function on an AVCodecContext that hasn't been opened will free
- * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
- * codec. Subsequent calls will do nothing.
- *
- * @note Do not use this function. Use avcodec_free_context() to destroy a
- * codec context (either open or closed). Opening and closing a codec context
- * multiple times is not supported anymore -- use multiple codec contexts
- * instead.
- *)
-function avcodec_close(avctx: PAVCodecContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Free all allocated data in the given subtitle struct.
- *
- * @param sub AVSubtitle to free.
- *)
-procedure avsubtitle_free(sub: PAVSubtitle);
-  cdecl; external av__codec;
-
-(**
- * @}
- *)
-
-(**
- * @addtogroup lavc_packet
- * @{
- *)
-
-(**
- * Allocate an AVPacket and set its fields to default values.  The resulting
- * struct must be freed using av_packet_free().
- *
- * @return An AVPacket filled with default values or NULL on failure.
- *
- * @note this only allocates the AVPacket itself, not the data buffers. Those
- * must be allocated through other means such as av_new_packet.
- *
- * @see av_new_packet
- *)
-function av_packet_alloc(): PAVPacket;
-  cdecl; external av__codec;
-
-(**
- * Create a new packet that references the same data as src.
- *
- * This is a shortcut for av_packet_alloc()+av_packet_ref().
- *
- * @return newly created AVPacket on success, NULL on error.
- *
- * @see av_packet_alloc
- * @see av_packet_ref
- *)
-function av_packet_clone(src: {const} PAVPacket): PAVPacket;
-  cdecl; external av__codec;
-
-(**
- * Free the packet, if the packet is reference counted, it will be
- * unreferenced first.
- *
- * @param pkt packet to be freed. The pointer will be set to NULL.
- * @note passing NULL is a no-op.
- *)
-procedure av_packet_free(pkt: PPAVPacket);
-  cdecl; external av__codec;
-
-(*
- * Initialize optional fields of a packet with default values.
- *
- * Note, this does not touch the data and size members, which have to be
- * initialized separately.
- *
- * @param pkt packet
- *)
-procedure av_init_packet(var pkt: TAVPacket);
-  cdecl; external av__codec;
-
-(*
- * Allocate the payload of a packet and initialize its fields with
- * default values.
- *
- * @param pkt packet
- * @param size wanted payload size
- * @return 0 if OK, AVERROR_xxx otherwise
- *)
-function av_new_packet(pkt: PAVPacket; size: cint): cint;
-  cdecl; external av__codec;
-
-(*
- * Reduce packet size, correctly zeroing padding
- *
- * @param pkt packet
- * @param size new size
- *)
-procedure av_shrink_packet(pkt: PAVPacket; size: cint);
-  cdecl; external av__codec;
-
-(**
- * Increase packet size, correctly zeroing padding
- *
- * @param pkt packet
- * @param grow_by number of bytes by which to increase the size of the packet
- *)
-function av_grow_packet(pkt: PAVPacket; grow_by: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Initialize a reference-counted packet from av_malloc()ed data.
- *
- * @param pkt packet to be initialized. This function will set the data, size,
- *        buf and destruct fields, all others are left untouched.
- * @param data Data allocated by av_malloc() to be used as packet data. If this
- *        function returns successfully, the data is owned by the underlying AVBuffer.
- *        The caller may not access the data through other means.
- * @param size size of data in bytes, without the padding. I.e. the full buffer
- *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
- *
- * @return 0 on success, a negative AVERROR on error
- *)
-function av_packet_from_data(pkt: PAVPacket; data: PByte; size: cint): cint;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_AVPACKET_OLD_API}
-(*
- * @warning This is a hack - the packet memory allocation stuff is broken. The
- * packet is allocated if it was not really allocated.
- *
- * @deprecated Use av_packet_ref or av_packet_make_refcounted
- *)
-function av_dup_packet(pkt: PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Copy packet, including contents
- *
- * @return 0 on success, negative AVERROR on fail
- *
- * @deprecated Use av_packet_ref
- *)
-function av_copy_packet(dst: PAVPacket; src: {const} PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
- * Copy packet side data
- *
- * @return 0 on success, negative AVERROR on fail
- *
- * @deprecated Use av_packet_copy_props
- *)
-function av_copy_packet_side_data(dst: PAVPacket; src: {const} PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-
-(*
- * Free a packet.
- *
- * @deprecated Use av_packet_unref
- *
- * @param pkt packet to free
- *)
-procedure av_free_packet(pkt: PAVPacket);
-  cdecl; external av__codec; deprecated;
-
-(**
- * Allocate new information of a packet.
- *
- * @param pkt packet
- * @param type side information type
- * @param size side information size
- * @return pointer to fresh allocated data or NULL otherwise
- *)
-function av_packet_new_side_data(pkt: PAVPacket; type_: TAVPacketSideDataType;
-                                 size: cint): PByte;
-  cdecl; external av__codec;
-
-(**
- * Wrap an existing array as a packet side data.
- *
- * @param pkt packet
- * @param type side information type
- * @param data the side data array. It must be allocated with the av_malloc()
- *             family of functions. The ownership of the data is transferred to
- *             pkt.
- * @param size side information size
- * @return a non-negative number on success, a negative AVERROR code on
- *         failure. On failure, the packet is unchanged and the data remains
- *         owned by the caller.
- *)
-function av_packet_add_side_data(pkt: PAVPacket; type_: TAVPacketSideDataType;
-                                 data: Pcuint8; size: size_t): cint;
-  cdecl; external av__codec;
-
-(**
- * Shrink the already allocated side data buffer
- *
- * @param pkt packet
- * @param type side information type
- * @param size new side information size
- * @return 0 on success, < 0 on failure
- *)
-function av_packet_shrink_side_data(pkt: PAVPacket; type_: TAVPacketSideDataType;
-                                size: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Get side information from packet.
- *
- * @param pkt packet
- * @param type desired side information type
- * @param size pointer for side information size to store (optional)
- * @return pointer to data if present or NULL otherwise
- *)
-function av_packet_get_side_data(pkt: {const} PAVPacket; type_: TAVPacketSideDataType;
-                                 size: Pcint): PByte;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_MERGE_SD_API}
-function av_packet_merge_side_data(pkt: PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-
-function av_packet_split_side_data(pkt: PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-function av_packet_side_data_name(type_: TAVPacketSideDataType): PAnsiChar;
-  cdecl; external av__codec;
-
-(**
- * Pack a dictionary for use in side_data.
- *
- * @param dict The dictionary to pack.
- * @param size pointer to store the size of the returned data
- * @return pointer to data if successful, NULL otherwise
- *)
-function av_packet_pack_dictionary(dict: PAVDictionary; size: PCuint): PByte;
-  cdecl; external av__codec;
-
-(**
- * Unpack a dictionary from side_data.
- *
- * @param data data from side_data
- * @param size size of the data
- * @param dict the metadata storage dictionary
- * @return 0 on success, < 0 on failure
- *)
-function av_packet_unpack_dictionary(data: {const} PByte; size: cint; dict: PPAVDictionary): cint;
-  cdecl; external av__codec;
-
-(**
- * Convenience function to free all the side data stored.
- * All the other fields stay untouched.
- *
- * @param pkt packet
- *)
-procedure av_packet_free_side_data(pkt: PAVPacket);
-  cdecl; external av__codec;
-
-(**
- * Setup a new reference to the data described by a given packet
- *
- * If src is reference-counted, setup dst as a new reference to the
- * buffer in src. Otherwise allocate a new buffer in dst and copy the
- * data from src into it.
- *
- * All the other fields are copied from src.
- *
- * @see av_packet_unref
- *
- * @param dst Destination packet
- * @param src Source packet
- *
- * @return 0 on success, a negative AVERROR on error.
- *)
-function av_packet_ref(dst: PAVPacket; src: {const} PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Wipe the packet.
- *
- * Unreference the buffer referenced by the packet and reset the
- * remaining packet fields to their default values.
- *
- * @param pkt The packet to be unreferenced.
- *)
-procedure av_packet_unref(pkt: PAVPacket);
-  cdecl; external av__codec;
-
-(**
- * Move every field in src to dst and reset src.
- *
- * @see av_packet_unref
- *
- * @param src Source packet, will be reset
- * @param dst Destination packet
- *)
-procedure av_packet_move_ref(dst: PAVPacket; src: PAVPacket);
-  cdecl; external av__codec;
-
-(**
- * Copy only "properties" fields from src to dst.
- *
- * Properties for the purpose of this function are all the fields
- * beside those related to the packet data (buf, data, size)
- *
- * @param dst Destination packet
- * @param src Source packet
- *
- * @return 0 on success AVERROR on failure.
- *
- *)
-function av_packet_copy_props(dst: PAVPacket; src: {const} PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Ensure the data described by a given packet is reference counted.
- *
- * @note This function does not ensure that the reference will be writable.
- *       Use av_packet_make_writable instead for that purpose.
- *
- * @see av_packet_ref
- * @see av_packet_make_writable
- *
- * @param pkt packet whose data should be made reference counted.
- *
- * @return 0 on success, a negative AVERROR on error. On failure, the
- *         packet is unchanged.
- *)
-function av_packet_make_refcounted(pkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Create a writable reference for the data described by a given packet,
- * avoiding data copy if possible.
- *
- * @param pkt Packet whose data should be made writable.
- *
- * @return 0 on success, a negative AVERROR on failure. On failure, the
- *         packet is unchanged.
- *)
-function av_packet_make_writable(pkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Convert valid timing fields (timestamps / durations) in a packet from one
- * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
- * ignored.
- *
- * @param pkt packet on which the conversion will be performed
- * @param tb_src source timebase, in which the timing fields in pkt are
- *               expressed
- * @param tb_dst destination timebase, to which the timing fields will be
- *               converted
- *)
-procedure av_packet_rescale_ts(pkt: PAVPacket; tb_src, tb_dst: TAVRational);
-  cdecl; external av__codec;
-
-(**
- * @
- *)
-
-(**
- * @addtogroup lavc_decoding
- * @
- *)
-
-(**
- * Find a registered decoder with a matching codec ID.
- *
- * @param id CodecID of the requested decoder
- * @return A decoder if one was found, NULL otherwise.
- *)
-function avcodec_find_decoder(id: TAVCodecID): PAVCodec;
-  cdecl; external av__codec;
-
-(**
- * Find a registered decoder with the specified name.
- *
- * @param name name of the requested decoder
- * @return A decoder if one was found, NULL otherwise.
- *)
-function avcodec_find_decoder_by_name(name: PAnsiChar): PAVCodec;
-  cdecl; external av__codec;
-
-(**
- * The default callback for AVCodecContext.get_buffer2(). It is made public so
- * it can be called by custom get_buffer2() implementations for decoders without
- * AV_CODEC_CAP_DR1 set.
- *)
-function avcodec_default_get_buffer2(s: PAVCodecContext; frame: PAVFrame; flags: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Modify width and height values so that they will result in a memory
- * buffer that is acceptable for the codec if you do not use any horizontal
- * padding.
- *
- * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
- *)
-procedure avcodec_align_dimensions(s: PAVCodecContext; width: PCint; height: PCint);
-  cdecl; external av__codec;
-
-(**
- * Modifiy width and height values so that they will result in a memory
- * buffer that is acceptable for the codec if you also ensure that all
- * line sizes are a multiple of the respective linesize_align[i].
- *
- * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
- *)
-procedure avcodec_align_dimensions2(s: PAVCodecContext; width: PCint; height: PCint;
-                                    linesize_align: PAVNDPArray);
-  cdecl; external av__codec;
-
-(**
- * Decode the audio frame of size avpkt->size from avpkt->data into frame.
- *
- * Some decoders may support multiple frames in a single AVPacket. Such
- * decoders would then just decode the first frame and the return value would be
- * less than the packet size. In this case, avcodec_decode_audio4 has to be
- * called again with an AVPacket containing the remaining data in order to
- * decode the second frame, etc...  Even if no frames are returned, the packet
- * needs to be fed to the decoder with remaining data until it is completely
- * consumed or an error occurs.
- *
- * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
- * and output. This means that for some packets they will not immediately
- * produce decoded output and need to be flushed at the end of decoding to get
- * all the decoded data. Flushing is done by calling this function with packets
- * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
- * returning samples. It is safe to flush even those decoders that are not
- * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
- *
- * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
- *          larger than the actual read bytes because some optimized bitstream
- *          readers read 32 or 64 bits at once and could read over the end.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- * before packets may be fed to the decoder.
- *
- * @param      avctx the codec context
- * @param[out] frame The AVFrame in which to store decoded audio samples.
- *                   The decoder will allocate a buffer for the decoded frame by
- *                   calling the AVCodecContext.get_buffer2() callback.
- *                   When AVCodecContext.refcounted_frames is set to 1, the frame is
- *                   reference counted and the returned reference belongs to the
- *                   caller. The caller must release the frame using av_frame_unref()
- *                   when the frame is no longer needed. The caller may safely write
- *                   to the frame if av_frame_is_writable() returns 1.
- *                   When AVCodecContext.refcounted_frames is set to 0, the returned
- *                   reference belongs to the decoder and is valid only until the
- *                   next call to this function or until closing or flushing the
- *                   decoder. The caller may not write to it.
- * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
- *                           non-zero. Note that this field being set to zero
- *                           does not mean that an error has occurred. For
- *                           decoders with AV_CODEC_CAP_DELAY set, no given decode
- *                           call is guaranteed to produce a frame.
- * @param[in]  avpkt The input AVPacket containing the input buffer.
- *                   At least avpkt->data and avpkt->size should be set. Some
- *                   decoders might also require additional fields to be set.
- * @return A negative error code is returned if an error occurred during
- *         decoding, otherwise the number of bytes consumed from the input
- *         AVPacket is returned.
- *
- * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
- *)
-function avcodec_decode_audio4(avctx: PAVCodecContext; frame: PAVFrame;
-                       got_frame_ptr: Pcint; avpkt: PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
- * Decode the video frame of size avpkt->size from avpkt->data into picture.
- * Some decoders may support multiple frames in a single AVPacket, such
- * decoders would then just decode the first frame.
- *
- * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
- * the actual read bytes because some optimized bitstream readers read 32 or 64
- * bits at once and could read over the end.
- *
- * @warning The end of the input buffer buf should be set to 0 to ensure that
- * no overreading happens for damaged MPEG streams.
- *
- * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
- * between input and output, these need to be fed with avpkt->data=NULL,
- * avpkt->size=0 at the end to return the remaining frames.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- * before packets may be fed to the decoder.
- *
- * @param avctx the codec context
- * @param[out] picture The AVFrame in which the decoded video frame will be stored.
- *             Use av_frame_alloc() to get an AVFrame. The codec will
- *             allocate memory for the actual bitmap by calling the
- *             AVCodecContext.get_buffer2() callback.
- *             When AVCodecContext.refcounted_frames is set to 1, the frame is
- *             reference counted and the returned reference belongs to the
- *             caller. The caller must release the frame using av_frame_unref()
- *             when the frame is no longer needed. The caller may safely write
- *             to the frame if av_frame_is_writable() returns 1.
- *             When AVCodecContext.refcounted_frames is set to 0, the returned
- *             reference belongs to the decoder and is valid only until the
- *             next call to this function or until closing or flushing the
- *             decoder. The caller may not write to it.
- *
- * @param[in] avpkt The input AVPacket containing the input buffer.
- *            You can create such packet with av_init_packet() and by then setting
- *            data and size, some decoders might in addition need other fields like
- *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
- *            fields possible.
- * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
- * @return On error a negative value is returned, otherwise the number of bytes
- * used or zero if no frame could be decompressed.
- *
- * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
- *)
-function avcodec_decode_video2(avctx: PAVCodecContext; picture: PAVFrame;
-                       var got_picture_ptr: cint;
-                       avpkt: {const} PAVPacket): cint;
-  cdecl; external av__codec; deprecated;
-
-(*
- * Decode a subtitle message.
- * Return a negative value on error, otherwise return the number of bytes used.
- * If no subtitle could be decompressed, got_sub_ptr is zero.
- * Otherwise, the subtitle is stored in *sub.
- * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
- * simplicity, because the performance difference is expect to be negligible
- * and reusing a get_buffer written for video codecs would probably perform badly
- * due to a potentially very different allocation pattern.
- *
- * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
- * and output. This means that for some packets they will not immediately
- * produce decoded output and need to be flushed at the end of decoding to get
- * all the decoded data. Flushing is done by calling this function with packets
- * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
- * returning subtitles. It is safe to flush even those decoders that are not
- * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- * before packets may be fed to the decoder.
- *
- * @param avctx the codec context
- * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
- *                 must be freed with avsubtitle_free if *got_sub_ptr is set.
- * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
- * @param[in] avpkt The input AVPacket containing the input buffer.
- *)
-function avcodec_decode_subtitle2(avctx: PAVCodecContext; sub: PAVSubtitle;
-                          var got_sub_ptr: cint;
-                          avpkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Supply raw packet data as input to a decoder.
- *
- * Internally, this call will copy relevant AVCodecContext fields, which can
- * influence decoding per-packet, and apply them when the packet is actually
- * decoded. (For example AVCodecContext.skip_frame, which might direct the
- * decoder to drop the frame contained by the packet sent with this function.)
- *
- * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
- *          larger than the actual read bytes because some optimized bitstream
- *          readers read 32 or 64 bits at once and could read over the end.
- *
- * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
- *          on the same AVCodecContext. It will return unexpected results now
- *          or in future libavcodec versions.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- *       before packets may be fed to the decoder.
- *
- * @param avctx codec context
- * @param[in] avpkt The input AVPacket. Usually, this will be a single video
- *                  frame, or several complete audio frames.
- *                  Ownership of the packet remains with the caller, and the
- *                  decoder will not write to the packet. The decoder may create
- *                  a reference to the packet data (or copy it if the packet is
- *                  not reference-counted).
- *                  Unlike with older APIs, the packet is always fully consumed,
- *                  and if it contains multiple frames (e.g. some audio codecs),
- *                  will require you to call avcodec_receive_frame() multiple
- *                  times afterwards before you can send a new packet.
- *                  It can be NULL (or an AVPacket with data set to NULL and
- *                  size set to 0); in this case, it is considered a flush
- *                  packet, which signals the end of the stream. Sending the
- *                  first flush packet will return success. Subsequent ones are
- *                  unnecessary and will return AVERROR_EOF. If the decoder
- *                  still has frames buffered, it will return them after sending
- *                  a flush packet.
- *
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   input is not accepted in the current state - user
- *                         must read output with avcodec_receive_frame() (once
- *                         all output is read, the packet should be resent, and
- *                         the call will not fail with EAGAIN).
- *      AVERROR_EOF:       the decoder has been flushed, and no new packets can
- *                         be sent to it (also returned if more than 1 flush
- *                         packet is sent)
- *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
- *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
- *      other errors: legitimate decoding errors
- *)
-function avcodec_send_packet(avctx: PAVCodecContext; avpkt: {const} PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Return decoded output data from a decoder.
- *
- * @param avctx codec context
- * @param frame This will be set to a reference-counted video or audio
- *              frame (depending on the decoder type) allocated by the
- *              decoder. Note that the function will always call
- *              av_frame_unref(frame) before doing anything else.
- *
- * @return
- *      0:                 success, a frame was returned
- *      AVERROR(EAGAIN):   output is not available in this state - user must try
- *                         to send new input
- *      AVERROR_EOF:       the decoder has been fully flushed, and there will be
- *                         no more output frames
- *      AVERROR(EINVAL):   codec not opened, or it is an encoder
- *      other negative values: legitimate decoding errors
- *)
-function avcodec_receive_frame(avctx: PAVCodecContext; frame: PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
- * to retrieve buffered output packets.
- *
- * @param avctx     codec context
- * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
- *                  Ownership of the frame remains with the caller, and the
- *                  encoder will not write to the frame. The encoder may create
- *                  a reference to the frame data (or copy it if the frame is
- *                  not reference-counted).
- *                  It can be NULL, in which case it is considered a flush
- *                  packet.  This signals the end of the stream. If the encoder
- *                  still has packets buffered, it will return them after this
- *                  call. Once flushing mode has been entered, additional flush
- *                  packets are ignored, and sending frames will return
- *                  AVERROR_EOF.
- *
- *                  For audio:
- *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
- *                  can have any number of samples.
- *                  If it is not set, frame->nb_samples must be equal to
- *                  avctx->frame_size for all frames except the last.
- *                  The final frame may be smaller than avctx->frame_size.
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   input is not accepted in the current state - user
- *                         must read output with avcodec_receive_packet() (once
- *                         all output is read, the packet should be resent, and
- *                         the call will not fail with EAGAIN).
- *      AVERROR_EOF:       the encoder has been flushed, and no new frames can
- *                         be sent to it
- *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
- *                         decoder, or requires flush
- *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
- *      other errors: legitimate decoding errors
- *)
-function avcodec_send_frame(avctx: PAVCodecContext; frame: {const} PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Read encoded data from the encoder.
- *
- * @param avctx codec context
- * @param avpkt This will be set to a reference-counted packet allocated by the
- *              encoder. Note that the function will always call
- *              av_frame_unref(frame) before doing anything else.
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   output is not available in the current state - user
- *                         must try to send input
- *      AVERROR_EOF:       the encoder has been fully flushed, and there will be
- *                         no more output packets
- *      AVERROR(EINVAL):   codec not opened, or it is an encoder
- *      other errors: legitimate decoding errors
- *)
-function avcodec_receive_packet(avctx: PAVCodecContext; avpkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Create and return a AVHWFramesContext with values adequate for hardware
- * decoding. This is meant to get called from the get_format callback, and is
- * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
- * This API is for decoding with certain hardware acceleration modes/APIs only.
- *
- * The returned AVHWFramesContext is not initialized. The caller must do this
- * with av_hwframe_ctx_init().
- *
- * Calling this function is not a requirement, but makes it simpler to avoid
- * codec or hardware API specific details when manually allocating frames.
- *
- * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
- * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
- * it unnecessary to call this function or having to care about
- * AVHWFramesContext initialization at all.
- *
- * There are a number of requirements for calling this function:
- *
- * - It must be called from get_format with the same avctx parameter that was
- *   passed to get_format. Calling it outside of get_format is not allowed, and
- *   can trigger undefined behavior.
- * - The function is not always supported (see description of return values).
- *   Even if this function returns successfully, hwaccel initialization could
- *   fail later. (The degree to which implementations check whether the stream
- *   is actually supported varies. Some do this check only after the user's
- *   get_format callback returns.)
- * - The hw_pix_fmt must be one of the choices suggested by get_format. If the
- *   user decides to use a AVHWFramesContext prepared with this API function,
- *   the user must return the same hw_pix_fmt from get_format.
- * - The device_ref passed to this function must support the given hw_pix_fmt.
- * - After calling this API function, it is the user's responsibility to
- *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
- *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
- *   before returning from get_format (this is implied by the normal
- *   AVCodecContext.hw_frames_ctx API rules).
- * - The AVHWFramesContext parameters may change every time time get_format is
- *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
- *   you are inherently required to go through this process again on every
- *   get_format call.
- * - It is perfectly possible to call this function without actually using
- *   the resulting AVHWFramesContext. One use-case might be trying to reuse a
- *   previously initialized AVHWFramesContext, and calling this API function
- *   only to test whether the required frame parameters have changed.
- * - Fields that use dynamically allocated values of any kind must not be set
- *   by the user unless setting them is explicitly allowed by the documentation.
- *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
- *   the new free callback must call the potentially set previous free callback.
- *   This API call may set any dynamically allocated fields, including the free
- *   callback.
- *
- * The function will set at least the following fields on AVHWFramesContext
- * (potentially more, depending on hwaccel API):
- *
- * - All fields set by av_hwframe_ctx_alloc().
- * - Set the format field to hw_pix_fmt.
- * - Set the sw_format field to the most suited and most versatile format. (An
- *   implication is that this will prefer generic formats over opaque formats
- *   with arbitrary restrictions, if possible.)
- * - Set the width/height fields to the coded frame size, rounded up to the
- *   API-specific minimum alignment.
- * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
- *   field to the number of maximum reference surfaces possible with the codec,
- *   plus 1 surface for the user to work (meaning the user can safely reference
- *   at most 1 decoded surface at a time), plus additional buffering introduced
- *   by frame threading. If the hwaccel does not require pre-allocation, the
- *   field is left to 0, and the decoder will allocate new surfaces on demand
- *   during decoding.
- * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
- *   hardware API.
- *
- * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
- * with basic frame parameters set.
- *
- * The function is stateless, and does not change the AVCodecContext or the
- * device_ref AVHWDeviceContext.
- *
- * @param avctx The context which is currently calling get_format, and which
- *              implicitly contains all state needed for filling the returned
- *              AVHWFramesContext properly.
- * @param device_ref A reference to the AVHWDeviceContext describing the device
- *                   which will be used by the hardware decoder.
- * @param hw_pix_fmt The hwaccel format you are going to return from get_format.
- * @param out_frames_ref On success, set to a reference to an _uninitialized_
- *                       AVHWFramesContext, created from the given device_ref.
- *                       Fields will be set to values required for decoding.
- *                       Not changed if an error is returned.
- * @return zero on success, a negative value on error. The following error codes
- *         have special semantics:
- *      AVERROR(ENOENT): the decoder does not support this functionality. Setup
- *                       is always manual, or it is a decoder which does not
- *                       support setting AVCodecContext.hw_frames_ctx at all,
- *                       or it is a software format.
- *      AVERROR(EINVAL): it is known that hardware decoding is not supported for
- *                       this configuration, or the device_ref is not supported
- *                       for the hwaccel referenced by hw_pix_fmt.
- *)
-function avcodec_get_hw_frames_parameters(avctx: PAVCodecContext;
-                                     device_ref: PAVBufferRef;
-                                     hw_pix_fmt: TAVPixelFormat;
-                                     out_frames_ref: PPAVBufferRef): cint;
-cdecl; external av__codec;
-
-
-(**
- * @defgroup lavc_parsing Frame parsing
- * @
- *)
-
-type
-  TAVPictureStructure = (
-    AV_PICTURE_STRUCTURE_UNKNOWN,      //< unknown
-    AV_PICTURE_STRUCTURE_TOP_FIELD,    //< coded as top field
-    AV_PICTURE_STRUCTURE_BOTTOM_FIELD, //< coded as bottom field
-    AV_PICTURE_STRUCTURE_FRAME         //< coded as frame
-  );
-
-const
-  AV_PARSER_PTS_NB      = 4;
-  PARSER_FLAG_COMPLETE_FRAMES = $0001;
-  PARSER_FLAG_ONCE            = $0002;
-/// Set if the parser has a valid file offset
-  PARSER_FLAG_FETCHED_OFFSET  = $0004;
-  PARSER_FLAG_USE_CODEC_TS    = $1000;
-
-type
-  (* frame parsing *)
-  PAVCodecParserContext = ^TAVCodecParserContext;
-  PAVCodecParser = ^TAVCodecParser;
-
-  TAVCodecParserContext = record
-    priv_data: pointer;
-    parser: PAVCodecParser;
-    frame_offset: cint64; (* offset of the current frame *)
-    cur_offset: cint64; (* current offset (incremented by each av_parser_parse()) *)
-    next_frame_offset: cint64; (* offset of the next frame *)
-    (* video info *)
-    pict_type: cint; (* XXX: put it back in AVCodecContext *)
-    (**
-     * This field is used for proper frame duration computation in lavf.
-     * It signals, how much longer the frame duration of the current frame
-     * is compared to normal frame duration.
-     *
-     * frame_duration = (1 + repeat_pict) * time_base
-     *
-     * It is used by codecs like H.264 to display telecined material.
-     *)
-    repeat_pict: cint; (* XXX: put it back in AVCodecContext *)
-    pts: cint64;     (* pts of the current frame *)
-    dts: cint64;     (* dts of the current frame *)
-
-    (* private data *)
-    last_pts: cint64;
-    last_dts: cint64;
-    fetch_timestamp: cint;
-
-    cur_frame_start_index: cint;
-    cur_frame_offset: array [0..AV_PARSER_PTS_NB - 1] of cint64;
-    cur_frame_pts: array [0..AV_PARSER_PTS_NB - 1] of cint64;
-    cur_frame_dts: array [0..AV_PARSER_PTS_NB - 1] of cint64;
-
-    flags: cint;
-
-    offset: cint64;      ///< byte offset from starting packet start
-    cur_frame_end: array [0..AV_PARSER_PTS_NB - 1] of cint64;
-
-    (**
-     * Set by parser to 1 for key frames and 0 for non-key frames.
-     * It is initialized to -1, so if the parser doesn't set this flag,
-     * old-style fallback using FF_I_TYPE picture type as key frames
-     * will be used.
-     *)
-    key_frame: cint;
-
-{$IFDEF FF_API_CONVERGENCE_DURATION}
-    (**
-     * @deprecated unused
-     *)
-    convergence_duration: cint64; {deprecated}
-{$ENDIF}
-
-    // Timestamp generation support:
-    (**
-     * Synchronization point for start of timestamp generation.
-     *
-     * Set to >0 for sync point, 0 for no sync point and <0 for undefined
-     * (default).
-     *
-     * For example, this corresponds to presence of H.264 buffering period
-     * SEI message.
-     *)
-    dts_sync_point: cint;
-
-    (**
-     * Offset of the current timestamp against last timestamp sync point in
-     * units of AVCodecContext.time_base.
-     *
-     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
-     * contain a valid timestamp offset.
-     *
-     * Note that the timestamp of sync point has usually a nonzero
-     * dts_ref_dts_delta, which refers to the previous sync point. Offset of
-     * the next frame after timestamp sync point will be usually 1.
-     *
-     * For example, this corresponds to H.264 cpb_removal_delay.
-     *)
-    dts_ref_dts_delta: cint;
-
-    (**
-     * Presentation delay of current frame in units of AVCodecContext.time_base.
-     *
-     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
-     * contain valid non-negative timestamp delta (presentation time of a frame
-     * must not lie in the past).
-     *
-     * This delay represents the difference between decoding and presentation
-     * time of the frame.
-     *
-     * For example, this corresponds to H.264 dpb_output_delay.
-     *)
-    pts_dts_delta: cint;
-
-    (**
-     * Position of the packet in file.
-     *
-     * Analogous to cur_frame_pts/dts
-     *)
-    cur_frame_pos: array [0..AV_PARSER_PTS_NB - 1] of cint64;
-
-    (**
-     * Byte position of currently parsed frame in stream.
-     *)
-    pos: cint64;
-
-    (**
-     * Previous frame byte position.
-     *)
-    last_pos: cint64;
-
-    (**
-     * Duration of the current frame.
-     * For audio, this is in units of 1 / AVCodecContext.sample_rate.
-     * For all other types, this is in units of AVCodecContext.time_base.
-     *)
-    duration: cint;
-
-    field_order: TAVFieldOrder;
-
-    (**
-     * Indicate whether a picture is coded as a frame, top field or bottom field.
-     *
-     * For example, H.264 field_pic_flag equal to 0 corresponds to
-     * AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
-     * equal to 1 and bottom_field_flag equal to 0 corresponds to
-     * AV_PICTURE_STRUCTURE_TOP_FIELD.
-     *)
-    picture_structure: TAVPictureStructure;
-
-    (**
-     * Picture number incremented in presentation or output order.
-     * This field may be reinitialized at the first picture of a new sequence.
-     *
-     * For example, this corresponds to H.264 PicOrderCnt.
-     *)
-    output_picture_number: cint;
-
-    (**
-     * Dimensions of the decoded video intended for presentation.
-     *)
-    width: cint;
-    height: cint;
-
-    (**
-     * Dimensions of the coded video.
-     *)
-    coded_width: cint;
-    coded_height: cint;
-
-    (**
-     * The format of the coded data, corresponds to enum AVPixelFormat for video
-     * and for enum AVSampleFormat for audio.
-     *
-     * Note that a decoder can have considerable freedom in how exactly it
-     * decodes the data, so the format reported here might be different from the
-     * one returned by a decoder.
-     *)
-    format: cint;
-  end; {AVCodecParserContext}
-
-  TAVCodecParser = record
-    codec_ids: array [0..4] of cint; (* several codec IDs are permitted *)
-    priv_data_size: cint;
-    parser_init: function(s: PAVCodecParserContext): cint; cdecl;
-    (* This callback never returns an error, a negative value means that
-     * the frame start was in a previous packet. *)
-    parser_parse: function(s: PAVCodecParserContext;
-                           avctx: PAVCodecContext;
-                           poutbuf: {const} PPointer; poutbuf_size: PCint;
-                           buf: {const} PByteArray; buf_size: cint): cint; cdecl;
-    parser_close: procedure(s: PAVCodecParserContext); cdecl;
-    split: function(avctx: PAVCodecContext; buf: {const} PByteArray;
-                    buf_size: cint): cint; cdecl;
-    next: PAVCodecParser;
-  end; {AVCodecParser}
-
-(**
- * Iterate over all registered codec parsers.
- *
- * @param opaque a pointer where libavcodec will store the iteration state. Must
- *               point to NULL to start the iteration.
- *
- * @return the next registered codec parser or NULL when the iteration is
- *         finished
- *)
-function av_parser_iterate(opaque: pointer): PAVCodecParser;
-  cdecl; external av__codec; {const}
-
-function av_parser_next(c: {const} PAVCodecParser): PAVCodecParser;
-  cdecl; external av__codec; deprecated;
-
-procedure av_register_codec_parser(parser: PAVCodecParser);
-  cdecl; external av__codec; deprecated;
-
-function av_parser_init(codec_id: cint): PAVCodecParserContext;
-  cdecl; external av__codec;
-
-(**
- * Parse a packet.
- *
- * @param s             parser context.
- * @param avctx         codec context.
- * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
- * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
- * @param buf           input buffer.
- * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
-                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
-                        To signal EOF, this should be 0 (so that the last frame
-                        can be output).
- * @param pts           input presentation timestamp.
- * @param dts           input decoding timestamp.
- * @param pos           input byte position in stream.
- * @return the number of bytes of the input bitstream used.
- *
- * Example:
- * @code
- *   while (in_len) do
- *   begin
- *     len := av_parser_parse2(myparser, AVCodecContext, data, size,
- *                                       in_data, in_len,
- *                                       pts, dts, pos);
- *      in_data := in_data + len;
- *      in_len  := in_len  - len;
- *
- *      if (size) then
- *        decode_frame(data, size);
- *   end;
- * @endcode
- *)
-function av_parser_parse2(s:    PAVCodecParserContext;
-                  avctx:        PAVCodecContext;
-                  poutbuf:      PPointer;
-                  poutbuf_size: PCint;
-                  buf: {const}  PByteArray;
-                  buf_size:     cint;
-                  pts:          cint64;
-                  dts:          cint64;
-                  pos:          cint64): cint;
-   cdecl; external av__codec;
-
-(**
- * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
- * @deprecated use AVBitStreamFilter
- *)
-function av_parser_change(s: PAVCodecParserContext;
-                   avctx: PAVCodecContext;
-                   poutbuf: PPointer; poutbuf_size: PCint;
-                   buf: {const} PByteArray; buf_size: cint; keyframe: cint): cint;
-  cdecl; external av__codec;
-
-procedure av_parser_close(s: PAVCodecParserContext);
-  cdecl; external av__codec;
-
-(**
- * @}
- * @}
- *)
-
-(**
- * @addtogroup lavc_encoding
- * @{
- *)
-
-(**
- * Find a registered encoder with a matching codec ID.
- *
- * @param id AVCodecID of the requested encoder
- * @return An encoder if one was found, NULL otherwise.
- *)
-function avcodec_find_encoder(id: TAVCodecID): PAVCodec;
-  cdecl; external av__codec;
-
-(**
- * Find a registered encoder with the specified name.
- *
- * @param name name of the requested encoder
- * @return An encoder if one was found, NULL otherwise.
- *)
-function avcodec_find_encoder_by_name(name: PAnsiChar): PAVCodec;
-  cdecl; external av__codec;
-
-(**
- * Encode a frame of audio.
- *
- * Takes input samples from frame and writes the next output packet, if
- * available, to avpkt. The output packet does not necessarily contain data for
- * the most recent frame, as encoders can delay, split, and combine input frames
- * internally as needed.
- *
- * @param avctx     codec context
- * @param avpkt     output AVPacket.
- *                  The user can supply an output buffer by setting
- *                  avpkt->data and avpkt->size prior to calling the
- *                  function, but if the size of the user-provided data is not
- *                  large enough, encoding will fail. If avpkt->data and
- *                  avpkt->size are set, avpkt->destruct must also be set. All
- *                  other AVPacket fields will be reset by the encoder using
- *                  av_init_packet(). If avpkt->data is NULL, the encoder will
- *                  allocate it. The encoder will set avpkt->size to the size
- *                  of the output packet.
- *
- *                  If this function fails or produces no output, avpkt will be
- *                  freed using av_packet_unref().
- * @param[in] frame AVFrame containing the raw audio data to be encoded.
- *                  May be NULL when flushing an encoder that has the
- *                  AV_CODEC_CAP_DELAY capability set.
- *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
- *                  can have any number of samples.
- *                  If it is not set, frame->nb_samples must be equal to
- *                  avctx->frame_size for all frames except the last.
- *                  The final frame may be smaller than avctx->frame_size.
- * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
- *                            output packet is non-empty, and to 0 if it is
- *                            empty. If the function returns an error, the
- *                            packet can be assumed to be invalid, and the
- *                            value of got_packet_ptr is undefined and should
- *                            not be used.
- * @return          0 on success, negative error code on failure
- *
- * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
- *)
-function avcodec_encode_audio2(avctx: PAVCodecContext; avpkt: PAVPacket;
-                          frame: {const} PAVFrame; got_packet_ptr: Pcint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
- * Encode a frame of video.
- *
- * Takes input raw video data from frame and writes the next output packet, if
- * available, to avpkt. The output packet does not necessarily contain data for
- * the most recent frame, as encoders can delay and reorder input frames
- * internally as needed.
- *
- * @param avctx     codec context
- * @param avpkt     output AVPacket.
- *                  The user can supply an output buffer by setting
- *                  avpkt->data and avpkt->size prior to calling the
- *                  function, but if the size of the user-provided data is not
- *                  large enough, encoding will fail. All other AVPacket fields
- *                  will be reset by the encoder using av_init_packet(). If
- *                  avpkt->data is NULL, the encoder will allocate it.
- *                  The encoder will set avpkt->size to the size of the
- *                  output packet. The returned data (if any) belongs to the
- *                  caller, he is responsible for freeing it.
- *
- *                  If this function fails or produces no output, avpkt will be
- *                  freed using av_packet_unref().
- * @param[in] frame AVFrame containing the raw video data to be encoded.
- *                  May be NULL when flushing an encoder that has the
- *                  AV_CODEC_CAP_DELAY capability set.
- * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
- *                            output packet is non-empty, and to 0 if it is
- *                            empty. If the function returns an error, the
- *                            packet can be assumed to be invalid, and the
- *                            value of got_packet_ptr is undefined and should
- *                            not be used.
- * @return          0 on success, negative error code on failure
- *
- * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
- *)
-function avcodec_encode_video2(avctx: PAVCodecContext; avpkt: PAVPacket;
-                      frame: {const} PAVFrame; got_packet_ptr: Pcint): cint;
-  cdecl; external av__codec; deprecated;
-
-function avcodec_encode_subtitle(avctx: PAVCodecContext; buf: PByteArray;
-                      buf_size: cint; sub: {const} PAVSubtitle): cint;
-  cdecl; external av__codec;
-
-(**
- * @}
- *)
-
-{$IFDEF FF_API_AVPICTURE}
-(**
- * @addtogroup lavc_picture
- * @{
- *)
-
-(**
-  * @deprecated unused
-  *)
-function avpicture_alloc (picture: PAVPicture; pix_fmt: TAVPixelFormat;
-                          width: cint; height: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated unused
-  *)
-procedure avpicture_free (picture: PAVPicture);
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated use av_image_fill_arrays() instead.
-  *)
-function avpicture_fill (picture: PAVPicture; ptr: pcuint8;
-                 pix_fmt: TAVPixelFormat; width: cint; height: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated use av_image_copy_to_buffer() instead.
-  *)
-function avpicture_layout (src: {const} PAVPicture; pix_fmt: TAVPixelFormat;
-                   width: cint; height: cint;
-                   dest: PByteArray; dest_size: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated use av_image_get_buffer_size() instead.
-  *)
-function avpicture_get_size (pix_fmt: TAVPixelFormat; width: cint; height: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated av_image_copy() instead.
-  *)
-procedure av_picture_copy(dst: PAVPicture; src: {const} PAVPicture;
-              pix_fmt: TAVPixelFormat; width: cint; height: cint);
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated unused
-  *)
-function av_picture_crop(dst: PAVPicture; src: {const} PAVPicture;
-              pix_fmt: TAVPixelFormat; top_band: cint; left_band: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
-  * @deprecated unused
-  *)
-function av_picture_pad(dst: PAVPicture; src: {const} PAVPicture;
-            height: cint; width: cint; pix_fmt: TAVPixelFormat;
-            padtop: cint;  padbottom: cint; padleft: cint;
-            padright: cint; color: PCint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
- * @}
- *)
-{$ENDIF}
-
-(**
- * @defgroup lavc_misc Utility functions
- * @ingroup libavc
- *
- * Miscellaneous utility functions related to both encoding and decoding
- * (or neither).
- * @
- *)
-
-(**
- * @defgroup lavc_misc_pixfmt Pixel formats
- *
- * Functions for working with pixel formats.
- * @
- *)
-
-{$IFDEF FF_API_GETCHROMA}
-(**
- * @deprecated Use av_pix_fmt_get_chroma_sub_sample
- *)
-
-procedure avcodec_get_chroma_sub_sample (pix_fmt: TAVPixelFormat; var h_shift: cint; var v_shift: cint);
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Return a value representing the fourCC code associated to the
- * pixel format pix_fmt, or 0 if no associated fourCC code can be
- * found.
- *)
-function avcodec_pix_fmt_to_codec_tag(pix_fmt: TAVPixelFormat): cuint;
-  cdecl; external av__codec;
-
-(**
- * @deprecated see av_get_pix_fmt_loss()
- *)
-function avcodec_get_pix_fmt_loss (dst_pix_fmt: TAVPixelFormat; src_pix_fmt: TAVPixelFormat;
-                           has_alpha: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Find the best pixel format to convert to given a certain source pixel
- * format.  When converting from one pixel format to another, information loss
- * may occur.  For example, when converting from RGB24 to GRAY, the color
- * information will be lost. Similarly, other losses occur when converting from
- * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
- * the given pixel formats should be used to suffer the least amount of loss.
- * The pixel formats from which it chooses one, are determined by the
- * pix_fmt_list parameter.
- *
- *
- * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
- * @param[in] src_pix_fmt source pixel format
- * @param[in] has_alpha Whether the source pixel format alpha channel is used.
- * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
- * @return The best pixel format to convert to or -1 if none was found.
- *)
-function avcodec_find_best_pix_fmt_of_list(pix_fmt_list: PAVPixelFormat;
-                                           src_pix_fmt: TAVPixelFormat;
-                                           has_alpha: cint; loss_ptr: Pcint): TAVPixelFormat;
-  cdecl; external av__codec;
-
-(**
- * @deprecated see av_find_best_pix_fmt_of_2()
- *)
-function avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1: TAVPixelFormat; dst_pix_fmt2: TAVPixelFormat;
-                                        src_pix_fmt: TAVPixelFormat; has_alpha: cint; loss_ptr: Pcint): TAVPixelFormat;
-  cdecl; external av__codec;
-
-function avcodec_find_best_pix_fmt2(dst_pix_fmt1: TAVPixelFormat; dst_pix_fmt2: TAVPixelFormat;
-                      src_pix_fmt: TAVPixelFormat; has_alpha: cint; loss_ptr: Pcint): TAVPixelFormat;
-  cdecl; external av__codec; deprecated;
-
-function avcodec_default_get_format(s: PAVCodecContext; fmt: {const} PAVPixelFormat): TAVPixelFormat;
-  cdecl; external av__codec;
-
-(**
- * @}
- *)
-
-{$IFDEF FF_API_TAG_STRING}
-(* Put a string representing the codec tag codec_tag in buf.
- *
- * @param buf       buffer to place codec tag in
- * @param buf_size size in bytes of buf
- * @param codec_tag codec tag to assign
- * @return the length of the string that would have been generated if
- * enough space had been available, excluding the trailing null
- *
- * @deprecated see av_fourcc_make_string() and av_fourcc2str().
- *)
-function av_get_codec_tag_string(buf: PAnsiChar; buf_size: size_t; codec_tag: cuint): size_t;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-procedure avcodec_string(buf: PAnsiChar; buf_size: cint; enc: PAVCodecContext; encode: cint);
-  cdecl; external av__codec;
-
-(**
- * Return a name for the specified profile, if available.
- *
- * @param codec the codec that is searched for the given profile
- * @param profile the profile value for which a name is requested
- * @return A name for the profile if found, NULL otherwise.
- *)
-function av_get_profile_name(codec: {const} PAVCodec; profile: cint): {const} PAnsiChar;
-  cdecl; external av__codec;
-
-(**
- * Return a name for the specified profile, if available.
- *
- * @param codec_id the ID of the codec to which the requested profile belongs
- * @param profile the profile value for which a name is requested
- * @return A name for the profile if found, NULL otherwise.
- *
- * @note unlike av_get_profile_name(), which searches a list of profiles
- *       supported by a specific decoder or encoder implementation, this
- *       function searches the list of profiles from the AVCodecDescriptor
- *)
-function avcodec_profile_name(codec_id: TAVCodecID; profile: cint): {const} PChar;
-  cdecl; external av__codec;
-
-function avcodec_default_execute(s: PAVCodecContext; func: TExecuteFunc; arg: Pointer; var ret: cint; count: cint; size: cint): cint;
-  cdecl; external av__codec;
-
-function avcodec_default_execute2(s: PAVCodecContext; func: TExecuteFunc; arg: Pointer; var ret: cint; count: cint): cint;
-  cdecl; external av__codec;
-//FIXME func typedef
-
-(**
- * Fill AVFrame audio data and linesize pointers.
- *
- * The buffer buf must be a preallocated buffer with a size big enough
- * to contain the specified samples amount. The filled AVFrame data
- * pointers will point to this buffer.
- *
- * AVFrame extended_data channel pointers are allocated if necessary for
- * planar audio.
- *
- * @param frame       the AVFrame
- *                    frame->nb_samples must be set prior to calling the
- *                    function. This function fills in frame->data,
- *                    frame->extended_data, frame->linesize[0].
- * @param nb_channels channel count
- * @param sample_fmt  sample format
- * @param buf         buffer to use for frame data
- * @param buf_size    size of buffer
- * @param align       plane size sample alignment
- * @return            >=0 on success, negative error code on failure
- * @todo return the size in bytes required to store the samples in
- * case of success, at the next libavutil bump
- *)
-function avcodec_fill_audio_frame(frame: PAVFrame; nb_channels: cint;
-                             sample_fmt: TAVSampleFormat; buf: {const} PByte;
-                             buf_size: cint; align: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Flush buffers, should be called when seeking or when switching to a different stream.
- *)
-procedure avcodec_flush_buffers(avctx: PAVCodecContext);
-  cdecl; external av__codec;
-
-(**
- * Return codec bits per sample.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- *)
-function av_get_bits_per_sample(codec_id: TAVCodecID): cint;
-  cdecl; external av__codec;
-
-(**
- * Return the PCM codec associated with a sample format.
- * @param be  endianness, 0 for little, 1 for big,
- *            -1 (or anything else) for native
- * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
- *)
-function av_get_pcm_codec(fmt: TAVSampleFormat; be: cint): TAVCodecID;
-  cdecl; external av__codec;
-
-(**
- * Return codec bits per sample.
- * Only return non-zero if the bits per sample is exactly correct, not an
- * approximation.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- *)
-function av_get_exact_bits_per_sample(codec_id: TAVCodecID): cint;
-  cdecl; external av__codec;
-
-(**
- * Return audio frame duration.
- *
- * @param avctx        codec context
- * @param frame_bytes  size of the frame, or 0 if unknown
- * @return             frame duration, in samples, if known. 0 if not able to
- *                     determine.
- *)
-function av_get_audio_frame_duration(avctx: PAVCodecContext; frame_bytes: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * This function is the same as av_get_audio_frame_duration(), except it works
- * with AVCodecParameters instead of an AVCodecContext.
- *)
-function av_get_audio_frame_duration2(par: PAVCodecParameters; frame_bytes: cint): cint;
-  cdecl; external av__codec;
-
-type
-{$IFDEF FF_API_OLD_BSF}
-  PAVBitStreamFilterContext = ^TAVBitStreamFilterContext;
-  PAVBitStreamFilter = ^TAVBitStreamFilter;
-
-  TAVBitStreamFilterContext = record
-    priv_data: pointer;
-    filter: {const} PAVBitStreamFilter;
-    parser: PAVCodecParserContext;
-    next: PAVBitStreamFilterContext;
-    (**
-     * Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
-     * Not for access by library users.
-     *)
-    args: PChar;
-  end;
-{$ENDIF}
-
-  PAVBSFInternal = ^TAVBSFInternal;
-  TAVBSFInternal = record
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-  (**
-   * The bitstream filter state.
-   *
-   * This struct must be allocated with av_bsf_alloc() and freed with
-   * av_bsf_free().
-   *
-   * The fields in the struct will only be changed (by the caller or by the
-   * filter) as described in their documentation, and are to be considered
-   * immutable otherwise.
-   *)
-  PPAVBSFContext = ^PAVBSFContext;
-  PAVBSFContext  = ^TAVBSFContext;
-  TAVBSFContext  = record
-    (**
-     * A class for logging and AVOptions
-     *)
-    av_class: {const} PAVClass;
-
-    (**
-     * The bitstream filter this context is an instance of.
-     *)
-    filter: {const} PAVBitStreamFilter;
-
-    (**
-     * Opaque libavcodec internal data. Must not be touched by the caller in any
-     * way.
-     *)
-    internal: PAVBSFInternal;
-
-    (**
-     * Opaque filter-specific private data. If filter->priv_class is non-NULL,
-     * this is an AVOptions-enabled struct.
-     *)
-    priv_data: pointer;
-
-    (**
-     * Parameters of the input stream. This field is allocated in
-     * av_bsf_alloc(), it needs to be filled by the caller before
-     * av_bsf_init().
-     *)
-    par_in: PAVCodecParameters;
-
-    (**
-     * Parameters of the output stream. This field is allocated in
-     * av_bsf_alloc(), it is set by the filter in av_bsf_init().
-     *)
-    par_out: PAVCodecParameters;
-
-    (**
-     * The timebase used for the timestamps of the input packets. Set by the
-     * caller before av_bsf_init().
-     *)
-    time_base_in: TAVRational;
-
-    (**
-     * The timebase used for the timestamps of the output packets. Set by the
-     * filter in av_bsf_init().
-     *)
-    time_base_out: TAVRational;
-  end; {TAVBSFContext}
-
-  TAVBitStreamFilter = record
-    name: PAnsiChar;
-
-    (**
-     * A list of codec ids supported by the filter, terminated by
-     * AV_CODEC_ID_NONE.
-     * May be NULL, in that case the bitstream filter works with any codec id.
-     *)
-    codec_ids: PAVCodecID;
-
-    (**
-     * A class for the private data, used to declare bitstream filter private
-     * AVOptions. This field is NULL for bitstream filters that do not declare
-     * any options.
-     *
-     * If this field is non-NULL, the first member of the filter private data
-     * must be a pointer to AVClass, which will be set by libavcodec generic
-     * code to this class.
-     *)
-    priv_class: PAVClass;
-
-    (*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-
-    priv_data_size: cint;
-    init: function(ctx: PAVBSFContext): cint; cdecl;
-    filter: function(ctx: PAVBSFContext; pkt: PAVPacket): cint; cdecl;
-    close: procedure(ctx: PAVBSFContext); cdecl;
-  end;
-
-  PPAVBSFList = ^PAVBSFList;
-  PAVBSFList  = ^TAVBSFList;
-  TAVBSFList  = record
-  end;
-
-{$IFDEF FF_API_OLD_BSF}
-(**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use the new bitstream filtering API (using AVBSFContext).
- *)
-procedure av_register_bitstream_filter(bsf: PAVBitStreamFilter);
-  cdecl; external av__codec; deprecated;
-
-(**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()
- * from the new bitstream filtering API (using AVBSFContext).
- *)
-function av_bitstream_filter_init(name: {const} PAnsiChar): PAVBitStreamFilterContext;
-  cdecl; external av__codec; deprecated;
-
-(**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the
- * new bitstream filtering API (using AVBSFContext).
- *)
-function av_bitstream_filter_filter(bsfc: PAVBitStreamFilterContext;
-                               avctx: PAVCodecContext; args: {const} PAnsiChar;
-                               poutbuf: PPointer; poutbuf_size: PCint;
-                               buf: {const} PByte; buf_size: cint; keyframe: cint): cint;
-  cdecl; external av__codec; deprecated;
-
-(**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_free() from the new bitstream filtering API (using
- * AVBSFContext).
- *)
-procedure av_bitstream_filter_close(bsf: PAVBitStreamFilterContext);
-  cdecl; external av__codec; deprecated;
-
-(**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using
- * AVBSFContext).
- *)
-function av_bitstream_filter_next(f: {const} PAVBitStreamFilter): PAVBitStreamFilter;
-  cdecl; external av__codec; deprecated; {const}
-{$ENDIF}
-
-(**
- * @return a bitstream filter with the specified name or NULL if no such
- *         bitstream filter exists.
- *)
-function av_bsf_get_by_name(name: {const} PAnsiChar): {const} PAVBitStreamFilter;
-  cdecl; external av__codec;
-
-(**
- * Iterate over all registered bitstream filters.
- *
- * @param opaque a pointer where libavcodec will store the iteration state. Must
- *               point to NULL to start the iteration.
- *
- * @return the next registered bitstream filter or NULL when the iteration is
- *         finished
- *)
-function av_bsf_iterate(opaque: pointer): PAVBitStreamFilter;
-  cdecl; external av__codec; {const}
-{$IFDEF FF_API_NEXT}
-function av_bsf_next(opaque: pointer): {const} PAVBitStreamFilter;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Allocate a context for a given bitstream filter. The caller must fill in the
- * context parameters as described in the documentation and then call
- * av_bsf_init() before sending any data to the filter.
- *
- * @param filter the filter for which to allocate an instance.
- * @param ctx a pointer into which the pointer to the newly-allocated context
- *            will be written. It must be freed with av_bsf_free() after the
- *            filtering is done.
- *
- * @return 0 on success, a negative AVERROR code on failure
- *)
-function av_bsf_alloc(filter: {const} PAVBitStreamFilter; ctx: PPAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Prepare the filter for use, after all the parameters and options have been
- * set.
- *)
-function av_bsf_init(ctx: PAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Submit a packet for filtering.
- *
- * After sending each packet, the filter must be completely drained by calling
- * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
- * AVERROR_EOF.
- *
- * @param pkt the packet to filter. The bitstream filter will take ownership of
- * the packet and reset the contents of pkt. pkt is not touched if an error occurs.
- * This parameter may be NULL, which signals the end of the stream (i.e. no more
- * packets will be sent). That will cause the filter to output any packets it
- * may have buffered internally.
- *
- * @return 0 on success, a negative AVERROR on error.
- *)
-function av_bsf_send_packet(ctx: PAVBSFContext; pkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Retrieve a filtered packet.
- *
- * @param[out] pkt this struct will be filled with the contents of the filtered
- *                 packet. It is owned by the caller and must be freed using
- *                 av_packet_unref() when it is no longer needed.
- *                 This parameter should be "clean" (i.e. freshly allocated
- *                 with av_packet_alloc() or unreffed with av_packet_unref())
- *                 when this function is called. If this function returns
- *                 successfully, the contents of pkt will be completely
- *                 overwritten by the returned data. On failure, pkt is not
- *                 touched.
- *
- * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
- * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
- * will be no further output from the filter. Another negative AVERROR value if
- * an error occurs.
- *
- * @note one input packet may result in several output packets, so after sending
- * a packet with av_bsf_send_packet(), this function needs to be called
- * repeatedly until it stops returning 0. It is also possible for a filter to
- * output fewer packets than were sent to it, so this function may return
- * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
- *)
-function av_bsf_receive_packet(ctx: PAVBSFContext; pkt: PAVPacket): cint;
-  cdecl; external av__codec;
-
-(**
- * Free a bitstream filter context and everything associated with it; write NULL
- * into the supplied pointer.
- *)
-procedure av_bsf_free(ctx: PPAVBSFContext);
-  cdecl; external av__codec;
-
-(**
- * Get the AVClass for AVBSFContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function av_bsf_get_class(): {const} PAVClass;
-  cdecl; external av__codec;
-
-(**
- * Allocate empty list of bitstream filters.
- * The list must be later freed by av_bsf_list_free()
- * or finalized by av_bsf_list_finalize().
- *
- * @return Pointer to @ref AVBSFList on success, NULL in case of failure
- *)
-function av_bsf_list_alloc(): PAVBSFList;
-  cdecl; external av__codec;
-
-(**
- * Free list of bitstream filters.
- *
- * @param lst Pointer to pointer returned by av_bsf_list_alloc()
- *)
-procedure av_bsf_list_free(lst: PPAVBSFList);
-  cdecl; external av__codec;
-
-(**
- * Append bitstream filter to the list of bitstream filters.
- *
- * @param lst List to append to
- * @param bsf Filter context to be appended
- *
- * @return >=0 on success, negative AVERROR in case of failure
- *)
-function av_bsf_list_append(lst: PAVBSFList; bsf: PAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Construct new bitstream filter context given it's name and options
- * and append it to the list of bitstream filters.
- *
- * @param lst      List to append to
- * @param bsf_name Name of the bitstream filter
- * @param options  Options for the bitstream filter, can be set to NULL
- *
- * @return >=0 on success, negative AVERROR in case of failure
- *)
-function av_bsf_list_append2(lst: PAVBSFList; bsf_name: {const} Pcchar; options: PPAVDictionary): cint;
-  cdecl; external av__codec;
-
-(**
- * Finalize list of bitstream filters.
- *
- * This function will transform @ref AVBSFList to single @ref AVBSFContext,
- * so the whole chain of bitstream filters can be treated as single filter
- * freshly allocated by av_bsf_alloc().
- * If the call is successful, @ref AVBSFList structure is freed and lst
- * will be set to NULL. In case of failure, caller is responsible for
- * freeing the structure by av_bsf_list_free()
- *
- * @param      lst Filter list structure to be transformed
- * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
- *                 representing the chain of bitstream filters
- *
- * @return >=0 on success, negative AVERROR in case of failure
- *)
-function av_bsf_list_finalize(lst: PPAVBSFList; bsf: PPAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Parse string describing list of bitstream filters and create single
- * @ref AVBSFContext describing the whole chain of bitstream filters.
- * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
- * allocated by av_bsf_alloc().
- *
- * @param      str String describing chain of bitstream filters in format
- *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`
- * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
- *                 representing the chain of bitstream filters
- *
- * @return >=0 on success, negative AVERROR in case of failure
- *)
-function av_bsf_list_parse_str(str: {const} Pcchar; bsf: PPAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(**
- * Get null/pass-through bitstream filter.
- *
- * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
- *
- * @return
- *)
-function av_bsf_get_null_filter(bsf: PPAVBSFContext): cint;
-  cdecl; external av__codec;
-
-(* memory *)
-
-(**
- * Same behaviour av_fast_malloc but the buffer has additional
- * FF_INPUT_BUFFER_PADDING_SIZE at the end which will will always be 0.
- *
- * In addition the whole buffer will initially and after resizes
- * be 0-initialized so that no uninitialized data will ever appear.
- *)
-procedure av_fast_padded_malloc(ptr: pointer; size: Pcuint; min_size: size_t);
-  cdecl; external av__codec;
-
-(**
- * Same behaviour av_fast_padded_malloc except that buffer will always
- * be 0-initialized after call.
- *)
-procedure av_fast_padded_mallocz(ptr: pointer; size: Pcuint; min_size: size_t);
-  cdecl; external av__codec;
-
-(**
- * Encode extradata length to a buffer. Used by xiph codecs.
- *
- * @param s buffer to write to; must be at least (v/255+1) bytes long
- * @param v size of extradata in bytes
- * @return number of bytes written to the buffer.
- *)
-function av_xiphlacing(s: PByte; v: cuint): cuint;
-  cdecl; external av__codec;
-
-{$IFDEF FF_API_USER_VISIBLE_AVHWACCEL}
-(**
- * Register the hardware accelerator hwaccel.
- *
- * @deprecated  This function doesn't do anything.
- *)
-procedure av_register_hwaccel (hwaccel: PAVHWAccel)
-  cdecl; external av__codec; deprecated;
-
-(**
- * If hwaccel is NULL, returns the first registered hardware accelerator,
- * if hwaccel is non-NULL, returns the next registered hardware accelerator
- * after hwaccel, or NULL if hwaccel is the last one.
- *
- * @deprecated  AVHWaccel structures contain no user-serviceable parts, so
- *              this function should not be used.
- *)
-function av_hwaccel_next (hwaccel: {const} PAVHWAccel): PAVHWAccel;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-{$IFDEF FF_API_LOCKMGR}
-(**
- * Lock operation used by lockmgr
- *
- * @deprecated Deprecated together with av_lockmgr_register().
- *)
-type
-  TAVLockOp = (
-    AV_LOCK_CREATE,  ///< Create a mutex
-    AV_LOCK_OBTAIN,  ///< Lock the mutex
-    AV_LOCK_RELEASE, ///< Unlock the mutex
-    AV_LOCK_DESTROY  ///< Free mutex resources
-  );
-
-(**
- * Register a user provided lock manager supporting the operations
- * specified by AVLockOp. The "mutex" argument to the function points
- * to a (void * ) where the lockmgr should store/get a pointer to a user
- * allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
- * value left by the last call for all other ops. If the lock manager is
- * unable to perform the op then it should leave the mutex in the same
- * state as when it was called and return a non-zero value. However,
- * when called with AV_LOCK_DESTROY the mutex will always be assumed to
- * have been successfully destroyed. If av_lockmgr_register succeeds
- * it will return a non-negative value, if it fails it will return a
- * negative value and destroy all mutex and unregister all callbacks.
- * av_lockmgr_register is not thread-safe, it must be called from a
- * single thread before any calls which make use of locking are used.
- *
- * @param cb User defined callback. av_lockmgr_register invokes calls
- *           to this callback and the previously registered callback.
- *           The callback will be used to create more than one mutex
- *           each of which must be backed by its own underlying locking
- *           mechanism (i.e. do not use a single static object to
- *           implement your lock manager). If cb is set to NULL the
- *           lockmgr will be unregistered.
- *
- * @deprecated This function does nothing, and always returns 0. Be sure to
- *             build with thread support to get basic thread safety.
- *)
-// ToDo: Implement and test this
-//function av_lockmgr_register(cb: function (mutex: Ppointer; op: TAVLockOp)): cint;
-//  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Get the type of the given codec.
- *)
-function avcodec_get_type(codec_id: TAVCodecID): TAVMediaType;
-  cdecl; external av__codec;
-
-(**
- * Get the name of a codec.
- * @return  a static string identifying the codec; never NULL
- *)
-function avcodec_get_name(id: TAVCodecID): PAnsiChar;
-  cdecl; external av__codec;
-
-(**
- * @return a positive value if s is open (i.e. avcodec_open2() was called on it
- * with no corresponding avcodec_close()), 0 otherwise.
- *)
-function avcodec_is_open(s: PAVCodecContext): cint;
-  cdecl; external av__codec;
-
-(**
- * @return a non-zero number if codec is an encoder, zero otherwise
- *)
-function av_codec_is_encoder(codec: {const} PAVCodec): cint;
-  cdecl; external av__codec;
-
-(**
- * @return a non-zero number if codec is a decoder, zero otherwise
- *)
-function av_codec_is_decoder(codec: {const} PAVCodec): cint;
-  cdecl; external av__codec;
-
-(**
- * @return descriptor for given codec ID or NULL if no descriptor exists.
- *)
-function avcodec_descriptor_get(id: TAVCodecID): PAVCodecDescriptor;
-  cdecl; external av__codec;
-
-(**
- * Iterate over all codec descriptors known to libavcodec.
- *
- * @param prev previous descriptor. NULL to get the first descriptor.
- *
- * @return next descriptor or NULL after the last descriptor
- *)
-function avcodec_descriptor_next(prev: {const} PAVCodecDescriptor): PAVCodecDescriptor;
-  cdecl; external av__codec;
-
-(**
- * @return codec descriptor with the given name or NULL if no such descriptor
- *         exists.
- *)
-function avcodec_descriptor_get_by_name(name: {const} PAnsiChar): PAVCodecDescriptor;
-  cdecl; external av__codec;
-
-(**
- * Allocate a CPB properties structure and initialize its fields to default
- * values.
- *
- * @param size if non-NULL, the size of the allocated struct will be written
- *             here. This is useful for embedding it in side data.
- *
- * @return the newly allocated struct or NULL on failure
- *)
-function av_cpb_properties_alloc(size: Psize_t): PAVCPBProperties;
-  cdecl; external av__codec;
-
-(**
- * @}
- *)
-
+function av_dup_packet(pkt: PAVPacket): cint; cdecl; external 'libavcodec';
+procedure av_init_packet(var pkt: TAVPacket); cdecl; external 'libavcodec';
+procedure av_free_packet(pkt: PAVPacket); cdecl; external 'libavcodec';
+function avcodec_version(): cuint; cdecl; external 'libavcodec';
+function av_codec_is_decoder(codec: PAVCodec): cint; cdecl; external 'libavcodec';
+function av_codec_iterate(opaque: ppointer): PAVCodec; cdecl; external 'libavcodec';
+function avcodec_find_decoder(id: TAVCodecID): PAVCodec; cdecl; external 'libavcodec';
+function avcodec_find_decoder_by_name(name: PAnsiChar): PAVCodec; cdecl; external 'libavcodec';
+function avcodec_descriptor_get(id: TAVCodecID): PAVCodecDescriptor; cdecl; external 'libavcodec';
+function avcodec_open2(avctx: PAVCodecContext; codec: PAVCodec; options: PPAVDictionary): cint; cdecl; external 'libavcodec';
+function avcodec_close(avctx: PAVCodecContext): cint; cdecl; external 'libavcodec';
+function avcodec_decode_video2(avctx: PAVCodecContext; picture: PAVFrame; var got_picture: cint; avpkt: PAVPacket): cint; cdecl; external 'libavcodec';
+procedure avcodec_flush_buffers(avctx: PAVCodecContext); cdecl; external 'libavcodec';
+function avpicture_fill(picture: PAVPicture; ptr: pcuint8; pix_fmt: TAVPixelFormat; width: cint; height: cint): cint; cdecl; external 'libavcodec';
+function avpicture_get_size(pix_fmt: TAVPixelFormat; width: cint; height: cint): cint; cdecl; external 'libavcodec';
+function avcodec_receive_frame(avctx: PAVCodecContext; frame: PAVFrame): cint; cdecl; external 'libavcodec';
+function avcodec_send_packet(avctx: PAVCodecContext; avpkt: PAVPacket): cint; cdecl; external 'libavcodec';
+function avcodec_alloc_context3(codec: PAVCodec): PAVCodecContext; cdecl; external 'libavcodec';
+procedure avcodec_free_context(avctx: PPAVCodecContext); cdecl; external 'libavcodec';
+function avcodec_parameters_to_context(codec: PAVCodecContext; par: PAVCodecParameters): cint; cdecl; external 'libavcodec';
 implementation
-
 end.
diff --git a/src/lib/ffmpeg-4.0/avformat.pas b/src/lib/ffmpeg-4.0/avformat.pas
index b6609e1f4..20418ceae 100644
--- a/src/lib/ffmpeg-4.0/avformat.pas
+++ b/src/lib/ffmpeg-4.0/avformat.pas
@@ -1,43 +1,13 @@
-(*
- * copyright (c) 2001 Fabrice Bellard
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of version 2.0 libavformat/avformat.h
- * Version: 56.4.101
- *)
-
 unit avformat;
 
 {$IFDEF FPC}
-  {$MODE DELPHI }
+  {$MODE DELPHI}
   {$PACKENUM 4}    (* use 4-byte enums *)
   {$PACKRECORDS C} (* C/C++-compatible record packing *)
 {$ELSE}
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I switches.inc}  (* for the HasInline define *)
-{$I ff_api-defines.inc}  (* FF_API_* defines *)
-
 {$IFDEF DARWIN}
   {$linklib libavformat}
 {$ENDIF}
@@ -50,20 +20,12 @@ interface
   avio,
   avutil,
   rational,
-  {$IFDEF UNIX}
-  BaseUnix,
-  {$ENDIF}
-  SysUtils,
   UConfig;
 
 const
-  (*
-   * IMPORTANT: This headers are valid for all minor revisions of ffmpeg
-   * version 2.4.*
-   *)
   (* Max. supported version by this header *)
   LIBAVFORMAT_MAX_VERSION_MAJOR   = 58;
-  LIBAVFORMAT_MAX_VERSION_MINOR   = 29;
+  LIBAVFORMAT_MAX_VERSION_MINOR   = 76;
   LIBAVFORMAT_MAX_VERSION_RELEASE = 100;
   LIBAVFORMAT_MAX_VERSION = (LIBAVFORMAT_MAX_VERSION_MAJOR * VERSION_MAJOR) +
                             (LIBAVFORMAT_MAX_VERSION_MINOR * VERSION_MINOR) +
@@ -87,3194 +49,75 @@ interface
   {$MESSAGE Error 'Linked version of libavformat is not yet supported!'}
 {$IFEND}
 
-{
-const
-  LIBAVFORMAT_BUILD = LIBAVFORMAT_VERSION_INT;
-  LIBAVFORMAT_IDENT = 'Lavf' AV_STRINGIFY(LIBAVFORMAT_VERSION);
-}
-
-(**
- * @defgroup libavf libavformat
- * I/O and Muxing/Demuxing Library
- *
- * Libavformat (lavf) is a library for dealing with various media container
- * formats. Its main two purposes are demuxing - i.e. splitting a media file
- * into component streams, and the reverse process of muxing - writing supplied
- * data in a specified container format. It also has an @ref lavf_io
- * "I/O module" which supports a number of protocols for accessing the data (e.g.
- * file, tcp, http and others). Before using lavf, you need to call
- * av_register_all() to register all compiled muxers, demuxers and protocols.
- * Unless you are absolutely sure you won't use libavformat's network
- * capabilities, you should also call avformat_network_init().
- *
- * A supported input format is described by an AVInputFormat struct, conversely
- * an output format is described by AVOutputFormat. You can iterate over all
- * registered input/output formats using the av_iformat_next() /
- * av_oformat_next() functions. The protocols layer is not part of the public
- * API, so you can only get the names of supported protocols with the
- * avio_enum_protocols() function.
- *
- * Main lavf structure used for both muxing and demuxing is AVFormatContext,
- * which exports all information about the file being read or written. As with
- * most Libavformat structures, its size is not part of public ABI, so it cannot be
- * allocated on stack or directly with av_malloc(). To create an
- * AVFormatContext, use avformat_alloc_context() (some functions, like
- * avformat_open_input() might do that for you).
- *
- * Most importantly an AVFormatContext contains:
- * @li the @ref AVFormatContext.iformat "input" or @ref AVFormatContext.oformat
- * "output" format. It is either autodetected or set by user for input;
- * always set by user for output.
- * @li an @ref AVFormatContext.streams "array" of AVStreams, which describe all
- * elementary streams stored in the file. AVStreams are typically referred to
- * using their index in this array.
- * @li an @ref AVFormatContext.pb "I/O context". It is either opened by lavf or
- * set by user for input, always set by user for output (unless you are dealing
- * with an AVFMT_NOFILE format).
- *
- * @section lavf_options Passing options to (de)muxers
- * It is possible to configure lavf muxers and demuxers using the @ref avoptions
- * mechanism. Generic (format-independent) libavformat options are provided by
- * AVFormatContext, they can be examined from a user program by calling
- * av_opt_next() / av_opt_find() on an allocated AVFormatContext (or its AVClass
- * from avformat_get_class()). Private (format-specific) options are provided by
- * AVFormatContext.priv_data if and only if AVInputFormat.priv_class /
- * AVOutputFormat.priv_class of the corresponding format struct is non-NULL.
- * Further options may be provided by the @ref AVFormatContext.pb "I/O context",
- * if its AVClass is non-NULL, and the protocols layer. See the discussion on
- * nesting in @ref avoptions documentation to learn how to access those.
- *
- * @section urls
- * URL strings in libavformat are made of a scheme/protocol, a ':', and a
- * scheme specific string. URLs without a scheme and ':' used for local files
- * are supported but deprecated. "file:" should be used for local files.
- *
- * It is important that the scheme string is not taken from untrusted
- * sources without checks.
- *
- * Note that some schemes/protocols are quite powerful, allowing access to
- * both local and remote files, parts of them, concatenations of them, local
- * audio and video devices and so on.
- *
- * @{
- *
- * @defgroup lavf_decoding Demuxing
- * @defgroup lavf_decoding Demuxing
- * @
- * Demuxers read a media file and split it into chunks of data (@em packets). A
- * @ref AVPacket "packet" contains one or more encoded frames which belongs to a
- * single elementary stream. In the lavf API this process is represented by the
- * avformat_open_input() function for opening a file, av_read_frame() for
- * reading a single packet and finally avformat_close_input(), which does the
- * cleanup.
- *
- * @section lavf_decoding_open Opening a media file
- * The minimum information required to open a file is its URL, which
- * is passed to avformat_open_input(), as in the following code:
- * @code
- * const char    *url = "file:in.mp3";
- * AVFormatContext *s = NULL;
- * int ret = avformat_open_input(&s, url, NULL, NULL);
- * if (ret < 0)
- *     abort();
- * @endcode
- * The above code attempts to allocate an AVFormatContext, open the
- * specified file (autodetecting the format) and read the header, exporting the
- * information stored there into s. Some formats do not have a header or do not
- * store enough information there, so it is recommended that you call the
- * avformat_find_stream_info() function which tries to read and decode a few
- * frames to find missing information.
- *
- * In some cases you might want to preallocate an AVFormatContext yourself with
- * avformat_alloc_context() and do some tweaking on it before passing it to
- * avformat_open_input(). One such case is when you want to use custom functions
- * for reading input data instead of lavf internal I/O layer.
- * To do that, create your own AVIOContext with avio_alloc_context(), passing
- * your reading callbacks to it. Then set the @em pb field of your
- * AVFormatContext to newly created AVIOContext.
- *
- * Since the format of the opened file is in general not known until after
- * avformat_open_input() has returned, it is not possible to set demuxer private
- * options on a preallocated context. Instead, the options should be passed to
- * avformat_open_input() wrapped in an AVDictionary:
- * @code
- * AVDictionary *options = NULL;
- * av_dict_set(&options, "video_size", "640x480", 0);
- * av_dict_set(&options, "pixel_format", "rgb24", 0);
- *
- * if (avformat_open_input(&s, url, NULL, &options) < 0)
- *     abort();
- * av_dict_free(&options);
- * @endcode
- * This code passes the private options 'video_size' and 'pixel_format' to the
- * demuxer. They would be necessary for e.g. the rawvideo demuxer, since it
- * cannot know how to interpret raw video data otherwise. If the format turns
- * out to be something different than raw video, those options will not be
- * recognized by the demuxer and therefore will not be applied. Such unrecognized
- * options are then returned in the options dictionary (recognized options are
- * consumed). The calling program can handle such unrecognized options as it
- * wishes, e.g.
- * @code
- * AVDictionaryEntry *e;
- * if (e = av_dict_get(options, "", NULL, AV_DICT_IGNORE_SUFFIX)) {
- *     fprintf(stderr, "Option %s not recognized by the demuxer.\n", e->key);
- *     abort();
- * }
- * @endcode
- *
- * After you have finished reading the file, you must close it with
- * avformat_close_input(). It will free everything associated with the file.
- *
- * @section lavf_decoding_read Reading from an opened file
- * Reading data from an opened AVFormatContext is done by repeatedly calling
- * av_read_frame() on it. Each call, if successful, will return an AVPacket
- * containing encoded data for one AVStream, identified by
- * AVPacket.stream_index. This packet may be passed straight into the libavcodec
- * decoding functions avcodec_send_packet() or avcodec_decode_subtitle2() if the
- * caller wishes to decode the data.
- *
- * AVPacket.pts, AVPacket.dts and AVPacket.duration timing information will be
- * set if known. They may also be unset (i.e. AV_NOPTS_VALUE for
- * pts/dts, 0 for duration) if the stream does not provide them. The timing
- * information will be in AVStream.time_base units, i.e. it has to be
- * multiplied by the timebase to convert them to seconds.
- *
- * If AVPacket.buf is set on the returned packet, then the packet is
- * allocated dynamically and the user may keep it indefinitely.
- * Otherwise, if AVPacket.buf is NULL, the packet data is backed by a
- * static storage somewhere inside the demuxer and the packet is only valid
- * until the next av_read_frame() call or closing the file. If the caller
- * requires a longer lifetime, av_dup_packet() will make an av_malloc()ed copy
- * of it.
- * In both cases, the packet must be freed with av_packet_unref() when it is no
- * longer needed.
- *
- * @section lavf_decoding_seek Seeking
- * @
- *
- * @defgroup lavf_encoding Muxing
- * @
- * Muxers take encoded data in the form of @ref AVPacket "AVPackets" and write
- * it into files or other output bytestreams in the specified container format.
- *
- * The main API functions for muxing are avformat_write_header() for writing the
- * file header, av_write_frame() / av_interleaved_write_frame() for writing the
- * packets and av_write_trailer() for finalizing the file.
- *
- * At the beginning of the muxing process, the caller must first call
- * avformat_alloc_context() to create a muxing context. The caller then sets up
- * the muxer by filling the various fields in this context:
- *
- * - The @ref AVFormatContext.oformat "oformat" field must be set to select the
- *   muxer that will be used.
- * - Unless the format is of the AVFMT_NOFILE type, the @ref AVFormatContext.pb
- *   "pb" field must be set to an opened IO context, either returned from
- *   avio_open2() or a custom one.
- * - Unless the format is of the AVFMT_NOSTREAMS type, at least one stream must
- *   be created with the avformat_new_stream() function. The caller should fill
- *   the @ref AVStream.codecpar "stream codec parameters" information, such as the
- *   codec @ref AVCodecParameters.codec_type "type", @ref AVCodecParameters.codec_id
- *   "id" and other parameters (e.g. width / height, the pixel or sample format,
- *   etc.) as known. The @ref AVStream.time_base "stream timebase" should
- *   be set to the timebase that the caller desires to use for this stream (note
- *   that the timebase actually used by the muxer can be different, as will be
- *   described later).
- * - It is advised to manually initialize only the relevant fields in
- *   AVCodecParameters, rather than using @ref avcodec_parameters_copy() during
- *   remuxing: there is no guarantee that the codec context values remain valid
- *   for both input and output format contexts.
- * - The caller may fill in additional information, such as @ref
- *   AVFormatContext.metadata "global" or @ref AVStream.metadata "per-stream"
- *   metadata, @ref AVFormatContext.chapters "chapters", @ref
- *   AVFormatContext.programs "programs", etc. as described in the
- *   AVFormatContext documentation. Whether such information will actually be
- *   stored in the output depends on what the container format and the muxer
- *   support.
- *
- * When the muxing context is fully set up, the caller must call
- * avformat_write_header() to initialize the muxer internals and write the file
- * header. Whether anything actually is written to the IO context at this step
- * depends on the muxer, but this function must always be called. Any muxer
- * private options must be passed in the options parameter to this function.
- *
- * The data is then sent to the muxer by repeatedly calling av_write_frame() or
- * av_interleaved_write_frame() (consult those functions' documentation for
- * discussion on the difference between them; only one of them may be used with
- * a single muxing context, they should not be mixed). Do note that the timing
- * information on the packets sent to the muxer must be in the corresponding
- * AVStream's timebase. That timebase is set by the muxer (in the
- * avformat_write_header() step) and may be different from the timebase
- * requested by the caller.
- *
- * Once all the data has been written, the caller must call av_write_trailer()
- * to flush any buffered packets and finalize the output file, then close the IO
- * context (if any) and finally free the muxing context with
- * avformat_free_context().
- * @}
- *
- * @defgroup lavf_io I/O Read/Write
- * @{
- * @section lavf_io_dirlist Directory listing
- * The directory listing API makes it possible to list files on remote servers.
- *
- * Some of possible use cases:
- * - an "open file" dialog to choose files from a remote location,
- * - a recursive media finder providing a player with an ability to play all
- * files from a given directory.
- *
- * @subsection lavf_io_dirlist_open Opening a directory
- * At first, a directory needs to be opened by calling avio_open_dir()
- * supplied with a URL and, optionally, ::AVDictionary containing
- * protocol-specific parameters. The function returns zero or positive
- * integer and allocates AVIODirContext on success.
- *
- * @code
- * AVIODirContext *ctx = NULL;
- * if (avio_open_dir(&ctx, "smb://example.com/some_dir", NULL) < 0) {
- *     fprintf(stderr, "Cannot open directory.\n");
- *     abort();
- * }
- * @endcode
- *
- * This code tries to open a sample directory using smb protocol without
- * any additional parameters.
- *
- * @subsection lavf_io_dirlist_read Reading entries
- * Each directory's entry (i.e. file, another directory, anything else
- * within ::AVIODirEntryType) is represented by AVIODirEntry.
- * Reading consecutive entries from an opened AVIODirContext is done by
- * repeatedly calling avio_read_dir() on it. Each call returns zero or
- * positive integer if successful. Reading can be stopped right after the
- * NULL entry has been read -- it means there are no entries left to be
- * read. The following code reads all entries from a directory associated
- * with ctx and prints their names to standard output.
- * @code
- * AVIODirEntry *entry = NULL;
- * for (;;) {
- *     if (avio_read_dir(ctx, &entry) < 0) {
- *         fprintf(stderr, "Cannot list directory.\n");
- *         abort();
- *     }
- *     if (!entry)
- *         break;
- *     printf("%s\n", entry->name);
- *     avio_free_directory_entry(&entry);
- * }
- * @endcode
- * @}
- *
- * @defgroup lavf_codec Demuxers
- * @{
- * @defgroup lavf_codec_native Native Demuxers
- * @{
- * @}
- * @defgroup lavf_codec_wrappers External library wrappers
- * @{
- * @}
- * @}
- * @defgroup lavf_protos I/O Protocols
- * @{
- * @}
- * @defgroup lavf_internal Internal
- * @{
- * @}
- * @}
- *)
-
-//type
-
-(*
- * @defgroup metadata_api Public Metadata API
- * @
- * @ingroup libavf
- * The metadata API allows libavformat to export metadata tags to a client
- * application when demuxing. Conversely it allows a client application to
- * set metadata when muxing.
- *
- * Metadata is exported or set as pairs of key/value strings in the 'metadata'
- * fields of the AVFormatContext, AVStream, AVChapter and AVProgram structs
- * using the @ref lavu_dict "AVDictionary" API. Like all strings in FFmpeg,
- * metadata is assumed to be UTF-8 encoded Unicode. Note that metadata
- * exported by demuxers isn't checked to be valid UTF-8 in most cases.
- *
- * Important concepts to keep in mind:
- * -  Keys are unique; there can never be 2 tags with the same key. This is
- *    also meant semantically, i.e., a demuxer should not knowingly produce
- *    several keys that are literally different but semantically identical.
- *    E.g., key=Author5, key=Author6. In this example, all authors must be
- *    placed in the same tag.
- * -  Metadata is flat, not hierarchical; there are no subtags. If you
- *    want to store, e.g., the email address of the child of producer Alice
- *    and actor Bob, that could have key=alice_and_bobs_childs_email_address.
- * -  Several modifiers can be applied to the tag name. This is done by
- *    appending a dash character ('-') and the modifier name in the order
- *    they appear in the list below -- e.g. foo-eng-sort, not foo-sort-eng.
- *    -  language -- a tag whose value is localized for a particular language
- *       is appended with the ISO 639-2/B 3-letter language code.
- *       For example: Author-ger=Michael, Author-eng=Mike
- *       The original/default language is in the unqualified "Author" tag.
- *       A demuxer should set a default if it sets any translated tag.
- *    -  sorting  -- a modified version of a tag that should be used for
- *       sorting will have '-sort' appended. E.g. artist="The Beatles",
- *       artist-sort="Beatles, The".
- *
- * -  Demuxers attempt to export metadata in a generic format, however tags
- *    with no generic equivalents are left as they are stored in the container.
- *    Follows a list of generic tag names:
- *
- @verbatim
- album        -- name of the set this work belongs to
- album_artist -- main creator of the set/album, if different from artist.
-                 e.g. "Various Artists" for compilation albums.
- artist       -- main creator of the work
- comment      -- any additional description of the file.
- composer     -- who composed the work, if different from artist.
- copyright    -- name of copyright holder.
- creation_time-- date when the file was created, preferably in ISO 8601.
- date         -- date when the work was created, preferably in ISO 8601.
- disc         -- number of a subset, e.g. disc in a multi-disc collection.
- encoder      -- name/settings of the software/hardware that produced the file.
- encoded_by   -- person/group who created the file.
- filename     -- original name of the file.
- genre        -- <self-evident>.
- language     -- main language in which the work is performed, preferably
-                 in ISO 639-2 format. Multiple languages can be specified by
-                 separating them with commas.
- performer    -- artist who performed the work, if different from artist.
-                 E.g for "Also sprach Zarathustra", artist would be "Richard
-                 Strauss" and performer "London Philharmonic Orchestra".
- publisher    -- name of the label/publisher.
- service_name     -- name of the service in broadcasting (channel name).
- service_provider -- name of the service provider in broadcasting.
- title        -- name of the work.
- track        -- number of this work in the set, can be in form current/total.
- variant_bitrate -- the total bitrate of the bitrate variant that the current stream is part of
- @endverbatim
- *
- * Look in the examples section for an application example how to use the Metadata API.
- *
- * @
- *)
-
-(* packet functions *)
-
-(**
- * Allocate and read the payload of a packet and initialize its fields with
- * default values.
- *
- * @param s    associated IO context
- * @param pkt packet
- * @param size desired payload size
- * @return >0 (read size) if OK, AVERROR_xxx otherwise
- *)
-function av_get_packet(s: PAVIOContext; var pkt: TAVPacket; size: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Read data and append it to the current content of the AVPacket.
- * If pkt->size is 0 this is identical to av_get_packet.
- * Note that this uses av_grow_packet and thus involves a realloc
- * which is inefficient. Thus this function should only be used
- * when there is no reasonable way to know (an upper bound of)
- * the final size.
- *
- * @param s    associated IO context
- * @param pkt packet
- * @param size amount of data to read
- * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
- *         will not be lost even if an error occurs.
- *)
-function av_append_packet(s: PAVIOContext; var pkt: TAVPacket; size: cint): cint;
-  cdecl; external av__format;
-
-{$IFNDEF FPC}
-  //defines for delphi
-  size_t = cardinal;
-{$ENDIF}
-
-(*************************************************)
-(* input/output formats *)
-
-type
-  (**
-   * This structure contains the data a format has to probe a file.
-   *)
-  TAVProbeData = record
-    filename: PAnsiChar;
-    buf: PByteArray;   (**< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. *)
-    buf_size: cint;    (**< Size of buf except extra allocated bytes *)
-    {const} mime_type: PAnsiChar; (**< mime_type, when known. *)
-  end;
-
 const
-	AVPROBE_SCORE_EXTENSION    =  50; ///< score for file extension
-	AVPROBE_SCORE_MIME         =  75; ///< score for file mime type
-  AVPROBE_SCORE_MAX          = 100; ///< maximum score
-
-	AVPROBE_SCORE_RETRY        = (AVPROBE_SCORE_MAX DIV 4);
-  AVPROBE_SCORE_STREAM_RETRY = (AVPROBE_SCORE_MAX DIV 4-1);
-
-  AVPROBE_PADDING_SIZE       = 32;  ///< extra allocated bytes at the end of the probe buffer
-
-/// Demuxer will use avio_open, no opened file should be provided by the caller.
-  AVFMT_NOFILE        = $0001;
-  AVFMT_NEEDNUMBER    = $0002; (**< Needs '%d' in filename. *)
-  AVFMT_SHOW_IDS      = $0008; (**< Show format stream IDs numbers. *)
-  AVFMT_GLOBALHEADER  = $0040; (**< Format wants global header. *)
-  AVFMT_NOTIMESTAMPS  = $0080; (**< Format does not need / have any timestamps. *)
-  AVFMT_GENERIC_INDEX = $0100; (**< Use generic index building code. *)
-  AVFMT_TS_DISCONT    = $0200; (**< Format allows timestamp discontinuities. *)
-  AVFMT_VARIABLE_FPS  = $0400; (**< Format allows variable fps. *)
-  AVFMT_NODIMENSIONS  = $0800; (**< Format does not need width/height *)
-  AVFMT_NOSTREAMS     = $1000; (**< Format does not require any streams *)
-  AVFMT_NOBINSEARCH   = $2000; (**< Format does not allow to fall back to binary search via read_timestamp *)
-  AVFMT_NOGENSEARCH   = $4000; (**< Format does not allow to fall back to generic search *)
-  AVFMT_NO_BYTE_SEEK  = $8000; (**< Format does not allow seeking by bytes *)
-  AVFMT_ALLOW_FLUSH   = $10000;(**< Format allows flushing. If not set, the muxer will not receive a NULL packet in the write_packet function. *)
-  AVFMT_TS_NONSTRICT  = $20000;(**< Format does not require strictly
-                                        increasing timestamps, but they must
-                                        still be monotonic *)
-  AVFMT_TS_NEGATIVE   = $40000;    (**< Format allows muxing negative
-                                        timestamps. If not set the timestamp
-                                        will be shifted in av_write_frame and
-                                        av_interleaved_write_frame so they
-                                        start from 0.
-                                        The user or muxer can override this through
-                                        AVFormatContext.avoid_negative_ts
-                                        *)
-
-  AVFMT_SEEK_TO_PTS   = $4000000;  (**< Seeking is based on PTS *)
-
-  // used by AVIndexEntry
-  AVINDEX_KEYFRAME = $0001;
-  AVINDEX_DISCARD_FRAME = $0002; (**
-                                   * Flag is used to indicate which frame should be discarded after decoding.
-                                   *)
-  AVFMTCTX_NOHEADER = $0001; (**< signal that no header is present
-                                         (streams are added dynamically) *)
-  AVFMTCTX_UNSEEKABLE = $0002; (**< signal that the stream is definitely
-                                         not seekable, and attempts to call the
-                                         seek function will fail. For some
-                                         network protocols (e.g. HLS), this can
-                                         change dynamically at runtime. *)
-
-
-  MAX_STREAMS = 20;
-
-  AVFMT_FLAG_GENPTS          =  $0001;   ///< Generate missing pts even if it requires parsing future frames.
-  AVFMT_FLAG_IGNIDX          =  $0002;   ///< Ignore index.
-  AVFMT_FLAG_NONBLOCK        =  $0004; ///< Do not block when reading packets from input.
-  AVFMT_FLAG_IGNDTS          =  $0008; ///< Ignore DTS on frames that contain both DTS & PTS
-  AVFMT_FLAG_NOFILLIN        =  $0010; ///< Do not infer any values from other values, just return what is stored in the container
-  AVFMT_FLAG_NOPARSE         =  $0020; ///< Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -> no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled
-  AVFMT_FLAG_NOBUFFER        =  $0040; ///< Do not buffer frames when possible
-  AVFMT_FLAG_CUSTOM_IO       =  $0080; ///< The caller has supplied a custom AVIOContext, don't avio_close() it.
-  AVFMT_FLAG_DISCARD_CORRUPT =  $0100; ///< Discard frames marked corrupted
-  AVFMT_FLAG_FLUSH_PACKETS   =  $0200; ///< Flush the AVIOContext every packet.
-(**
- * When muxing, try to avoid writing any random/volatile data to the output.
- * This includes any random IDs, real-time timestamps/dates, muxer version, etc.
- *
- * This flag is mainly intended for testing.
- *)
-  AVFMT_FLAG_BITEXACT        =  $0400;
-  AVFMT_FLAG_MP4A_LATM       =  $8000; ///< Enable RTP MP4A-LATM payload
-  AVFMT_FLAG_SORT_DTS        = $10000; ///< try to interleave outputted packets by dts (using this flag can slow demuxing down)
-  AVFMT_FLAG_PRIV_OPT        = $20000; ///< Enable use of private options by delaying codec open (this could be made default once all code is converted)
-  {$IFDEF FF_API_LAVF_KEEPSIDE_FLAG}
-  AVFMT_FLAG_KEEP_SIDE_DATA  = $40000; ///< Deprecated, does nothing.
-  {$ENDIF}
-  AVFMT_FLAG_FAST_SEEK       = $80000; ///< Enable fast, but inaccurate seeks for some formats
-  AVFMT_FLAG_SHORTEST        = $100000; ///< Stop muxing when the shortest stream stops.
-  AVFMT_FLAG_AUTO_BSF        = $200000; ///< Add bitstream filters as requested by the muxer
-
-  // used by AVStream
-  AVSTREAM_EVENT_FLAG_METADATA_UPDATED = $0001; ///< The call resulted in updated metadata.
-  MAX_STD_TIMEBASES = (30*12+30+3+6);
-  MAX_REORDER_DELAY = 16;
-
-  // used by TAVProgram
-  AV_PROGRAM_RUNNING = 1;
-
-
-  AV_DISPOSITION_DEFAULT   = $0001;
-  AV_DISPOSITION_DUB       = $0002;
-  AV_DISPOSITION_ORIGINAL  = $0004;
-  AV_DISPOSITION_COMMENT   = $0008;
-  AV_DISPOSITION_LYRICS    = $0010;
-  AV_DISPOSITION_KARAOKE   = $0020;
-
-  (**
-   * Track should be used during playback by default.
-   * Useful for subtitle track that should be displayed
-   * even when user did not explicitly ask for subtitles.
-   *)
-  AV_DISPOSITION_FORCED    = $0040;
-  AV_DISPOSITION_HEARING_IMPAIRED = $0080;  (**< stream for hearing impaired audiences *)
-  AV_DISPOSITION_VISUAL_IMPAIRED  = $0100;  (**< stream for visual impaired audiences *)
-  AV_DISPOSITION_CLEAN_EFFECTS    = $0200;  (**< stream without voice *)
-(**
- * The stream is stored in the file as an attached picture/"cover art" (e.g.
- * APIC frame in ID3v2). The first (usually only) packet associated with it
- * will be returned among the first few packets read from the file unless
- * seeking takes place. It can also be accessed at any time in
- * AVStream.attached_pic.
- *)
-  AV_DISPOSITION_ATTACHED_PIC     = $0400;
-
-(**
- * The stream is sparse, and contains thumbnail images, often corresponding
- * to chapter markers. Only ever used with AV_DISPOSITION_ATTACHED_PIC.
- *)
- AV_DISPOSITION_TIMED_THUMBNAILS  = $0800;
-
-(**
- * To specify text track kind (different from subtitles default).
- *)
-  AV_DISPOSITION_CAPTIONS     = $10000;
-  AV_DISPOSITION_DESCRIPTIONS = $20000;
-  AV_DISPOSITION_METADATA     = $40000;
-  AV_DISPOSITION_DEPENDENT    = $80000; ///< dependent audio stream (mix_type=0 in mpegts)
-
-(**
- * Options for behavior on timestamp wrap detection.
- *)
-  AV_PTS_WRAP_IGNORE     = 0;   ///< ignore the wrap
-  AV_PTS_WRAP_ADD_OFFSET = 1;   ///< add the format specific offset on wrap detection
-  AV_PTS_WRAP_SUB_OFFSET = -1;  ///< subtract the format specific offset on wrap detection
-
-  // used by TAVFormatContext.debug
-  FF_FDEBUG_TS = 0001;
-  AVFMT_EVENT_FLAG_METADATA_UPDATED = 0001; ///< The call resulted in updated metadata.
-
-  RAW_PACKET_BUFFER_SIZE = 2500000;
-
-  AVFMT_AVOID_NEG_TS_AUTO              = -1; ///< Enabled when required by target format
-  AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE =  1; ///< Shift timestamps so they are non negative
-  AVFMT_AVOID_NEG_TS_MAKE_ZERO         =  2; ///< Shift timestamps so that they start at 0
-
+  AVFMT_FLAG_GENPTS = 1;
+  AVSEEK_FLAG_ANY = 4;
+  AVSEEK_FLAG_BACKWARD = 1;
 type
-  PPAVCodecTag = ^PAVCodecTag;
-  PAVCodecTag = Pointer;
-
-  PAVOutputFormat = ^TAVOutputFormat;
-  PAVProbeData = ^TAVProbeData;
-
-  PAVInputFormat = ^TAVInputFormat;
-  PAVIndexEntry = ^TAVIndexEntry;
-
-  PPAVStream = ^PAVStream;
-  PAVStream = ^TAVStream;
   PAVPacketList = ^TAVPacketList;
   TAVPacketList = record
     pkt: TAVPacket;
-    next: PAVPacketList;
-  end; (*AVPacketList*)
-
-  PPAVProgram = ^PAVProgram;
-  PAVProgram = ^TAVProgram;
-
-  PPAVFormatContext = ^PAVFormatContext;
-  PAVFormatContext = ^TAVFormatContext;
-
-(**
- * Convert all the metadata sets from ctx according to the source and
- * destination conversion tables.
- *
- * @param d_conv destination tags format conversion table
- * @param s_conv source tags format conversion table
- *)
-  PAVMetadataConv = ^TAVMetadataConv;
-  TAVMetadataConv = record
-    ctx:            PAVFormatContext;
-    d_conv: {const} PAVMetadataConv;
-    s_conv: {const} PAVMetadataConv;
-  end;
-
-  (** From libavdevice/avdevice.h **)
-  PPAVDeviceInfo = ^PAVDeviceInfo;
-  PAVDeviceInfo = ^TAVDeviceInfo;
-  TAVDeviceInfo = record
-    device_name: PAnsiChar; (**< device name, format depends on device *)
-    device_description: PAnsiChar; (**< human friendly name *)
-  end; {TAVDeviceInfo}
-
-  PAVDeviceInfoList = ^TAVDeviceInfoList;
-  TAVDeviceInfoList = record
-    devices: PPAVDeviceInfo;  (**< list of autodetected devices *)
-    nb_devices: cint; (**< number of autodetected devices *)
-    default_device: cint; (**< index of default device or -1 if no default *)
-  end; {TAVDeviceInfoList}
-
-  PAVDeviceCapabilitiesQuery = ^TAVDeviceCapabilitiesQuery;
-  TAVDeviceCapabilitiesQuery = record
-  end;
-
-  PFFFrac = ^TFFFrac;
-  TFFFrac = record
-    val: cint64;
-    num: cint64;
-    den: cint64;
-  end;
-
-(**
- * @addtogroup lavf_encoding
- * @
- *)
-   TAVOutputFormat = record
-    name: PAnsiChar;
-    (**
-     * Descriptive name for the format, meant to be more human-readable
-     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
-     * to define it.
-     *)
-    long_name: PAnsiChar;
-    mime_type: PAnsiChar;
-    extensions: PAnsiChar; (**< comma-separated filename extensions *)
-    (* output support *)
-    audio_codec: TAVCodecID;    (**< default audio codec *)
-    video_codec: TAVCodecID;    (**< default video codec *)
-    subtitle_codec: TAVCodecID; (**< default subtitle codec *)
-    (**
-     * can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
-     * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
-     * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
-     * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
-     *)
-    flags: cint;
-
-    (**
-     * List of supported codec_id-codec_tag pairs, ordered by "better
-     * choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
-     *)
-    codec_tag: {const} PPAVCodecTag;
-
-    priv_class: {const} PAVClass; ///< AVClass for the private context
-
-    (*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-    next: PAVOutputFormat;
-    (**
-     * size of private data so that it can be allocated in the wrapper
-     *)
-    priv_data_size: cint;
-
-    write_header: function (c: PAVFormatContext): cint; cdecl;
-    (**
-     * Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
-     * pkt can be NULL in order to flush data buffered in the muxer.
-     * When flushing, return 0 if there still is more data to flush,
-     * or 1 if everything was flushed and there is no more buffered
-     * data.
-     *)
-    write_packet: function (c: PAVFormatContext; pkt: PAVPacket): cint; cdecl;
-    write_trailer: function (c: PAVFormatContext): cint; cdecl;
-    (**
-     * Currently only used to set pixel format if not YUV420P.
-     *)
-    interleave_packet: function (s: PAVFormatContext; out_: PAVPacket;
-                                 in_: PAVPacket; flush: cint): cint; cdecl;
-    (**
-     * Test if the given codec can be stored in this container.
-     *
-     * @return 1 if the codec is supported, 0 if it is not.
-     *         A negative number if unknown.
-     *         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
-     *)
-    query_codec: function (id: TAVCodecID; std_compliance: cint): cint; cdecl;
-
-    get_output_timestamp: procedure (s: PAVFormatContext; stream: cint;
-				     dts: Pcint64; wall: Pcint64); cdecl;
-
-    (**
-     * Allows sending messages from application to device.
-     *)
-    control_message: function(s: PAVFormatContext; type_: cint; data: pointer;
-				  data_size: size_t): cint; cdecl;
-
-    (**
-     * Write an uncoded AVFrame.
-     *
-     * See av_write_uncoded_frame() for details.
-     *
-     * The library will free *frame afterwards, but the muxer can prevent it
-     * by setting the pointer to NULL.
-     *)
-    write_uncodec_frame: function(s: PAVFormatContext; stream_index: cint;
-				  frame: PPAVFrame; flags: cuint): cint; cdecl;
-
-    (**
-     * Returns device list with it properties.
-     * @see avdevice_list_devices() for more details.
-     *)
-    get_device_list: function(s: PAVFormatContext; device_list: PAVDeviceInfoList): cint; cdecl;
-
-    (**
-     * Initialize device capabilities submodule.
-     * @see avdevice_capabilities_create() for more details.
-     *)
-    create_device_capabilities: function(s: PAVFormatContext; caps: PAVDeviceCapabilitiesQuery): cint; cdecl;
-
-    (**
-     * Free device capabilities submodule.
-     * @see avdevice_capabilities_free() for more details.
-     *)
-    free_device_capabilities: function(s: PAVFormatContext; caps: PAVDeviceCapabilitiesQuery): cint; cdecl;
-
-    data_codec: TAVCodecID; (**< default data codec *)
-
-    (**
-     * Initialize format. May allocate data here, and set any AVFormatContext or
-     * AVStream parameters that need to be set before packets are sent.
-     * This method must not write output.
-     *
-     * Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure
-     *
-     * Any allocations made here must be freed in deinit().
-     *)
-    init: function(s: PAVFormatContext): cint; cdecl;
-
-    (**
-     * Deinitialize format. If present, this is called whenever the muxer is being
-     * destroyed, regardless of whether or not the header has been written.
-     *
-     * If a trailer is being written, this is called after write_trailer().
-     *
-     * This is called if init() fails as well.
-     *)
-    deinit: procedure(s: PAVFormatContext);
-
-    (**
-     * Set up any necessary bitstream filtering and extract any extra data needed
-     * for the global header.
-     * Return 0 if more packets from this stream must be checked; 1 if not.
-     *)
-    check_bitstream: function(s: PAVFormatContext; pkt: {const} PAVPacket): cint; cdecl;
-  end;
-(**
- * @}
- *)
-
-(**
- * @addtogroup lavf_decoding
- * @
- *)
-  TAVInputFormat = record
-    (**
-     * A comma separated list of short names for the format. New names
-     * may be appended with a minor bump.
-     *)
-    name: PAnsiChar;
-
-    (**
-     * Descriptive name for the format, meant to be more human-readable
-     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
-     * to define it.
-     *)
-    long_name: PAnsiChar;
-
-    (**
-     * Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
-     * AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
-     * AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
-     *)
-    flags: cint;
-
-    (**
-     * If extensions are defined, then no probe is done. You should
-     * usually not use extension format guessing because it is not
-     * reliable enough
-     *)
-    extensions: PAnsiChar;
-
-    codec_tag: {const} PPAVCodecTag;
-
-    priv_class: {const} PAVClass; ///< AVClass for the private context
-
-    (**
-     * Comma-separated list of mime types.
-     * It is used check for matching mime types while probing.
-     * @see av_probe_input_format2
-     *)
-    mime_type: {const} PAnsiChar;
-
-    (*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-    next: PAVInputFormat;
-
-    (**
-     * Raw demuxers store their codec ID here.
-     *)
-    raw_codec_id: cint;
-
-    (**
-     * Size of private data so that it can be allocated in the wrapper.
-     *)
-    priv_data_size: cint;
-
-    (**
-     * Tell if a given file has a chance of being parsed as this format.
-     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
-     * big so you do not have to check for that unless you need more.
-     *)
-    read_probe: function (p: PAVProbeData): cint; cdecl;
-
-    (**
-     * Read the format header and initialize the AVFormatContext
-     * structure. Return 0 if OK. Only used in raw format right
-     * now. 'avformat_new_stream' should be called to create new streams.
-     *)
-    read_header: function (c: PAVFormatContext): cint; cdecl;
-
-    (**
-     * Read one packet and put it in 'pkt'. pts and flags are also
-     * set. 'avformat_new_stream' can be called only if the flag
-     * AVFMTCTX_NOHEADER is used.
-     * @return 0 on success, < 0 on error.
-     *         When returning an error, pkt must not have been allocated
-     *         or must be freed before returning
-     *)
-    read_packet: function (c: PAVFormatContext; var pkt: TAVPacket): cint; cdecl;
-
-    (**
-     * Close the stream. The AVFormatContext and AVStreams are not
-     * freed by this function
-     *)
-    read_close: function (c: PAVFormatContext): cint; cdecl;
-
-    (**
-     * Seek to a given timestamp relative to the frames in
-     * stream component stream_index.
-     * @param stream_index Must not be -1.
-     * @param flags Selects which direction should be preferred if no exact
-     *              match is available.
-     * @return >= 0 on success (but not necessarily the new offset)
-     *)
-    read_seek: function (c: PAVFormatContext; stream_index: cint;
-                  timestamp: cint64; flags: cint): cint; cdecl;
-
-    (**
-     * Get the next timestamp in stream[stream_index].time_base units.
-     * @return the timestamp or AV_NOPTS_VALUE if an error occurred
-     *)
-    read_timestamp: function (s: PAVFormatContext; stream_index: cint;
-                              pos: pint64; pos_limit: cint64): cint64; cdecl;
-
-    (**
-     * Start/resume playing - only meaningful if using a network-based format
-     * (RTSP).
-     *)
-    read_play: function (c: PAVFormatContext): cint; cdecl;
-
-    (**
-     * Pause playing - only meaningful if using a network-based format
-     * (RTSP).
-     *)
-    read_pause: function (c: PAVFormatContext): cint; cdecl;
-
-    (**
-     * Seek to timestamp ts.
-     * Seeking will be done so that the point from which all active streams
-     * can be presented successfully will be closest to ts and within min/max_ts.
-     * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
-     *)
-    read_seek2: function (s:            PAVFormatContext;
-                          stream_index: cint;
-                          min_ts:       cint64;
-                          ts:           cint64;
-                          max_ts:       cint64;
-			  flags:        cint): cint; cdecl;
-
-    (**
-     * Returns device list with it properties.
-     * @see avdevice_list_devices() for more details.
-     *)
-    get_device_list: function(s: PAVFormatContext; device_list: PAVDeviceInfoList): cint; cdecl;
-
-    (**
-     * Initialize device capabilities submodule.
-     * @see avdevice_capabilities_create() for more details.
-     *)
-    create_device_capabilities: function(s: PAVFormatContext; caps: PAVDeviceCapabilitiesQuery): cint; cdecl;
-
-    (**
-     * Free device capabilities submodule.
-     * @see avdevice_capabilities_free() for more details.
-     *)
-    free_device_capabilities: function(s: PAVFormatContext; caps: PAVDeviceCapabilitiesQuery): cint; cdecl;
-
-  end;
-(**
- * @}
- *)
-
-  TAVStreamParseType = (
-    AVSTREAM_PARSE_NONE,
-    AVSTREAM_PARSE_FULL,       (**< full parsing and repack *)
-    AVSTREAM_PARSE_HEADERS,    (**< Only parse headers, do not repack. *)
-    AVSTREAM_PARSE_TIMESTAMPS, (**< full parsing and interpolation of timestamps for frames not starting on a packet boundary *)
-    AVSTREAM_PARSE_FULL_ONCE,  (**< full parsing and repack of the first frame only, only implemented for H.264 currently *)
-    AVSTREAM_PARSE_FULL_RAW    (**< full parsing and repack with timestamp and position generation by parser for raw
-                                    this assumes that each packet in the file contains no demuxer level headers and
-                                    just codec level data, otherwise position generation would fail *)
-  );
-
-  TAVIndexEntry = record
-    pos: cint64;
-    timestamp: cint64;        (**<
-                               * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
-                               * when seeking to this entry. That means preferable PTS on keyframe based formats.
-                               * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
-                               * is known
-                               *)
-     { Delphi doesn't support bitfields -> use flags_size instead
-    int flags:2;
-    int size:30; //Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).
-    }
-    flags_size: cint; // 0..1: flags, 2..31: size
-    min_distance: cint;         (**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. *)
-  end;
-
-  Tduration_error = array[0..1] of array[0..MAX_STD_TIMEBASES - 1] of cdouble;
-  PStreamInfo = ^TStreamInfo;
-  TStreamInfo = record
-    last_dts: cint64;
-    duration_gcd: cint64;
-    duration_count: cint;
-    rfps_duration_sum: cint64;
-    duration_error: ^Tduration_error;
-    codec_info_duration: cint64;
-    codec_info_duration_fields: cint64;
-    frame_delay_evidence: cint;
-
-    (**
-     * 0  -> decoder has not been searched for yet.
-     * >0 -> decoder found
-     * <0 -> decoder with codec_id == -found_decoder has not been found
-     *)
-    found_decoder: cint;
-
-    (**
-     * Those are used for average framerate estimation.
-     *)
-    fps_first_dts:     cint64;
-    fps_first_dts_idx: cint;
-    fps_last_dts:      cint64;
-    fps_last_dts_idx:  cint;
-  end;
-
- (**
-  * Stream structure.
-  * New fields can be added to the end with minor version bumps.
-  * Removal, reordering and changes to existing fields require a major
-  * version bump.
-  * sizeof(AVStream) must not be used outside libav*.
-  *)
-  TAVStream = record
-    index: cint;    (**< stream index in AVFormatContext *)
-    (**
-     * Format-specific stream ID.
-     * decoding: set by libavformat
-     * encoding: set by the user, replaced by libavformat if left unset
-     *)
-    id: cint;       (**< format-specific stream ID *)
-{$IFDEF FF_API_LAVF_AVCTX}
-    (**
-     * @deprecated use the codecpar struct instead
-     *)
-    codec: PAVCodecContext; {deprecated}
-{$ENDIF}
-    priv_data: pointer;
-
-    (**
-     * This is the fundamental unit of time (in seconds) in terms
-     * of which frame timestamps are represented.
-     *
-     * decoding: set by libavformat
-     * encoding: May be set by the caller before avformat_write_header() to
-     *           provide a hint to the muxer about the desired timebase. In
-     *           avformat_write_header(), the muxer will overwrite this field
-     *           with the timebase that will actually be used for the timestamps
-     *           written into the file (which may or may not be related to the
-     *           user-provided one, depending on the format).
-     *)
-    time_base: TAVRational;
-
-    (**
-     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
-     * Only set this if you are absolutely 100% sure that the value you set
-     * it to really is the pts of the first frame.
-     * This may be undefined (AV_NOPTS_VALUE).
-     * @note The ASF header does NOT contain a correct start_time the ASF
-     * demuxer must NOT set this.
-     *)
-    start_time: cint64;
-
-    (**
-     * Decoding: duration of the stream, in stream time base.
-     * If a source file does not specify a duration, but does specify
-     * a bitrate, this value will be estimated from bitrate and file size.
-     *
-     * Encoding: May be set by the caller before avformat_write_header() to
-     * provide a hint to the muxer about the estimated duration.
-     *)
-    duration: cint64;
-
-    nb_frames: cint64;                 ///< number of frames in this stream if known or 0
-
-    disposition: cint; (**< AV_DISPOSITION_* bitfield *)
-
-    discard: TAVDiscard; ///< Selects which packets can be discarded at will and do not need to be demuxed.
-
-    (**
-     * sample aspect ratio (0 if unknown)
-     * - encoding: Set by user.
-     * - decoding: Set by libavformat.
-     *)
-    sample_aspect_ratio: TAVRational;
-
-    metadata: PAVDictionary;
-
-    (**
-     * Average framerate
-     *
-     * - demuxing: May be set by libavformat when creating the stream or in
-     *             avformat_find_stream_info().
-     * - muxing: May be set by the caller before avformat_write_header().
-     *)
-    avg_frame_rate: TAVRational;
-
-    (**
-     * For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
-     * will contain the attached picture.
-     *
-     * decoding: set by libavformat, must not be modified by the caller.
-     * encoding: unused
-     *)
-     attached_pic: TAVPacket;
-
-    (**
-     * An array of side data that applies to the whole stream (i.e. the
-     * container does not allow it to change between packets).
-     *
-     * There may be no overlap between the side data in this array and side data
-     * in the packets. I.e. a given side data is either exported by the muxer
-     * (demuxing) / set by the caller (muxing) in this array, then it never
-     * appears in the packets, or the side data is exported / sent through
-     * the packets (always in the first packet where the value becomes known or
-     * changes), then it does not appear in this array.
-     *
-     * - demuxing: Set by libavformat when the stream is created.
-     * - muxing: May be set by the caller before avformat_write_header().
-     *
-     * Freed by libavformat in avformat_free_context().
-     *
-     * @see av_format_inject_global_side_data()
-     *)
-    side_data: PAVPacketSideData;
-
-    (**
-     * The number of elements in the AVStream.side_data array.
-     *)
-    nb_side_data: cint;
-
-    (**
-     * Flags for the user to detect events happening on the stream. Flags must
-     * be cleared by the user once the event has been handled.
-     * A combination of AVSTREAM_EVENT_FLAG_*.
-     *)
-    event_flags: cint;
-
-    (**
-     * Real base framerate of the stream.
-     * This is the lowest framerate with which all timestamps can be
-     * represented accurately (it is the least common multiple of all
-     * framerates in the stream). Note, this value is just a guess!
-     * For example, if the time base is 1/90000 and all frames have either
-     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
-     *)
-    r_frame_rate: TAVRational;
-
-{$IFDEF FF_API_LAVF_FFSERVER}
-    (**
-     * String containing pairs of key and values describing recommended encoder configuration.
-     * Pairs are separated by ','.
-     * Keys are separated from values by '='.
-     *
-     * @deprecated unused
-     *)
-    recommended_encoder_configuration: PAnsichar; {deprecated}
-{$ENDIF}
-
-    (**
-     * Codec parameters associated with this stream. Allocated and freed by
-     * libavformat in avformat_new_stream() and avformat_free_context()
-     * respectively.
-     *
-     * - demuxing: filled by libavformat on stream creation or in
-     *             avformat_find_stream_info()
-     * - muxing: filled by the caller before avformat_write_header()
-     *)
-    codecpar: PAVCodecParameters;
-
-    (*****************************************************************
-     * All fields below this line are not part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * Internal note: be aware that physically removing these fields
-     * will break ABI. Replace removed fields with dummy fields, and
-     * add new fields to AVStreamInternal.
-    *****************************************************************
-     *)
-
-    (**
-     * Stream information used internally by avformat_find_stream_info()
-     *)
-    info: PStreamInfo;
-
-    pts_wrap_bits: cint; (**< number of bits in pts (used for wrapping control) *)
-
-    // Timestamp generation support:
-    (**
-     * Timestamp corresponding to the last dts sync point.
-     *
-     * Initialized when AVCodecParserContext.dts_sync_point >= 0 and
-     * a DTS is received from the underlying container. Otherwise set to
-     * AV_NOPTS_VALUE by default.
-     *)
-    first_dts: cint64;
-    cur_dts: cint64;
-    last_IP_pts: cint64;
-    last_IP_duration: cint;
-
-    (**
-     * Number of packets to buffer for codec probing
-     *)
-    probe_packets: cint;
-
-     (**
-     * Number of frames that have been demuxed during avformat_find_stream_info()
-     *)
-    codec_info_nb_frames: cint;
-
-    (* av_read_frame() support *)
-    need_parsing: TAVStreamParseType;
-    parser: PAVCodecParserContext;
-
-    (**
-     * last packet in packet_buffer for this stream when muxing.
-     *)
-    last_in_packet_buffer: PAVPacketList;
-    probe_data: TAVProbeData;
-    pts_buffer: array [0..MAX_REORDER_DELAY] of cint64;
-
-    index_entries: PAVIndexEntry; (**< Only used if the format does not
-                                    support seeking natively. *)
-    nb_index_entries: cint;
-    index_entries_allocated_size: cuint;
-
-    (**
-     * Stream Identifier
-     * This is the MPEG-TS stream identifier +1
-     * 0 means unknown
-     *)
-    stream_identifier: cint;
-
-    interleaver_chunk_size: cint64;
-    interleaver_chunk_duration: cint64;
-
-    (**
-     * stream probing state
-     * -1   -> probing finished
-     *  0   -> no probing requested
-     * rest -> perform probing with request_probe being the minimum score to accept.
-     * NOT PART OF PUBLIC API
-     *)
-    request_probe: cint;
-    (**
-     * Indicates that everything up to the next keyframe
-     * should be discarded.
-     *)
-    skip_to_keyframe: cint;
-
-    (**
-     * Number of samples to skip at the start of the frame decoded from the next packet.
-     *)
-    skip_samples: cint;
-
-    (**
-     * If not 0, the number of samples that should be skipped from the start of
-     * the stream (the samples are removed from packets with pts==0, which also
-     * assumes negative timestamps do not happen).
-     * Intended for use with formats such as mp3 with ad-hoc gapless audio
-     * support.
-     *)
-    start_skip_samples: cint64;
-
-    (**
-     * If not 0, the first audio sample that should be discarded from the stream.
-     * This is broken by design (needs global sample count), but can't be
-     * avoided for broken by design formats such as mp3 with ad-hoc gapless
-     * audio support.
-     *)
-    first_discard_sample: cint64;
-
-    (**
-     * The sample after last sample that is intended to be discarded after
-     * first_discard_sample. Works on frame boundaries only. Used to prevent
-     * early EOF if the gapless info is broken (considered concatenated mp3s).
-     *)
-    last_discard_sample: cint64;
-
-    (**
-     * Number of internally decoded frames, used internally in libavformat, do not access
-     * its lifetime differs from info which is why it is not in that structure.
-     *)
-    nb_decoded_frames: cint;
-
-    (**
-     * Timestamp offset added to timestamps before muxing
-     * NOT PART OF PUBLIC API
-     *)
-    mux_ts_offset: cint64;
-
-    (**
-     * Internal data to check for wrapping of the time stamp
-     *)
-    pts_wrap_reference: cint64;
-
-    (**
-     * Options for behavior, when a wrap is detected.
-     *
-     * Defined by AV_PTS_WRAP_ values.
-     *
-     * If correction is enabled, there are two possibilities:
-     * If the first time stamp is near the wrap point, the wrap offset
-     * will be subtracted, which will create negative time stamps.
-     * Otherwise the offset will be added.
-     *)
-    pts_wrap_behavior: cint;
-
-    (**
-     * Internal data to prevent doing update_initial_durations() twice
-     *)
-    update_initial_durations_done: cint;
-
-    (**
-     * Internal data to generate dts from pts
-     *)
-    pts_reorder_error: array[0..MAX_REORDER_DELAY] of cint64;
-    pts_reorder_error_count: array[0..MAX_REORDER_DELAY] of byte;
-
-    (**
-     * Internal data to analyze DTS and detect faulty mpeg streams
-     *)
-    last_dts_for_order_check: cint64;
-    dts_ordered: byte;
-    dts_misordered: byte;
-
-		(**
-     * Internal data to inject global side data
-     *)
-    inject_global_side_data: cint;
-
-    (**
-     * display aspect ratio (0 if unknown)
-     * - encoding: unused
-     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally
-     *)
-    display_aspect_ratio: TAVRational;
-
-    (**
-     * An opaque field for libavformat internal usage.
-     * Must not be accessed in any way by callers.
-     *)
-    internal: pointer;
-  end; (** TAVStream **)
-
-(**
- * New fields can be added to the end with minor version bumps.
- * Removal, reordering and changes to existing fields require a major
- * version bump.
- * sizeof(AVProgram) must not be used outside libav*.
- *)
-  TAVProgram = record
-    id: cint;
-    flags: cint;
-    discard: TAVDiscard;        ///< selects which program to discard and which to feed to the caller
-    stream_index: Pcuint;
-    nb_stream_indexes: cuint;
-    metadata: PAVDictionary;
-
-    program_num: cint;
-    pmt_pid: cint;
-    pcr_pid: cint;
-
-    (*****************************************************************
-     * All fields below this line are not part of the public API. They
-     * may not be used outside of libavformat and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     *)
-   start_time: cint64;
-   end_time: cint64;
-
-   pts_wrap_reference: cint64;    ///< reference dts for wrap detection
-   pts_wrap_behavior: cint;       ///< behavior on wrap detection
-  end; (*AVProgram*)
-
-  PAVChapter = ^TAVChapter;
-  TAVChapter = record
-    id: cint;                 ///< unique ID to identify the chapter
-    time_base: TAVRational;   ///< time base in which the start/end timestamps are specified
-    start, end_: cint64;     ///< chapter start/end time in time_base units
-    metadata: PAVDictionary;
-  end; (*AVChapter*)
-
-  TAVChapterArray = array[0..(MaxInt div SizeOf(TAVChapter))-1] of TAVChapter;
-  PAVChapterArray = ^TAVChapterArray;
-
-  (**
-   * The duration of a video can be estimated through various ways, and this enum can be used
-   * to know how the duration was estimated.
-   *)
-  TAVDurationEstimationMethod = (
-    AVFMT_DURATION_FROM_PTS,    ///< Duration accurately estimated from PTSes
-    AVFMT_DURATION_FROM_STREAM, ///< Duration estimated from a stream with a known duration
-    AVFMT_DURATION_FROM_BITRATE ///< Duration estimated from bitrate (less accurate)
-    );
-
-  PAVFormatInternal = ^TAVFormatInternal;
-  TAVFormatInternal = record
-    (**
-     * Number of streams relevant for interleaving.
-     * Muxing only.
-     *)
-    nb_interleaved_streams: cint;
-    inject_global_side_data: cint;
+    next: ^TAVPacketList;
   end;
-
-  TAv_format_control_message = function (s: PAVFormatContext; type_: cint;
-				  data: pointer; data_size: size_t): cint; cdecl;
-
-  TAVOpenCallback = function (s: PAVFormatContext; pb: PPAVIOContext; url: {const} PAnsiChar; flags: cint;
-                              int_cb: {const} PAVIOInterruptCB; options: PPAVDictionary): cint; cdecl;
-
- (**
-  * Format I/O context.
-  * New fields can be added to the end with minor version bumps.
-  * Removal, reordering and changes to existing fields require a major
-  * version bump.
-  * sizeof(AVFormatContext) must not be used outside libav*, use
-  * avformat_alloc_context() to create an AVFormatContext.
-  *
-  * Fields can be accessed through AVOptions (av_opt* ),
-  * the name string used matches the associated command line parameter name and
-  * can be found in libavformat/options_table.h.
-  * The AVOption/command line parameter names differ in some cases from the C
-  * structure field names for historic reasons or brevity.
-  *)
+  PAVInputFormat = ^TAVInputFormat;
+  PAVStream = ^TAVStream;
+  PPAVStream = ^PAVStream;
+  PAVFormatContext = ^TAVFormatContext;
+  PPAVFormatContext = ^PAVFormatContext;
   TAVFormatContext = record
-    (**
-     * A class for logging and @ref avoptions. Set by avformat_alloc_context().
-     * Exports (de)muxer private options if they exist.
-     *)
-    av_class: PAVClass; (**< Set by avformat_alloc_context. *)
-
-    (**
-     * The input container format.
-     *
-     * Demuxing only, set by avformat_open_input().
-     *)
+    we_do_not_use_av_class: pointer;
     iformat: PAVInputFormat;
-
-    (**
-     * The output container format.
-     *
-     * Muxing only, must be set by the caller before avformat_write_header().
-     *)
-    oformat: PAVOutputFormat;
-
-    (**
-     * Format private data. This is an AVOptions-enabled struct
-     * if and only if iformat/oformat.priv_class is not NULL.
-     *
-     * - muxing: set by avformat_write_header()
-     * - demuxing: set by avformat_open_input()
-     *)
-    priv_data: pointer;
-
-    (*
-     * I/O context.
-     *
-     * - demuxing: either set by the user before avformat_open_input() (then
-     *             the user must close it manually) or set by avformat_open_input().
-     * - muxing: set by the user before avformat_write_header(). The caller must
-     *           take care of closing / freeing the IO context.
-     *
-     * Do NOT set this field if AVFMT_NOFILE flag is set in
-     * iformat/oformat.flags. In such a case, the (de)muxer will handle
-     * I/O in some other way and this field will be NULL.
-     *)
-     pb: PAVIOContext;
-
-    (* stream info *)
-    (**
-     * Flags signalling stream properties. A combination of AVFMTCTX_*.
-     * Set by libavformat.
-     *)
-    ctx_flags: cint;
-
-    (**
-     * Number of elements in AVFormatContext.streams.
-     *
-     * Set by avformat_new_stream(), must not be modified by any other code.
-     *)
+    we_do_not_use_oformat: pointer;
+    we_do_not_use_priv_data: pointer;
+    pb: ^TAVIOContext;
+    we_do_not_use_ctx_flags: cint;
     nb_streams: cuint;
-
-    (**
-     * A list of all streams in the file. New streams are created with
-     * avformat_new_stream().
-     *
-     * - demuxing: streams are created by libavformat in avformat_open_input().
-     *             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
-     *             appear in av_read_frame().
-     * - muxing: streams are created by the user before avformat_write_header().
-     *
-     * Freed by libavformat in avformat_free_context().
-     *)
     streams: PPAVStream;
-
-{$IFDEF FF_API_FORMAT_FILENAME}
-    (**
-     * input or output filename
-     *
-     * - demuxing: set by avformat_open_input()
-     * - muxing: may be set by the caller before avformat_write_header()
-     *
-     * @deprecated Use url instead.
-     *)
-    filename: array [0..1023] of AnsiChar; {deprecated} (* input or output filename *)
-{$ENDIF}
-
-    (**
-     * input or output URL. Unlike the old filename field, this field has no
-     * length restriction.
-     *
-     * - demuxing: set by avformat_open_input(), initialized to an empty
-     *             string if url parameter was NULL in avformat_open_input().
-     * - muxing: may be set by the caller before calling avformat_write_header()
-     *           (or avformat_init_output() if that is called first) to a string
-     *           which is freeable by av_free(). Set to an empty string if it
-     *           was NULL in avformat_init_output().
-     *
-     * Freed by libavformat in avformat_free_context().
-     *)
-    url: PAnsichar;
-
-    (**
-     * Position of the first frame of the component, in
-     * AV_TIME_BASE fractional seconds. NEVER set this value directly:
-     * It is deduced from the AVStream values.
-     *
-     * Demuxing only, set by libavformat.
-     *)
+    filename: array [0..1023] of AnsiChar; 
+    url: ^AnsiChar;
     start_time: cint64;
-    (**
-     * Duration of the stream, in AV_TIME_BASE fractional
-     * seconds. Only set this value if you know none of the individual stream
-     * durations and also dont set any of them. This is deduced from the
-     * AVStream values if not set.
-     *)
     duration: cint64;
-
-    (**
-     * Total stream bitrate in bit/s, 0 if not
-     * available. Never set it directly if the file_size and the
-     * duration are known as ffmpeg can compute it automatically.
-     *)
-    bit_rate: cint64;
-
-    packet_size: cuint;
-    max_delay: cint;
-
-    (**
-     * Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
-     * Set by the user before avformat_open_input() / avformat_write_header().
-     *)
+    we_do_not_use_bit_rate: cint64;
+    we_do_not_use_packet_size: cuint;
+    we_do_not_use_max_delay: cint;
     flags: cint;
-
-    (**
-     * Maximum size of the data read from input for determining
-     * the input container format.
-     * Demuxing only, set by the caller before avformat_open_input().
-     *)
-    probesize: cint64;
-
-    (**
-     * Maximum duration (in AV_TIME_BASE units) of the data read
-     * from input in avformat_find_stream_info().
-     * Demuxing only, set by the caller before avformat_find_stream_info().
-     * Can be set to 0 to let avformat choose using a heuristic.
-     *)
-    max_analyze_duration: cint64;
-
-    key: pbyte;
-    keylen: cint;
-
-    nb_programs: cuint;
-    programs: PPAVProgram;
-
-    (**
-     * Forced video codec_id.
-     * Demuxing: Set by user.
-     *)
-    video_codec_id: TAVCodecID;
-
-    (**
-     * Forced audio codec_id.
-     * Demuxing: Set by user.
-     *)
-    audio_codec_id: TAVCodecID;
-
-    (**
-     * Forced subtitle codec_id.
-     * Demuxing: Set by user.
-     *)
-    subtitle_codec_id: TAVCodecID;
-
-    (**
-     * Maximum amount of memory in bytes to use for the index of each stream.
-     * If the index exceeds this size, entries will be discarded as
-     * needed to maintain a smaller size. This can lead to slower or less
-     * accurate seeking (depends on demuxer).
-     * Demuxers for which a full in-memory index is mandatory will ignore
-     * this.
-     * - muxing: unused
-     * - demuxing: set by user
-     *)
-    max_index_size: cuint;
-
-    (**
-     * Maximum amount of memory in bytes to use for buffering frames
-     * obtained from realtime capture devices.
-     *)
-    max_picture_buffer: cuint;
-
-    nb_chapters: cuint;
-    chapters: PAVChapterArray;
-
-    (**
-     * Metadata that applies to the whole file.
-     *
-     * - demuxing: set by libavformat in avformat_open_input()
-     * - muxing: may be set by the caller before avformat_write_header()
-     *
-     * Freed by libavformat in avformat_free_context().
-     *)
-    metadata: PAVDictionary;
-
-    (**
-     * Start time of the stream in real world time, in microseconds
-     * since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
-     * stream was captured at this real world time.
-     * - muxing: Set by the caller before avformat_write_header(). If set to
-     *           either 0 or AV_NOPTS_VALUE, then the current wall-time will
-     *           be used.
-     * - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
-     *             the value may become known after some number of frames
-     *             have been received.
-     *)
-    start_time_realtime: cint64;
-
-    (**
-     * The number of frames used for determining the framerate in
-     * avformat_find_stream_info().
-     * Demuxing only, set by the caller before avformat_find_stream_info().
-     *)
-    fps_probe_size: cint;
-
-    (**
-     * Error recognition; higher values will detect more errors but may
-     * misdetect some more or less valid parts as errors.
-     * Demuxing only, set by the caller before avformat_open_input().
-     *)
-    error_recognition: cint;
-
-    (**
-     * Custom interrupt callbacks for the I/O layer.
-     *
-     * demuxing: set by the user before avformat_open_input().
-     * muxing: set by the user before avformat_write_header()
-     * (mainly useful for AVFMT_NOFILE formats). The callback
-     * should also be passed to avio_open2() if it's used to
-     * open the file.
-     *)
-    interrupt_callback: TAVIOInterruptCB;
-
-    (**
-     * Flags to enable debugging.
-     *)
-    debug: cint;
-
-    (**
-     * Maximum buffering duration for interleaving.
-     *
-     * To ensure all the streams are interleaved correctly,
-     * av_interleaved_write_frame() will wait until it has at least one packet
-     * for each stream before actually writing any packets to the output file.
-     * When some streams are "sparse" (i.e. there are large gaps between
-     * successive packets), this can result in excessive buffering.
-     *
-     * This field specifies the maximum difference between the timestamps of the
-     * first and the last packet in the muxing queue, above which libavformat
-     * will output a packet regardless of whether it has queued a packet for all
-     * the streams.
-     *
-     * Muxing only, set by the caller before avformat_write_header().
-     *)
-    max_interleave_delta: cint64;
-
-    (**
-     * Allow non-standard and experimental extension
-     * @see AVCodecContext.strict_std_compliance
-     *)
-    strict_std_compliance: cint;
-
-    (**
-     * Flags for the user to detect events happening on the file. Flags must
-     * be cleared by the user once the event has been handled.
-     * A combination of AVFMT_EVENT_FLAG_*.
-     *)
-    event_flags: cint;
-
-    (**
-     * Maximum number of packets to read while waiting for the first timestamp.
-     * Decoding only.
-     *)
-    max_ts_probe: cint;
-
-    (**
-     * Avoid negative timestamps during muxing.
-     * Any value of the AVFMT_AVOID_NEG_TS_* constants.
-     * Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)
-     * - muxing: Set by user
-     * - demuxing: unused
-     *)
-    avoid_negative_ts: cint;
-
-    (**
-     * Transport stream id.
-     * This will be moved into demuxer private options. Thus no API/ABI compatibility
-     *)
-    ts_id: cint;
-
-    (**
-     * Audio preload in microseconds.
-     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
-     * - encoding: Set by user
-     * - decoding: unused
-     *)
-    audio_preload: cint;
-
-    (**
-     * Max chunk time in microseconds.
-     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
-     * - encoding: Set by user
-     * - decoding: unused
-     *)
-    max_chunk_duration: cint;
-
-    (**
-     * Max chunk size in bytes
-     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
-     * - encoding: Set by user
-     * - decoding: unused
-     *)
-    max_chunk_size: cint;
-
-    (**
-     * forces the use of wallclock timestamps as pts/dts of packets
-     * This has undefined results in the presence of B frames.
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    use_wallclock_as_timestamps: cint;
-
-    (**
-     * avio flags, used to force AVIO_FLAG_DIRECT.
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    avio_flags: cint;
-
-    (**
-     * The duration field can be estimated through various ways, and this field can be used
-     * to know how the duration was estimated.
-     * - encoding: unused
-     * - decoding: Read by user
-     *)
-    duration_estimation_method: TAVDurationEstimationMethod;
-
-    (**
-     * Skip initial bytes when opening stream
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    skip_initial_bytes: cint64;
-
-    (**
-     * Correct single timestamp overflows
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    correct_ts_overflow: cuint;
-
-    (**
-     * Force seeking to any (also non key) frames.
-     * - encoding: unused
-     * - decoding: Set by user
-     *)
-    seek2any: cint;
-
-    (**
-     * Flush the I/O context after each packet.
-     * - encoding: Set by user
-     * - decoding: unused
-     *)
-    flush_packets: cint;
-
-    (**
-     * format probing score.
-     * The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
-     * the format.
-     * - encoding: unused
-     * - decoding: set by avformat, read by user
-     *)
-    probe_score: cint;
-
-    (**
-     * number of bytes to read maximally to identify format.
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    format_probesize: cint;
-
-    (**
-     * ',' separated list of allowed decoders.
-     * If NULL then all are allowed
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    codec_whitelist: PAnsiChar;
-
-    (**
-     * ',' separated list of allowed demuxers.
-     * If NULL then all are allowed
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    format_whitelist: PAnsiChar;
-
-
-    (**
-     * An opaque field for libavformat internal usage.
-     * Must not be accessed in any way by callers.
-     *)
-    internal: PAVFormatInternal;
-
-    (**
-     * IO repositioned flag.
-     * This is set by avformat when the underlaying IO context read pointer
-     * is repositioned, for example when doing byte based seeking.
-     * Demuxers can use the flag to detect such changes.
-     *)
-    io_repositioned: cint;
-
-    (**
-     * Forced video codec.
-     * This allows forcing a specific decoder, even when there are multiple with
-     * the same codec_id.
-     * Demuxing: Set by user
-     *)
-    video_codec: PAVCodec;
-
-    (**
-     * Forced audio codec.
-     * This allows forcing a specific decoder, even when there are multiple with
-     * the same codec_id.
-     * Demuxing: Set by user
-     *)
-    audio_codec: PAVCodec;
-
-    (**
-     * Forced subtitle codec.
-     * This allows forcing a specific decoder, even when there are multiple with
-     * the same codec_id.
-     * Demuxing: Set by user
-     *)
-    subtitle_codec: PAVCodec;
-
-    (**
-     * Forced data codec.
-     * This allows forcing a specific decoder, even when there are multiple with
-     * the same codec_id.
-     * Demuxing: Set by user
-     *)
-    data_codec: PAVCodec;
-
-    (**
-     * Number of bytes to be written as padding in a metadata header.
-     * Demuxing: Unused.
-     * Muxing: Set by user via av_format_set_metadata_header_padding.
-     *)
-    metadata_header_padding: cint;
-
-    (**
-     * User data.
-     * This is a place for some private data of the user.
-     *)
-    opaque: pointer;
-
-    (**
-     * Callback used by devices to communicate with application.
-     *)
-    control_message_cb: TAv_format_control_message;
-
-    (**
-     * Output timestamp offset, in microseconds.
-     * Muxing: set by user
-     *)
-    output_ts_offset: cint64;
-
-    (**
-     * dump format separator.
-     * can be ", " or "\n      " or anything else
-     * - muxing: Set by user.
-     * - demuxing: Set by user.
-     *)
-    dump_separator: Pcuint8;
-
-    (**
-     * Forced Data codec_id.
-     * Demuxing: Set by user.
-     *)
-    data_codec_id: TAVCodecID;
-{$IFDEF FF_API_OLD_OPEN_CALLBACKS}
-    (**
-     * Called to open further IO contexts when needed for demuxing.
-     *
-     * This can be set by the user application to perform security checks on
-     * the URLs before opening them.
-     * The function should behave like avio_open2(), AVFormatContext is provided
-     * as contextual information and to reach AVFormatContext.opaque.
-     *
-     * If NULL then some simple checks are used together with avio_open2().
-     *
-     * Must not be accessed directly from outside avformat.
-     * @See av_format_set_open_cb()
-     *
-     * Demuxing: Set by user.
-     *
-     * @deprecated Use io_open and io_close.
-     *)
-    open_cb: function(s: PAVFormatContext; p: PPAVIOContext; url: {const} PAnsiChar; flags: cint; int_cb: {const} PAVIOInterruptCB; options: PPAVDictionary): cint; cdecl;  {deprecated}
-{$ENDIF}
-
-    (**
-     * ',' separated list of allowed protocols.
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    protocol_whitelist: pchar;
-
-    (*
-     * A callback for opening new IO streams.
-     *
-     * Whenever a muxer or a demuxer needs to open an IO stream (typically from
-     * avformat_open_input() for demuxers, but for certain formats can happen at
-     * other times as well), it will call this callback to obtain an IO context.
-     *
-     * @param s the format context
-     * @param pb on success, the newly opened IO context should be returned here
-     * @param url the url to open
-     * @param flags a combination of AVIO_FLAG_*
-     * @param options a dictionary of additional options, with the same
-     *                semantics as in avio_open2()
-     * @return 0 on success, a negative AVERROR code on failure
-     *
-     * @note Certain muxers and demuxers do nesting, i.e. they open one or more
-     * additional internal format contexts. Thus the AVFormatContext pointer
-     * passed to this callback may be different from the one facing the caller.
-     * It will, however, have the same 'opaque' field.
-     *)
-    io_open: function(s: PAVFormatContext; pb: PPAVIOContext; url: {const} pchar;
-		      flags: cint; options: PPAVDictionary): cint; cdecl;
-
-    (**
-     * A callback for closing the streams opened with AVFormatContext.io_open().
-     *)
-    io_close: procedure(s: PAVFormatContext; pb: PAVIOContext); cdecl;
-
-    (**
-     * ',' separated list of disallowed protocols.
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    protocol_blacklist: PAnsiChar;
-
-    (**
-     * The maximum number of streams.
-     * - encoding: unused
-     * - decoding: set by user
-     *)
-    max_streams: cint;
-  end; (** TAVFormatContext **)
-
-  TAVTimebaseSource = (
-      AVFMT_TBCF_AUTO = -1,
-      AVFMT_TBCF_DECODER,
-      AVFMT_TBCF_DEMUXER,
-{$IFDEF FF_API_R_FRAME_RATE}
-      AVFMT_TBCF_R_FRAMERATE
-{$ENDIF}
-  );
-
-{$IFDEF FF_API_FORMAT_GET_SET}
-(**
- * Accessors for some AVFormatContext fields. These used to be provided for ABI
- * compatibility, and do not need to be used anymore.
- *)
-function av_format_get_probe_score(s: {const} PAVFormatContext): cint;
-  cdecl; external av__format; deprecated;
-function av_format_get_video_codec(s: {const} PAVFormatContext): PAVCodec;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_video_codec(s: PAVFormatContext; c: PAVCodec);
-  cdecl; external av__format; deprecated;
-function av_format_get_audio_codec(s: {const} PAVFormatContext): PAVCodec;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_audio_codec(s: PAVFormatContext; c: PAVCodec);
-  cdecl; external av__format; deprecated;
-function av_format_get_subtitle_codec(s: {const} PAVFormatContext): PAVCodec;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_subtitle_codec(s: PAVFormatContext; c: PAVCodec);
-  cdecl; external av__format; deprecated;
-function av_format_get_data_codec(s: {const} PAVFormatContext): PAVCodec;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_data_codec(s: PAVFormatContext; c: PAVCodec);
-  cdecl; external av__format; deprecated;
-function av_format_get_metadata_header_padding(s: {const} PAVFormatContext): cint;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_metadata_header_padding(s: PAVFormatContext; c: cint);
-  cdecl; external av__format; deprecated;
-procedure av_format_get_opaque(s: {const} PAVFormatContext);
-  cdecl; external av__format; deprecated;
-procedure av_format_set_opaque(s: PAVFormatContext; opaque: pointer);
-  cdecl; external av__format; deprecated;
-function av_format_get_control_message_cb(s: {const} PAVFormatContext): TAv_format_control_message;
-  cdecl; external av__format; deprecated;
-procedure av_format_set_control_message_cb(s: PAVFormatContext; callback: TAv_format_control_message);
-  cdecl; external av__format; deprecated;
-{$IFDEF FF_API_OLD_OPEN_CALLBACKS}
-function av_format_get_open_cb(s: {const} PAVFormatContext): TAVOpenCallback; {deprecated}
-  cdecl; external av__format; deprecated;
-procedure av_format_set_open_cb(s: PAVFormatContext; callback: TAVOpenCallback); {deprecated}
-  cdecl; external av__format; deprecated;
-{$ENDIF} {FF_API_OLD_OPEN_CALLBACKS}
-{$ENDIF} {FF_API_FORMAT_GET_SET}
-
-(**
- * This function will cause global side data to be injected in the next packet
- * of each stream as well as after any subsequent seek.
- *)
-procedure av_format_inject_global_side_data(s: PAVFormatContext);
-  cdecl; external av__format;
-
-(**
- * Returns the method used to set ctx->duration.
- *
- * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
- *)
-function av_fmt_ctx_get_duration_estimation_method(ctx: {const} PAVFormatContext): TAVDurationEstimationMethod;
-  cdecl; external av__format;
-
-{$IFDEF FF_API_FORMAT_GET_SET}
-(**
- * Accessors for some AVStream fields. These used to be provided for ABI
- * compatibility, and do not need to be used anymore.
- *)
-function  av_stream_get_r_frame_rate({const} s: PAVStream): TAVRational;
-  cdecl; external av__format; deprecated;
-procedure av_stream_set_r_frame_rate(s: PAVStream; r: TAVRational);
-  cdecl; external av__format; deprecated;
-{$IFDEF FF_API_LAVF_FFSERVER}
-function av_stream_get_recommended_encoder_configuration({const} s: PAVStream): PAnsiChar;
-  cdecl; external av__format; deprecated;
-procedure av_stream_set_recommended_encoder_configuration(s: PAVStream; configuration: PAnsiChar);
-  cdecl; external av__format; deprecated;
-{$ENDIF} {FF_API_LAVF_FFSERVER}
-{$ENDIF} {FF_API_FORMAT_GET_SET}
-
-function av_stream_get_parser(s: {const} PAVStream): PAVCodecParserContext;
-  cdecl; external av__format;
-
-(**
- * Returns the pts of the last muxed packet + its duration
- *
- * the retuned value is undefined when used with a demuxer.
- *)
-function av_stream_get_end_pts(st: {const} PAVStream): cint64;
-  cdecl; external av__format;
-
-(**
- * @defgroup lavf_core Core functions
- * @ingroup libavf
- *
- * Functions for querying libavformat capabilities, allocating core structures,
- * etc.
- * @
- *)
-
-(**
- * Return the LIBAVFORMAT_VERSION_INT constant.
- *)
-function avformat_version(): cuint;
-  cdecl; external av__format;
-
-(**
- * Return the libavformat build-time configuration.
- *)
-function avformat_configuration(): {const} PansiChar;
-  cdecl; external av__format;
-
-(**
- * Return the libavformat license.
- *)
-function avformat_license(): {const} PansiChar;
-  cdecl; external av__format;
-
-{$IFDEF FF_API_NEXT}
-(**
- * Initialize libavformat and register all the muxers, demuxers and
- * protocols. If you do not call this function, then you can select
- * exactly which formats you want to support.
- *
- * @see av_register_input_format()
- * @see av_register_output_format()
- * @see av_register_protocol()
- *)
-procedure av_register_all();
-  cdecl; external av__format; deprecated;
-
-procedure av_register_input_format(format: PAVInputFormat);
-  cdecl; external av__format; deprecated;
-procedure av_register_output_format(format: PAVOutputFormat);
-  cdecl; external av__format; deprecated;
-{$ENDIF}
-
-(**
- * Do global initialization of network libraries. This is optional,
- * and not recommended anymore.
- *
- * This functions only exists to work around thread-safety issues
- * with older GnuTLS or OpenSSL libraries. If libavformat is linked
- * to newer versions of those libraries, or if you do not use them,
- * calling this function is unnecessary. Otherwise, you need to call
- * this function before any other threads using them are started.
- *
- * This function will be deprecated once support for older GnuTLS and
- * OpenSSL libraries is removed, and this function has no purpose
- * anymore.
- *)
-function avformat_network_init(): cint;
-  cdecl; external av__format;
-
-(**
- * Undo the initialization done by avformat_network_init. Call it only
- * once for each time you called avformat_network_init.
- *)
-function avformat_network_deinit(): cint;
-  cdecl; external av__format;
-
-{$IFDEF FF_API_NEXT}
-(**
- * If f is NULL, returns the first registered input format,
- * if f is non-NULL, returns the next registered input format after f
- * or NULL if f is the last one.
- *)
-function av_iformat_next(f: {const} PAVInputFormat): PAVInputFormat;
-    cdecl; external av__format; deprecated;
-
-(**
- * If f is NULL, returns the first registered output format,
- * if f is non-NULL, returns the next registered input format after f
- * or NULL if f is the last one.
- *)
-function av_oformat_next(f: {const} PAVOutputFormat): PAVOutputFormat;
-    cdecl; external av__format; deprecated;
-{$ENDIF}
-
-(**
- * Iterate over all registered muxers.
- *
- * @param opaque a pointer where libavformat will store the iteration state. Must
- *               point to NULL to start the iteration.
- *
- * @return the next registered muxer or NULL when the iteration is
- *         finished
- *)
-function av_muxer_iterate(opaque: pointer): PAVOutputFormat;
-    cdecl; external av__format; deprecated; {const}
-
-(**
- * Iterate over all registered demuxers.
- *
- * @param opaque a pointer where libavformat will store the iteration state. Must
- *               point to NULL to start the iteration.
- *
- * @return the next registered demuxer or NULL when the iteration is
- *         finished
- *)
-function av_demuxer_iterate(opaque: pointer): PAVInputFormat;
-    cdecl; external av__format; deprecated; {const}
-
-(**
- * Allocate an AVFormatContext.
- * Can be freed with av_free() but do not forget to free everything you
- * explicitly allocated as well!
- *)
-function avformat_alloc_context(): PAVFormatContext;
-  cdecl; external av__format;
-
-(**
- * Free an AVFormatContext and all its streams.
- * @param s context to free
- *)
-procedure avformat_free_context(s: PAVFormatContext);
-  cdecl; external av__format;
-
-(**
- * Get the AVClass for AVFormatContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function avformat_get_class(): {const} PAVClass;
-  cdecl; external av__format;
-
-(**
- * Add a new stream to a media file.
- *
- * When demuxing, it is called by the demuxer in read_header(). If the
- * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
- * be called in read_packet().
- *
- * When muxing, should be called by the user before avformat_write_header().
- *
- * User is required to call avcodec_close() and avformat_free_context() to
- * clean up the allocation by avformat_new_stream().
- *
- * @param s media file handle
- * @param c If non-NULL, the AVCodecContext corresponding to the new stream
- * will be initialized to use this codec. This is needed for e.g. codec-specific
- * defaults to be set, so codec should be provided if it is known.
- *
- * @return newly created stream or NULL on error.
- *)
-function avformat_new_stream(s: PAVFormatContext; c: {const} PAVCodec): PAVStream;
-  cdecl; external av__format;
-
-(**
- * Wrap an existing array as stream side data.
- *
- * @param st stream
- * @param type side information type
- * @param data the side data array. It must be allocated with the av_malloc()
- *             family of functions. The ownership of the data is transferred to
- *             st.
- * @param size side information size
- * @return zero on success, a negative AVERROR code on failure. On failure,
- *         the stream is unchanged and the data remains owned by the caller.
- *)
-function av_stream_add_side_data(st: PAVStream; type_: TAVPacketSideDataType;
-                                 data: Pcuint8; size: size_t): cint;
-  cdecl; external av__format;
-
-(**
- * Allocate new information from stream.
- *
- * @param stream stream
- * @param type desired side information type
- * @param size side information size
- * @return pointer to fresh allocated data or NULL otherwise
- *)
-function av_stream_new_side_data(stream: PAVStream;
-                                 type_: TAVPacketSideDataType; size: cint): Pcuint8;
-  cdecl; external av__format;
-
-(**
- * Get side information from stream.
- *
- * @param stream stream
- * @param type desired side information type
- * @param size pointer for side information size to store (optional)
- * @return pointer to data if present or NULL otherwise
- *)
-function av_stream_get_side_data(stream: {const} PAVStream;
-                                 type_: TAVPacketSideDataType; size: Pcint): Pcuint8;
-  cdecl; external av__format;
-
-function av_new_program(s: PAVFormatContext; id: cint): PAVProgram;
-  cdecl; external av__format;
-
-(**
- * @}
- *)
-
-{$IFDEF FF_API_PKT_DUMP}
-procedure av_pkt_dump(f: PAVFile; pkt: PAVPacket; dump_payload: cint); {deprecated}
-  cdecl; external av__format;
-procedure av_pkt_dump_log(avcl: Pointer; level: cint; pkt: PAVPacket; dump_payload: cint); {deprecated}
-  cdecl; external av__format;
-{$IFEND}
-
-(**
- * Allocate an AVFormatContext for an output format.
- * avformat_free_context() can be used to free the context and
- * everything allocated by the framework within it.
- *
- * @param *ctx is set to the created format context, or to NULL in
- * case of failure
- * @param oformat format to use for allocating the context, if NULL
- * format_name and filename are used instead
- * @param format_name the name of output format to use for allocating the
- * context, if NULL filename is used instead
- * @param filename the name of the filename to use for allocating the
- * context, may be NULL
- * @return >= 0 in case of success, a negative AVERROR code in case of
- * failure
- *)
-function avformat_alloc_output_context2(ctx: PPAVFormatContext; oformat: PAVOutputFormat;
-        {const} format_name: PAnsiChar; {const} filename: PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * @addtogroup lavf_decoding
- * @
- *)
-
-(**
- * Find AVInputFormat based on the short name of the input format.
- *)
-function av_find_input_format(short_name: PAnsiChar): PAVInputFormat;
-  cdecl; external av__format;
-
-(**
- * Guess the file format.
- *
- * @param pd        data to be probed
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- *)
-function av_probe_input_format(pd: PAVProbeData; is_opened: cint): PAVInputFormat;
-  cdecl; external av__format;
-
-(**
- * Guess the file format.
- *
- * @param pd        data to be probed
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- * @param score_max A probe score larger that this is required to accept a
- *                  detection, the variable is set to the actual detection
- *                  score afterwards.
- *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
- *                  to retry with a larger probe buffer.
- *)
-function av_probe_input_format2(pd: PAVProbeData; is_opened: cint; score_max: PCint): PAVInputFormat;
-  cdecl; external av__format;
-
-(**
- * Guess the file format.
- *
- * @param is_opened Whether the file is already opened; determines whether
- *                  demuxers with or without AVFMT_NOFILE are probed.
- * @param score_ret The score of the best detection.
- *)
-function av_probe_input_format3(pd: PAVProbeData; is_opened: cint; score_ret: Pcint): PAVInputFormat;
-  cdecl; external av__format;
-
-(**
- * Probe a bytestream to determine the input format. Each time a probe returns
- * with a score that is too low, the probe buffer size is increased and another
- * attempt is made. When the maximum probe size is reached, the input format
- * with the highest score is returned.
- *
- * @param pb the bytestream to probe
- * @param fmt the input format is put here
- * @param url the url of the stream
- * @param logctx the log context
- * @param offset the offset within the bytestream to probe from
- * @param max_probe_size the maximum probe buffer size (zero for default)
- * @return 0 in case of success, a negative value corresponding to an
- * AVERROR code otherwise
- *)
-function av_probe_input_buffer2(pb: PAVIOContext; var fmt: PAVInputFormat;
-                          url: {const} PAnsiChar; logctx: pointer;
-                          offset: cuint; max_probe_size: cuint): cint;
-  cdecl; external av__format;
-
-(**
- * Like av_probe_input_buffer2() but returns 0 on success
- *)
-function av_probe_input_buffer(pb: PAVIOContext; var fmt: PAVInputFormat;
-                          url: {const} PAnsiChar; logctx: pointer;
-                          offset: cuint; max_probe_size: cuint): cint;
-  cdecl; external av__format;
-
-(**
- * Open an input stream and read the header. The codecs are not opened.
- * The stream must be closed with av_close_input_file().
- *
- * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
- *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this
- *           function and written into ps.
- *           Note that a user-supplied AVFormatContext will be freed on failure.
- * @param url URL of the stream to open.
- * @param fmt If non-NULL, this parameter forces a specific input format.
- *            Otherwise the format is autodetected.
- * @param options  A dictionary filled with AVFormatContext and demuxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
- *
- * @return 0 on success, a negative AVERROR on failure.
- *
- * @note If you want to use custom IO, preallocate the format context and set its pb field.
- *)
-function avformat_open_input(ps: PPAVFormatContext; url: {const} PAnsiChar; fmt: PAVInputFormat; options: PPAVDictionary): cint;
-  cdecl; external av__format;
-
-function av_demuxer_open(ic: PAVFormatContext): cint;
-  cdecl; external av__format; deprecated;
-
-(**
- * Read packets of a media file to get stream information. This
- * is useful for file formats with no headers such as MPEG. This
- * function also computes the real framerate in case of MPEG-2 repeat
- * frame mode.
- * The logical file position is not changed by this function;
- * examined packets may be buffered for later processing.
- *
- * @param ic media file handle
- * @param options  If non-NULL, an ic.nb_streams long array of pointers to
- *                 dictionaries, where i-th member contains options for
- *                 codec corresponding to i-th stream.
- *                 On return each dictionary will be filled with options that were not found.
- * @return >=0 if OK, AVERROR_xxx on error
- *
- * @note this function isn't guaranteed to open all the codecs, so
- *       options being non-empty at return is a perfectly normal behavior.
- *
- * @todo Let the user decide somehow what information is needed so that
- *       we do not waste time getting stuff the user does not need.
- *)
-function avformat_find_stream_info(ic: PAVFormatContext; options: PPAVDictionary): cint;
-  cdecl; external av__format;
-
-(**
- * Find the programs which belong to a given stream.
- *
- * @param ic    media file handle
- * @param last  the last found program, the search will start after this
- *              program, or from the beginning if it is NULL
- * @param s     stream index
- * @return the next program which belongs to s, NULL if no program is found or
- *         the last program is not among the programs of ic.
- *)
-function av_find_program_from_stream(ic: PAVFormatContext; last: PAVProgram; s: cint): PAVProgram;
-  cdecl; external av__format;
-
-procedure av_program_add_stream_index(ac: PAVFormatContext; progid: cint; idx: cuint);
-  cdecl; external av__format;
-
-(**
- * Find the "best" stream in the file.
- * The best stream is determined according to various heuristics as the most
- * likely to be what the user expects.
- * If the decoder parameter is non-NULL, av_find_best_stream will find the
- * default decoder for the stream's codec; streams for which no decoder can
- * be found are ignored.
- *
- * @param ic                media file handle
- * @param type              stream type: video, audio, subtitles, etc.
- * @param wanted_stream_nb  user-requested stream number,
- *                          or -1 for automatic selection
- * @param related_stream    try to find a stream related (eg. in the same
- *                          program) to this one, or -1 if none
- * @param decoder_ret       if non-NULL, returns the decoder for the
- *                          selected stream
- * @param flags             flags; none are currently defined
- * @return  the non-negative stream number in case of success,
- *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type
- *          could be found,
- *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
- * @note  If av_find_best_stream returns successfully and decoder_ret is not
- *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
- *)
-function av_find_best_stream(ic: PAVFormatContext;
-                        type_: TAVMediaType;
-                        wanted_stream_nb: cint;
-                        related_stream: cint;
-                        decoder_ret: PPAVCodec;
-                        flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Return the next frame of a stream.
- * This function returns what is stored in the file, and does not validate
- * that what is there are valid frames for the decoder. It will split what is
- * stored in the file into frames and return one for each call. It will not
- * omit invalid data between valid frames so as to give the decoder the maximum
- * information possible for decoding.
- *
- * If pkt->buf is NULL, then the packet is valid until the next
- * av_read_frame() or until avformat_close_input(). Otherwise the packet
- * is valid indefinitely. In both cases the packet must be freed with
- * av_packet_unref when it is no longer needed. For video, the packet contains
- * exactly one frame. For audio, it contains an integer number of frames if each
- * frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames
- * have a variable size (e.g. MPEG audio), then it contains one frame.
- *
- * pkt->pts, pkt->dts and pkt->duration are always set to correct
- * values in AVStream.time_base units (and guessed if the format cannot
- * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
- * has B-frames, so it is better to rely on pkt->dts if you do not
- * decompress the payload.
- *
- * @return 0 if OK, < 0 on error or end of file
- *)
-function av_read_frame(s: PAVFormatContext; var pkt: TAVPacket): cint;
-  cdecl; external av__format;
-
-(**
- * Seek to the keyframe at timestamp.
- * 'timestamp' in 'stream_index'.
- *
- * @param s media file handle
- * @param stream_index If stream_index is (-1), a default
- * stream is selected, and timestamp is automatically converted
- * from AV_TIME_BASE units to the stream specific time_base.
- * @param timestamp Timestamp in AVStream.time_base units
- *        or, if no stream is specified, in AV_TIME_BASE units.
- * @param flags flags which select direction and seeking mode
- * @return >= 0 on success
- *)
-function av_seek_frame(s: PAVFormatContext; stream_index: cint; timestamp: cint64;
-                       flags: cint): cint;
-  cdecl; external av__format;
-
-
-(**
- * Seek to timestamp ts.
- * Seeking will be done so that the point from which all active streams
- * can be presented successfully will be closest to ts and within min/max_ts.
- * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
- *
- * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
- * are the file position (this may not be supported by all demuxers).
- * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
- * in the stream with stream_index (this may not be supported by all demuxers).
- * Otherwise all timestamps are in units of the stream selected by stream_index
- * or if stream_index is -1, in AV_TIME_BASE units.
- * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
- * keyframes (this may not be supported by all demuxers).
- * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
- *
- * @param s media file handle
- * @param stream_index index of the stream which is used as time base reference
- * @param min_ts smallest acceptable timestamp
- * @param ts target timestamp
- * @param max_ts largest acceptable timestamp
- * @param flags flags
- * @return >=0 on success, error code otherwise
- *
- * @note This is part of the new seek API which is still under construction.
- *       Thus do not use this yet. It may change at any time, do not expect
- *       ABI compatibility yet!
- *)
-function avformat_seek_file(s: PAVFormatContext; stream_index: cint; min_ts, ts, max_ts: cint64; flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Discard all internally buffered data. This can be useful when dealing with
- * discontinuities in the byte stream. Generally works only with formats that
- * can resync. This includes headerless formats like MPEG-TS/TS but should also
- * work with NUT, Ogg and in a limited way AVI for example.
- *
- * The set of streams, the detected duration, stream parameters and codecs do
- * not change when calling this function. If you want a complete reset, it's
- * better to open a new AVFormatContext.
- *
- * This does not flush the AVIOContext (s->pb). If necessary, call
- * avio_flush(s->pb) before calling this function.
- *
- * @param s media file handle
- * @return >=0 on success, error code otherwise
- *)
-function avformat_flush(s: PAVFormatContext): cint;
-  cdecl; external av__format;
-
-(**
- * Start playing a network-based stream (e.g. RTSP stream) at the
- * current position.
- *)
-function av_read_play(s: PAVFormatContext): cint;
-  cdecl; external av__format;
-
-(**
- * Pause a network-based stream (e.g. RTSP stream).
- *
- * Use av_read_play() to resume it.
- *)
-function av_read_pause(s: PAVFormatContext): cint;
-  cdecl; external av__format;
-
-(**
- * Close an opened input AVFormatContext. Free it and all its contents
- * and set *s to NULL.
- *)
-procedure avformat_close_input(s: PPAVFormatContext);
-  cdecl; external av__format;
-(**
- * @}
- *)
-
-const
-  AVSEEK_FLAG_BACKWARD = 1; ///< seek backward
-  AVSEEK_FLAG_BYTE     = 2; ///< seeking based on position in bytes
-  AVSEEK_FLAG_ANY      = 4; ///< seek to any frame, even non-keyframes
-  AVSEEK_FLAG_FRAME    = 8;
-
-  AVSTREAM_INIT_IN_WRITE_HEADER = 0; ///< stream parameters initialized in avformat_write_header
-  AVSTREAM_INIT_IN_INIT_OUTPUT  = 1; ///< stream parameters initialized in avformat_init_output
-
-  AV_FRAME_FILENAME_FLAGS_MULTIPLE = 1; ///< Allow multiple %d
-
-(**
- * @addtogroup lavf_encoding
- * @{
- *)
-(**
- * Allocate the stream private data and write the stream header to
- * an output media file.
- *
- * @param s Media file handle, must be allocated with avformat_alloc_context().
- *          Its oformat field must be set to the desired output format;
- *          Its pb field must be set to an already opened AVIOContext.
- * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
- *
- * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
- *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
- *         negative AVERROR on failure.
- *
- * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
- *)
-function avformat_write_header(s: PAVFormatContext; options: {PPAVDictionary} pointer): cint;
-  cdecl; external av__format;
-
-(**
- * Allocate the stream private data and initialize the codec, but do not write the header.
- * May optionally be used before avformat_write_header to initialize stream parameters
- * before actually writing the header.
- * If using this function, do not pass the same options to avformat_write_header.
- *
- * @param s Media file handle, must be allocated with avformat_alloc_context().
- *          Its oformat field must be set to the desired output format;
- *          Its pb field must be set to an already opened AVIOContext.
- * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
- *                 On return this parameter will be destroyed and replaced with a dict containing
- *                 options that were not found. May be NULL.
- *
- * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
- *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
- *         negative AVERROR on failure.
- *
- * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
- *)
-{av_warn_unused_result}
-function avformat_init_output(s: PAVFormatContext; options: PPAVDictionary): cint;
-  cdecl; external av__format;
-
-(**
- * Write a packet to an output media file.
- *
- * This function passes the packet directly to the muxer, without any buffering
- * or reordering. The caller is responsible for correctly interleaving the
- * packets if the format requires it. Callers that want libavformat to handle
- * the interleaving should call av_interleaved_write_frame() instead of this
- * function.
- *
- * @param s media file handle
- * @param pkt The packet containing the data to be written. Note that unlike
- *            av_interleaved_write_frame(), this function does not take
- *            ownership of the packet passed to it (though some muxers may make
- *            an internal reference to the input packet).
- *            <br>
- *            This parameter can be NULL (at any time, not just at the end), in
- *            order to immediately flush data buffered within the muxer, for
- *            muxers that buffer up data internally before writing it to the
- *            output.
- *            <br>
- *            Packet's @ref AVPacket.stream_index "stream_index" field must be
- *            set to the index of the corresponding stream in @ref
- *            AVFormatContext.streams "s->streams".
- *            <br>
- *            The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
- *            must be set to correct values in the stream's timebase (unless the
- *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
- *            they can be set to AV_NOPTS_VALUE).
- *            The dts for subsequent packets passed to this function must be strictly
- *            increasing when compared in their respective timebases (unless the
- *            output format is flagged with the AVFMT_TS_NONSTRICT, then they
- *            merely have to be nondecreasing).  @ref AVPacket.duration
- *            "duration") should also be set if known.
- * @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
- *
- * @see av_interleaved_write_frame()
- *)
-function av_write_frame(s: PAVFormatContext; pkt: PAVPacket): cint;
-  cdecl; external av__format;
-
-(**
- * Write a packet to an output media file ensuring correct interleaving.
- *
- * This function will buffer the packets internally as needed to make sure the
- * packets in the output file are properly interleaved in the order of
- * increasing dts. Callers doing their own interleaving should call
- * av_write_frame() instead of this function.
- *
- * Using this function instead of av_write_frame() can give muxers advance
- * knowledge of future packets, improving e.g. the behaviour of the mp4
- * muxer for VFR content in fragmenting mode.
- *
- * @param s media file handle
- * @param pkt The packet containing the data to be written.
- *            <br>
- *            If the packet is reference-counted, this function will take
- *            ownership of this reference and unreference it later when it sees
- *            fit.
- *            The caller must not access the data through this reference after
- *            this function returns. If the packet is not reference-counted,
- *            libavformat will make a copy.
- *            <br>
- *            This parameter can be NULL (at any time, not just at the end), to
- *            flush the interleaving queues.
- *            <br>
- *            Packet's @ref AVPacket.stream_index "stream_index" field must be
- *            set to the index of the corresponding stream in @ref
- *            AVFormatContext.streams "s->streams".
- *            <br>
- *            The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
- *            must be set to correct values in the stream's timebase (unless the
- *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
- *            they can be set to AV_NOPTS_VALUE).
- *            The dts for subsequent packets in one stream must be strictly
- *            increasing (unless the output format is flagged with the
- *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
- *            @ref AVPacket.duration "duration") should also be set if known.
- *
- * @return 0 on success, a negative AVERROR on error. Libavformat will always
- *         take care of freeing the packet, even if this function fails.
- *
- * @see av_write_frame(), AVFormatContext.max_interleave_delta
- *)
-function av_interleaved_write_frame(s: PAVFormatContext; var pkt: TAVPacket): cint;
-  cdecl; external av__format;
-
-(**
- * Write an uncoded frame to an output media file.
- *
- * The frame must be correctly interleaved according to the container
- * specification; if not, then av_interleaved_write_frame() must be used.
- *
- * See av_interleaved_write_frame() for details.
- *)
-function av_write_uncoded_frame(s: PAVFormatContext; stream_index: cint;
-                           frame: PAVFrame): cint;
-  cdecl; external av__format;
-
-(**
- * Write an uncoded frame to an output media file.
- *
- * If the muxer supports it, this function makes it possible to write an AVFrame
- * structure directly, without encoding it into a packet.
- * It is mostly useful for devices and similar special muxers that use raw
- * video or PCM data and will not serialize it into a byte stream.
- *
- * To test whether it is possible to use it with a given muxer and stream,
- * use av_write_uncoded_frame_query().
- *
- * The caller gives up ownership of the frame and must not access it
- * afterwards.
- *
- * @return  >=0 for success, a negative code on error
- *)
-function av_interleaved_write_uncoded_frame(s: PAVFormatContext; stream_index: cint;
-                                       frame: PAVFrame): cint;
-  cdecl; external av__format;
-
-
-(**
- * Test whether a muxer supports uncoded frame.
- *
- * @return  >=0 if an uncoded frame can be written to that muxer and stream,
- *          <0 if not
- *)
-function av_write_uncoded_frame_query(s: PAVFormatContext; stream_index: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Write the stream trailer to an output media file and free the
- * file private data.
- *
- * May only be called after a successful call to avformat_write_header.
- *
- * @param s media file handle
- * @return 0 if OK, AVERROR_xxx on error
- *)
-function av_write_trailer(s: pAVFormatContext): cint;
-  cdecl; external av__format;
-
-(**
- * Return the output format in the list of registered output formats
- * which best matches the provided parameters, or return NULL if
- * there is no match.
- *
- * @param short_name if non-NULL checks if short_name matches with the
- * names of the registered formats
- * @param filename if non-NULL checks if filename terminates with the
- * extensions of the registered formats
- * @param mime_type if non-NULL checks if mime_type matches with the
- * MIME type of the registered formats
- *)
-function av_guess_format(short_name: PAnsiChar;
-                         filename: PAnsiChar;
-                         mime_type: PAnsiChar): PAVOutputFormat;
-  cdecl; external av__format;
-
-(**
- * Guess the codec ID based upon muxer and filename.
- *)
-function av_guess_codec(fmt: PAVOutputFormat; short_name: PAnsiChar;
-                        filename: PAnsiChar; mime_type: PAnsiChar;
-                        type_: TCodecType): TAVCodecID;
-  cdecl; external av__format;
-
-(**
- * Get timing information for the data currently output.
- * The exact meaning of "currently output" depends on the format.
- * It is mostly relevant for devices that have an internal buffer and/or
- * work in real time.
- * @param s          media file handle
- * @param stream     stream in the media file
- * @param[out] dts   DTS of the last packet output for the stream, in stream
- *                   time_base units
- * @param[out] wall  absolute time when that packet whas output,
- *                   in microsecond
- * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
- * Note: some formats or devices may not allow to measure dts and wall
- * atomically.
- *)
-function av_get_output_timestamp(s: PAVFormatContext; stream: cint;
-        dts: Pcint64; wall: Pcint64): cint;
-  cdecl; external av__format;
-
-
-(**
- * @}
- *)
-
-
-(**
- * @defgroup lavf_misc Utility functions
- * @ingroup libavf
- * @
- *
- * Miscellaneous utility functions related to both muxing and demuxing
- * (or neither).
- *)
-
-(**
- * Send a nice hexadecimal dump of a buffer to the specified file stream.
- *
- * @param f The file stream pointer where the dump should be sent to.
- * @param buf buffer
- * @param size buffer size
- *
- * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
- *)
-procedure av_hex_dump(f: PAVFile; buf: {const} PByteArray; size: cint); {<-?FILE}
-  cdecl; external av__format;
-
-(**
- * Send a nice hexadecimal dump of a buffer to the log.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- * pointer to an AVClass struct.
- * @param level The importance level of the message, lower values signifying
- * higher importance.
- * @param buf buffer
- * @param size buffer size
- *
- * @see av_hex_dump, av_pkt_dump, av_pkt_dump_log
- *)
-procedure av_hex_dump_log(avcl: Pointer; level: cint; buf: {const} PByteArray; size: cint);
-  cdecl; external av__format;
-
-(**
- * Send a nice dump of a packet to the specified file stream.
- *
- * @param f The file stream pointer where the dump should be sent to.
- * @param pkt packet to dump
- * @param dump_payload True if the payload must be displayed, too.
- * @param st AVStream that the packet belongs to
- *)
-procedure av_pkt_dump2(f: PAVFile; pkt: {const} PAVPacket; dump_payload: cint; st: {const} PAVStream);
-  cdecl; external av__format;
-
-(**
- * Send a nice dump of a packet to the log.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- * pointer to an AVClass struct.
- * @param level The importance level of the message, lower values signifying
- * higher importance.
- * @param pkt packet to dump
- * @param dump_payload True if the payload must be displayed, too.
- * @param st AVStream that the packet belongs to
- *)
-procedure av_pkt_dump_log2(avcl: pointer; level: cint; pkt: {const} PAVPacket; dump_payload: cint;
-                           st: {const} PAVStream);
-  cdecl; external av__format;
-
-(**
- * Get the AVCodecID for the given codec tag tag.
- * If no codec id is found returns AV_CODEC_ID_NONE.
- *
- * @param tags list of supported codec_id-codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param tag  codec tag to match to a codec ID
- *)
-function av_codec_get_id(var tags: PAVCodecTag; tag: cuint): TAVCodecID;
-  cdecl; external av__format;
-
-(**
- * Getsthe codec tag for the given codec id id.
- * If no codec tag is found returns 0.
- *
- * @param tags list of supported codec_id-codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param id   codec ID to match to a codec tag
- *)
-function av_codec_get_tag(var tags: PAVCodecTag; id: TAVCodecID): cuint;
-  cdecl; external av__format;
-
-(**
- * Get the codec tag for the given codec id.
- *
- * @param tags list of supported codec_id - codec_tag pairs, as stored
- * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
- * @param id codec id that should be searched for in the list
- * @param tag A pointer to the found tag
- * @return 0 if id was not found in tags, > 0 if it was found
- *)
-function av_codec_get_tag2(var tags: PAVCodecTag; id: TAVCodecID;
-                           tag: Pcuint): cint;
-  cdecl; external av__format;
-
-function av_find_default_stream_index(s: PAVFormatContext): cint;
-  cdecl; external av__format;
-
-(**
- * Get the index for a specific timestamp.
- *
- * @param st        stream that the timestamp belongs to
- * @param timestamp timestamp to retrieve the index for
- * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
- *                 to the timestamp which is <= the requested one, if backward
- *                 is 0, then it will be >=
- *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
- * @return < 0 if no such timestamp could be found
- *)
-function av_index_search_timestamp(st: PAVStream; timestamp: cint64; flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Add an index entry into a sorted list. Update the entry if the list
- * already contains it.
- *
- * @param timestamp timestamp in the timebase of the given stream
- *)
-function av_add_index_entry(st: PAVStream; pos: cint64; timestamp: cint64;
-                  size: cint; distance: cint; flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Split a URL string into components.
- *
- * The pointers to buffers for storing individual components may be null,
- * in order to ignore that component. Buffers for components not found are
- * set to empty strings. If the port is not found, it is set to a negative
- * value.
- *
- * @param proto the buffer for the protocol
- * @param proto_size the size of the proto buffer
- * @param authorization the buffer for the authorization
- * @param authorization_size the size of the authorization buffer
- * @param hostname the buffer for the host name
- * @param hostname_size the size of the hostname buffer
- * @param port_ptr a pointer to store the port number in
- * @param path the buffer for the path
- * @param path_size the size of the path buffer
- * @param url the URL to split
- *)
-procedure av_url_split(proto: PAnsiChar;         proto_size: cint;
-                       authorization: PAnsiChar; authorization_size: cint;
-                       hostname: PAnsiChar;      hostname_size: cint;
-                       port_ptr: Pcint;
-                       path: PAnsiChar;          path_size: cint;
-                       url: {const} PAnsiChar);
-  cdecl; external av__format;
-
-(**
- * Print detailed information about the input or output format, such as
- * duration, bitrate, streams, container, programs, metadata, side data,
- * codec and time base.
- *
- * @param ic        the context to analyze
- * @param index     index of the stream to dump information about
- * @param url       the URL to print, such as source or destination file
- * @param is_output Select whether the specified context is an input(0) or output(1)
- *)
-procedure av_dump_format(ic: PAVFormatContext;
-                         index: cint;
-			                   url: {const} PAnsiChar;
-			                   is_output: cint);
-  cdecl; external av__format;
-
-(**
- * Return in 'buf' the path with '%d' replaced by a number.
- *
- * Also handles the '%0nd' format where 'n' is the total number
- * of digits and '%%'.
- *
- * @param buf destination buffer
- * @param buf_size destination buffer size
- * @param path numbered sequence string
- * @param number frame number
- * @param flags AV_FRAME_FILENAME_FLAGS_*
- * @return 0 if OK, -1 on format error
- *)
-function av_get_frame_filename2(buf: PAnsiChar; buf_size: cint;
-                               path: {const} PAnsiChar; number: cint; flags: cint): cint;
-  cdecl; external av__format;
-function av_get_frame_filename(buf: PAnsiChar; buf_size: cint;
-                               path: {const} PAnsiChar; number: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Check whether filename actually is a numbered sequence generator.
- *
- * @param filename possible numbered sequence string
- * @return 1 if a valid numbered sequence string, 0 otherwise
- *)
-function av_filename_number_test(filename: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Generate an SDP for an RTP session.
- *
- * Note, this overwrites the id values of AVStreams in the muxer contexts
- * for getting unique dynamic payload types.
- *
- * @param ac array of AVFormatContexts describing the RTP streams. If the
- *           array is composed by only one context, such context can contain
- *           multiple AVStreams (one AVStream per RTP stream). Otherwise,
- *           all the contexts in the array (an AVCodecContext per RTP stream)
- *           must contain only one AVStream.
- * @param n_files number of AVCodecContexts contained in ac
- * @param buf buffer where the SDP will be stored (must be allocated by
- *            the caller)
- * @param size the size of the buffer
- * @return 0 if OK, AVERROR_xxx on error
- *)
-function av_sdp_create(ac: pointer; n_files: cint; buf: PAnsiChar; size: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Return a positive value if the given filename has one of the given
- * extensions, 0 otherwise.
- *
- * @param filename   file name to check against the given extensions
- * @param extensions a comma-separated list of filename extensions
- *)
-function av_match_ext(filename: {const} Pchar; extensions: {const} Pchar): cint;
-  cdecl; external av__format;
-
-(**
- * Test if the given container can store a codec.
- *
- * @param ofmt           container to check for compatibility
- * @param codec_id       codec to potentially store in container
- * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
- *
- * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
- *         A negative number if this information is not available.
- *)
-function avformat_query_codec(ofmt: {const} PAVOutputFormat; codec_id: TAVCodecID;
-                              std_compliance: cint): cint;
-  cdecl; external av__format;
-
-(**
- * @defgroup riff_fourcc RIFF FourCCs
- * @
- * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
- * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
- * following code:
- * @code
- * uint32_t tag = MKTAG('H', '2', '6', '4');
- * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
- * enum AVCodecID id = av_codec_get_id(table, tag);
- * @endcode
- *)
-(**
- * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
- *)
-function avformat_get_riff_video_tags(): {const} PAVCodecTag;
-  cdecl; external av__format;
-(**
- * @return the table mapping RIFF FourCCs for audio to AVCodecID.
- *)
-function avformat_get_riff_audio_tags(): {const} PAVCodecTag;
-  cdecl; external av__format;
-
-(**
- * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
- *)
-function avformat_get_mov_video_tags(): {const} PAVCodecTag;
-  cdecl; external av__format;
-
-(**
- * @return the table mapping MOV FourCCs for audio to AVCodecID.
- *)
-function avformat_get_mov_audio_tags(): {const} PAVCodecTag;
-  cdecl; external av__format;
-
-(**
- * Guess the sample aspect ratio of a frame, based on both the stream and the
- * frame aspect ratio.
- *
- * Since the frame aspect ratio is set by the codec but the stream aspect ratio
- * is set by the demuxer, these two may not be equal. This function tries to
- * return the value that you should use if you would like to display the frame.
- *
- * Basic logic is to use the stream aspect ratio if it is set to something sane
- * otherwise use the frame aspect ratio. This way a container setting, which is
- * usually easy to modify can override the coded value in the frames.
- *
- * @param format the format context which the stream is part of
- * @param stream the stream which the frame is part of
- * @param frame the frame with the aspect ratio to be determined
- * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
- *)
-function av_guess_sample_aspect_ratio(format: PAVFormatContext; stream: PAVStream; frame: PAVFrame): TAVRational;
-  cdecl; external av__format;
-
-(**
- * Guess the frame rate, based on both the container and codec information.
- *
- * @param ctx the format context which the stream is part of
- * @param stream the stream which the frame is part of
- * @param frame the frame for which the frame rate should be determined, may be NULL
- * @return the guessed (valid) frame rate, 0/1 if no idea
- *)
-function av_guess_frame_rate(ctx: PAVFormatContext; stream: PAVStream; frame: PAVFrame): TAVRational;
-  cdecl; external av__format;
-
-(**
- * Check if the stream st contained in s is matched by the stream specifier
- * spec.
- *
- * See the "stream specifiers" chapter in the documentation for the syntax
- * of spec.
- *
- * @return  >0 if st is matched by spec;
- *          0  if st is not matched by spec;
- *          AVERROR code if spec is invalid
- *
- * @note  A stream specifier can match several streams in the format.
- *)
-function avformat_match_stream_specifier(s: PAVFormatContext; st: PAVStream;
-                                         spec: PAnsiChar): cint;
-  cdecl; external av__format;
-
-function avformat_queue_attached_pictures(s: PAVFormatContext): cint;
-  cdecl; external av__format;
-
-{$IFDEF FF_API_OLD_BSF}
-(**
- * Apply a list of bitstream filters to a packet.
- *
- * @param codec AVCodecContext, usually from an AVStream
- * @param pkt the packet to apply filters to. If, on success, the returned
- *        packet has size == 0 and side_data_elems == 0, it indicates that
- *        the packet should be dropped
- * @param pkt the packet to apply filters to
- * @param bsfc a NULL-terminated list of filters to apply
- * @return  >=0 on success;
- *          AVERROR code on failure
- *)
-function av_apply_bitstream_filters(codec: PAVCodecContext; pkt: PAVPacket;
-				    bsfc: PAVBitStreamFilterContext): cint;
-  cdecl; external av__format; deprecated;
-{$ENDIF}
-
-(**
- * Transfer internal timing information from one stream to another.
- *
- * This function is useful when doing stream copy.
- *
- * @param ofmt     target output format for ost
- * @param ost      output stream which needs timings copy and adjustments
- * @param ist      reference input stream to copy timings from
- * @param copy_tb  define from where the stream codec timebase needs to be imported
- *)
-function avformat_transfer_internal_stream_timing_info(ofmt: {const} PAVOutputFormat;
-                                                  ost: PAVStream; ist: {const} PAVStream;
-                                                  copy_tb: TAVTimebaseSource): cint;
-  cdecl; external av__format;
-
-(**
- * Get the internal codec timebase from a stream.
- *
- * @param st  input stream to extract the timebase from
- *)
-function av_stream_get_codec_timebase(st: {const} PAVStream): TAVRational;
-  cdecl; external av__format;
-
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  TAVStream = record
+    we_do_not_use_index: cint;
+    we_do_not_use_id: cint;
+    codec: ^TAVCodecContext;
+    we_do_not_use_priv_data: pointer;
+    time_base: TAVRational; 
+    start_time: cint64;
+    we_do_not_use_duration: cint64;
+    we_do_not_use_nb_frames: cint64;
+    we_do_not_use_disposition: cint;
+    we_do_not_use_discard: cenum;
+    we_do_not_use_sample_aspect_ratio: TAVRational;
+    we_do_not_use_metadata: PAVDictionary;
+    we_do_not_use_avg_frame_rate: TAVRational;
+    we_do_not_use_atached_pic: TAVPacket;
+    we_do_not_use_side_data: pointer;
+    we_do_not_use_nb_side_data: cint;
+    we_do_not_use_event_flags: cint;
+    r_frame_rate: TAVRational;
+    we_do_not_use_recommended_encoder_configuration: ^AnsiChar;
+    codecpar: ^TAVCodecParameters;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  TAVInputFormat = record
+    name: ^AnsiChar;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+function avformat_alloc_context(): PAVFormatContext; cdecl; external 'libavformat';
+function avformat_open_input(ps: PPAVFormatContext; url: PAnsiChar; fmt: PAVInputFormat; options: PPAVDictionary): cint; cdecl; external 'libavformat';
+procedure avformat_close_input(s: PPAVFormatContext); cdecl; external 'libavformat';
+function avformat_version(): cuint; cdecl; external 'libavformat';
+procedure av_register_all(); cdecl; external 'libavformat';
+function avformat_find_stream_info(ic: PAVFormatContext; options: PPAVDictionary): cint; cdecl; external 'libavformat';
+function av_stream_get_r_frame_rate(s: PAVStream): TAVRational; cdecl; external 'libavformat';
+function av_read_frame(s: PAVFormatContext; var pkt: TAVPacket): cint; cdecl; external 'libavformat';
+function av_seek_frame(s: PAVFormatContext; stream_index: cint; timestamp: cint64; flags: cint): cint; cdecl; external 'libavformat';
 implementation
-
 end.
diff --git a/src/lib/ffmpeg-4.0/avio.pas b/src/lib/ffmpeg-4.0/avio.pas
index 25a894891..a88f22091 100644
--- a/src/lib/ffmpeg-4.0/avio.pas
+++ b/src/lib/ffmpeg-4.0/avio.pas
@@ -1,992 +1,51 @@
-(*
- * copyright (c) 2001 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavformat/avio.h
- * unbuffered I/O operations
- * @warning This file has to be considered an internal but installed
- * header, so it should not be directly included in your projects.
- *
- * update to
- * avformat version: 56.4.101
- *)
-
 unit avio;
 
 {$IFDEF FPC}
-  {$MODE DELPHI }
+  {$MODE DELPHI}
   {$PACKENUM 4}    (* use 4-byte enums *)
   {$PACKRECORDS C} (* C/C++-compatible record packing *)
 {$ELSE}
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I switches.inc}
+{$IFDEF DARWIN}
+  {$linklib libavformat}
+{$ENDIF}
 
 interface
 
 uses
   ctypes,
-  {$IFDEF UNIX}
-  BaseUnix,   // for SEEK_CUR
-  {$ENDIF}
-  avcodec,
   avutil,
-  SysUtils,
-  UConfig;
-
-(**
- * Those FF_API_* defines are not part of public API.
- * They may change, break or disappear at any time.
- *)
+  SysUtils;
 const
-  FF_API_URL_CLASS            = (LIBAVFORMAT_VERSION_MAJOR >= 53);
-
-const
-  (**
-   * Seeking works like for a local file.
-   *)
-  AVIO_SEEKABLE_NORMAL = (1 << 0);
-
-  (**
-   * Seeking by timestamp with avio_seek_time() is possible.
-   *)
-  AVIO_SEEKABLE_TIME   = (1 << 1);
-
+  AVSEEK_SIZE = 65536;
 type
-  TReadWriteFunc = function(opaque: Pointer; buf: PByteArray; buf_size: cint): cint; cdecl;
-  TSeekFunc = function(opaque: Pointer; offset: cint64; whence: cint): cint64; cdecl;
-  Tcallback = function(p: pointer): cint; cdecl;
-
-type
-(**
- * Callback for checking whether to abort blocking functions.
- * AVERROR_EXIT is returned in this case by the interrupted
- * function. During blocking operations, callback is called with
- * opaque as parameter. If the callback returns 1, the
- * blocking operation will be aborted.
- *
- * No members can be added to this struct without a major bump, if
- * new elements have been added after this struct in AVFormatContext
- * or AVIOContext.
- *)
-  PAVIOInterruptCB = ^TAVIOInterruptCB;
-  TAVIOInterruptCB = record
-    callback: Tcallback;
-    opaque: pointer;
-  end; (*TAVIOInterruptCB*)
-
- (**
-  * Directory entry types.
-  *)
-  TAVIODirEntryType = (
-    AVIO_ENTRY_UNKNOWN,
-    AVIO_ENTRY_BLOCK_DEVICE,
-    AVIO_ENTRY_CHARACTER_DEVICE,
-    AVIO_ENTRY_DIRECTORY,
-    AVIO_ENTRY_NAMED_PIPE,
-    AVIO_ENTRY_SYMBOLIC_LINK,
-    AVIO_ENTRY_SOCKET,
-    AVIO_ENTRY_FILE,
-    AVIO_ENTRY_SERVER,
-    AVIO_ENTRY_SHARE,
-    AVIO_ENTRY_WORKGROUP
-  );
-
-  TAVIODataMarkerType = (
-    (**
-     * Header data; this needs to be present for the stream to be decodeable.
-     *)
-    AVIO_DATA_MARKER_HEADER,
-    (**
-     * A point in the output bytestream where a decoder can start decoding
-     * (i.e. a keyframe). A demuxer/decoder given the data flagged with
-     * AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,
-     * should give decodeable results.
-     *)
-    AVIO_DATA_MARKER_SYNC_POINT,
-    (**
-     * A point in the output bytestream where a demuxer can start parsing
-     * (for non self synchronizing bytestream formats). That is, any
-     * non-keyframe packet start point.
-     *)
-    AVIO_DATA_MARKER_BOUNDARY_POINT,
-    (**
-     * This is any, unlabelled data. It can either be a muxer not marking
-     * any positions at all, it can be an actual boundary/sync point
-     * that the muxer chooses not to mark, or a later part of a packet/fragment
-     * that is cut into multiple write callbacks due to limited IO buffer size.
-     *)
-    AVIO_DATA_MARKER_UNKNOWN,
-    (**
-     * Trailer data, which doesn't contain actual content, but only for
-     * finalizing the output file.
-     *)
-    AVIO_DATA_MARKER_TRAILER,
-    (**
-     * A point in the output bytestream where the underlying AVIOContext might
-     * flush the buffer depending on latency or buffering requirements. Typically
-     * means the end of a packet.
-     *)
-    AVIO_DATA_MARKER_FLUSH_POINT
-  );
-
- (**
-  * Describes single entry of the directory.
-  *
-  * Only name and type fields are guaranteed be set.
-  * Rest of fields are protocol or/and platform dependent and might be unknown.
-  *)
-  PPAVIODirEntry = ^PAVIODirEntry;
-  PAVIODirEntry = ^TAVIODirEntry;
-  TAVIODirEntry = record
-    name: PAnsiChar;                  (**< Filename *)
-    type_: cint;                       (**< Type of the entry *)
-    utf8: cint;                       (**< Set to 1 when name is encoded with UTF-8, 0 otherwise.
-                                           Name can be encoded with UTF-8 even though 0 is set. *)
-    size: cint64;                     (**< File size in bytes, -1 if unknown. *)
-    modification_timestamp: cint64;   (**< Time of last modification in microseconds since unix
-                                           epoch, -1 if unknown. *)
-    access_timestamp: cint64;         (**< Time of last access in microseconds since unix epoch,
-                                           -1 if unknown. *)
-    status_change_timestamp: cint64;  (**< Time of last status change in microseconds since unix
-                                           epoch, -1 if unknown. *)
-    user_id: cint64;                  (**< User ID of owner, -1 if unknown. *)
-    group_id: cint64;                 (**< Group ID of owner, -1 if unknown. *)
-    filemode: cint64;                 (**< Unix file mode, -1 if unknown. *)
-  end;
-
-  PPAVIODirContext = ^PAVIODirContext;
-  PAVIODirContext = ^TAVIODirContext;
-  TAVIODirContext = record
-    url_context: pointer;
-    (** struct URLContext *url_context; *)
-  end;
-
-(**
- * Bytestream IO Context.
- * New fields can be added to the end with minor version bumps.
- * Removal, reordering and changes to existing fields require a major
- * version bump.
- * sizeof(AVIOContext) must not be used outside libav*.
- *
- * @note None of the function pointers in AVIOContext should be called
- *       directly, they should only be set by the client application
- *       when implementing custom I/O. Normally these are set to the
- *       function pointers specified in avio_alloc_context()
- *)
-  PPAVIOContext = ^PAVIOContext;
   PAVIOContext = ^TAVIOContext;
   TAVIOContext = record
-    (**
-     * A class for private options.
-     *
-     * If this AVIOContext is created by avio_open2(), av_class is set and
-     * passes the options down to protocols.
-     *
-     * If this AVIOContext is manually allocated, then av_class may be set by
-     * the caller.
-     *
-     * warning -- this field can be NULL, be sure to not pass this AVIOContext
-     * to any av_opt_* functions in that case.
-     *)
-    av_class: {const} PAVClass;
-
-    (*
-     * The following shows the relationship between buffer, buf_ptr,
-     * buf_ptr_max, buf_end, buf_size, and pos, when reading and when writing
-     * (since AVIOContext is used for both):
-     *
-     **********************************************************************************
-     *                                   READING
-     **********************************************************************************
-     *
-     *                            |              buffer_size              |
-     *                            |---------------------------------------|
-     *                            |                                       |
-     *
-     *                         buffer          buf_ptr       buf_end
-     *                            +---------------+-----------------------+
-     *                            |/ / / / / / / /|/ / / / / / /|         |
-     *  read buffer:              |/ / consumed / | to be read /|         |
-     *                            |/ / / / / / / /|/ / / / / / /|         |
-     *                            +---------------+-----------------------+
-     *
-     *                                                         pos
-     *              +-------------------------------------------+-----------------+
-     *  input file: |                                           |                 |
-     *              +-------------------------------------------+-----------------+
-     *
-     *
-     **********************************************************************************
-     *                                   WRITING
-     **********************************************************************************
-     *
-     *                             |          buffer_size                 |
-     *                             |--------------------------------------|
-     *                             |                                      |
-     *
-     *                                                buf_ptr_max
-     *                          buffer                 (buf_ptr)       buf_end
-     *                             +-----------------------+--------------+
-     *                             |/ / / / / / / / / / / /|              |
-     *  write buffer:              | / / to be flushed / / |              |
-     *                             |/ / / / / / / / / / / /|              |
-     *                             +-----------------------+--------------+
-     *                               buf_ptr can be in this
-     *                               due to a backward seek
-     *
-     *                            pos
-     *               +-------------+----------------------------------------------+
-     *  output file: |             |                                              |
-     *               +-------------+----------------------------------------------+
-     *
-     *)
-
-    buffer: PByteArray;  (**< Start of the buffer. *)
-    buffer_size: cint;   (**< Maximum buffer size *)
-    buf_ptr: PByteArray; (**< Current position in the buffer *)
-    buf_end: PByteArray; (**< End of the data, may be less than
-                              buffer+buffer_size if the read function returned
-                              less data than requested, e.g. for streams where
-                              no more data has been received yet. *)
-    opaque: pointer;     (**< A private pointer, passed to the read/write/seek/...
-                              functions. *)
-    read_packet: TReadWriteFunc;
-    write_packet: TReadWriteFunc;
-    seek: TSeekFunc;
-    pos: cint64;         (**< position in the file of the current buffer *)
-    must_flush: cint;    (**< unused *)
-    eof_reached: cint;   (**< true if eof reached *)
-    write_flag: cint;    (**< true if open for writing *)
-    max_packet_size: cint;
-    checksum: culong;
-    checksum_ptr: PByteArray;
-    update_checksum: function (checksum: culong; buf: {const} PAnsiChar; size: cuint): culong; cdecl;
-    error: cint;         (**< contains the error code or 0 if no error happened *)
-    (**
-     * Pause or resume playback for network streaming protocols - e.g. MMS.
-     *)
-    read_pause: function(opaque: Pointer; pause: cint): cint; cdecl;
-    (**
-     * Seek to a given timestamp in stream with the specified stream_index.
-     * Needed for some network streaming protocols which don't support seeking
-     * to byte position.
-     *)
-    read_seek: function(opaque: Pointer; stream_index: cint;
-                        timestamp: cint64; flags: cint): cint64; cdecl;
-    (**
-     * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
-     *)
-    seekable: cint;
-
-    (**
-     * max filesize, used to limit allocations
-     * This field is internal to libavformat and access from outside is not allowed.
-     *)
-    maxsize: cint64;
-
-    (**
-     * avio_read and avio_write should if possible be satisfied directly
-     * instead of going through a buffer, and avio_seek will always
-     * call the underlying seek function directly.
-     *)
-    direct: cint;
-
-    (**
-     * Bytes read statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     *)
-    bytes_read: cint64;
-
-    (**
-     * seek statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     *)
-    seek_count: cint;
-
-    (**
-     * writeout statistic
-     * This field is internal to libavformat and access from outside is not allowed.
-     *)
-    writeout_count: cint;
-
-    (**
-     * Original buffer size
-     * used internally after probing and ensure seekback to reset the buffer size
-     * This field is internal to libavformat and access from outside is not allowed.
-     *)
-    orig_buffer_size: cint;
-
-    (**
-     * Threshold to favor readahead over seek.
-     * This is current internal only, do not use from outside.
-     *)
-    short_seek_threshold: cint;
-
-    (**
-     * ',' separated list of allowed protocols.
-     *)
-    protocol_whitelist: {const} PAnsiChar;
-
-    (**
-     * A callback that is used instead of write_packet.
-     *)
-    write_data_type: function(opaque: pointer; buf: Pcuint8; buf_size: cint;
-                               type_: TAVIODataMarkerType; time: cint64): cint; cdecl;
-    (**
-     * If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
-     * but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
-     * small chunks of data returned from the callback).
-     *)
-    ignore_boundary_point: cint;
-
-    (**
-     * Internal, not meant to be used from outside of AVIOContext.
-     *)
-    current_type: TAVIODataMarkerType;
-    last_time: cint64;
-
-    (**
-     * A callback that is used instead of short_seek_threshold.
-     * This is current internal only, do not use from outside.
-     *)
-    short_seek_get: function(opaque: pointer): cint; cdecl;
-
-    written: cint64;
-
-    (**
-     * Maximum reached position before a backward seek in the write buffer,
-     * used keeping track of already written data for a later flush.
-     *)
-    buf_ptr_max: PByteArray;
-
-    (**
-     * Try to buffer at least this amount of data before flushing it
-     *)
-    min_packet_size: cint;
-  end; {AVIOContext}
-
-(* unbuffered I/O *)
-
-(**
- * Return the name of the protocol that will handle the passed URL.
- *
- * NULL is returned if no protocol could be found for the given URL.
- *
- * @return Name of the protocol or NULL.
- *)
-function avio_find_protocol_name(url: {const} PAnsiChar): {const} PAnsiChar;
-  cdecl; external av__format;
-
-(**
- * Return AVIO_* access flags corresponding to the access permissions
- * of the resource in url, or a negative value corresponding to an
- * AVERROR code in case of failure. The returned access flags are
- * masked by the value in flags.
- *
- * @note This function is intrinsically unsafe, in the sense that the
- * checked resource may change its existence or permission status from
- * one call to another. Thus you should not trust the returned value,
- * unless you are sure that no other processes are accessing the
- * checked resource.
- *)
-function avio_check(url: {const} PAnsiChar; flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Move or rename a resource.
- *
- * @note url_src and url_dst should share the same protocol and authority.
- *
- * @param url_src url to resource to be moved
- * @param url_dst new url to resource if the operation succeeded
- * @return >=0 on success or negative on error.
- *)
-function avpriv_io_move(url_src: {const} PAnsiChar; url_dst: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Delete a resource.
- *
- * @param url resource to be deleted.
- * @return >=0 on success or negative on error.
- *)
-function avpriv_io_delete(url: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Open directory for reading.
- *
- * @param s       directory read context. Pointer to a NULL pointer must be passed.
- * @param url     directory to be listed.
- * @param options A dictionary filled with protocol-private options. On return
- *                this parameter will be destroyed and replaced with a dictionary
- *                containing options that were not found. May be NULL.
- * @return >=0 on success or negative on error.
- *)
-function avio_open_dir(s: PPAVIODirContext; url: {const} PAnsiChar; options: PPAVDictionary): cint;
-  cdecl; external av__format;
-
-(**
- * Get next directory entry.
- *
- * Returned entry must be freed with avio_free_directory_entry(). In particular
- * it may outlive AVIODirContext.
- *
- * @param s         directory read context.
- * @param[out] next next entry or NULL when no more entries.
- * @return >=0 on success or negative on error. End of list is not considered an
- *             error.
- *)
-function avio_read_dir(s: PAVIODirContext; next: PPAVIODirEntry): cint;
-  cdecl; external av__format;
-
-(**
- * Close directory.
- *
- * @note Entries created using avio_read_dir() are not deleted and must be
- * freeded with avio_free_directory_entry().
- *
- * @param s         directory read context.
- * @return >=0 on success or negative on error.
- *)
-function avio_close_dir(s: PPAVIODirContext): cint;
-  cdecl; external av__format;
-
-(**
- * Free entry allocated by avio_read_dir().
- *
- * @param entry entry to be freed.
- *)
-procedure avio_free_directory_entry(entry: PPAVIODirEntry);
-  cdecl; external av__format;
-
-(**
- * Allocate and initialize an AVIOContext for buffered I/O. It must be later
- * freed with avio_context_free().
- *
- * @param buffer Memory block for input/output operations via AVIOContext.
- *        The buffer must be allocated with av_malloc() and friends.
- *        It may be freed and replaced with a new buffer by libavformat.
- *        AVIOContext.buffer holds the buffer currently in use,
- *        which must be later freed with av_free().
- * @param buffer_size The buffer size is very important for performance.
- *        For protocols with fixed blocksize it should be set to this blocksize.
- *        For others a typical size is a cache page, e.g. 4kb.
- * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
- * @param opaque An opaque pointer to user-specific data.
- * @param read_packet  A function for refilling the buffer, may be NULL.
- *                     For stream protocols, must never return 0 but rather
- *                     a proper AVERROR code.
- * @param write_packet A function for writing the buffer contents, may be NULL.
- *        The function may not change the input buffers content.
- * @param seek A function for seeking to specified byte position, may be NULL.
- *
- * @return Allocated AVIOContext or NULL on failure.
- *)
-function avio_alloc_context(
-                  buffer: PAnsiChar;
-                  buffer_size: cint;
-                  write_flag: cint;
-                  opaque: Pointer;
-                  read_packet: TReadWriteFunc;
-                  write_packet: TReadWriteFunc;
-                  seek: TSeekFunc): PAVIOContext;
-  cdecl; external av__format;
-
-(**
- * Free the supplied IO context and everything associated with it.
- *
- * @param s Double pointer to the IO context. This function will write NULL
- * into s.
- *)
-procedure avio_context_free(s: PAVIOContext);
-  cdecl; external av__format;
-
-procedure avio_w8(s: PAVIOContext; b: cint);
-  cdecl; external av__format;
-procedure avio_write(s: PAVIOContext; buf: {const} PAnsiChar; size: cint);
-  cdecl; external av__format;
-procedure avio_wl64(s: PAVIOContext; val: cuint64);
-  cdecl; external av__format;
-procedure avio_wb64(s: PAVIOContext; val: cuint64);
-  cdecl; external av__format;
-procedure avio_wl32(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-procedure avio_wb32(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-procedure avio_wl24(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-procedure avio_wb24(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-procedure avio_wl16(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-procedure avio_wb16(s: PAVIOContext; val: cuint);
-  cdecl; external av__format;
-
-(**
- * Write a NULL-terminated string.
- * @return number of bytes written.
- *)
-function avio_put_str(s: PAVIOContext; str: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Convert an UTF-8 string to UTF-16LE and write it.
- * @param s the AVIOContext
- * @param str NULL-terminated UTF-8 string
- *
- * @return number of bytes written.
- *)
-function avio_put_str16le(s: PAVIOContext; str: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Convert an UTF-8 string to UTF-16BE and write it.
- * @param s the AVIOContext
- * @param str NULL-terminated UTF-8 string
- *
- * @return number of bytes written.
- *)
-function avio_put_str16be(s: PAVIOContext; str: {const} PAnsiChar): cint;
-  cdecl; external av__format;
-
-(**
- * Mark the written bytestream as a specific type.
- *
- * Zero-length ranges are omitted from the output.
- *
- * @param time the stream time the current bytestream pos corresponds to
- *             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
- *             applicable
- * @param type the kind of data written starting at the current pos
- *)
-procedure avio_write_marker(s: PAVIOContext; time: cint64; type_: TAVIODataMarkerType);
-  cdecl; external av__format;
-
-const
-(**
- * ORing this as the "whence" parameter to a seek function causes it to
- * return the filesize without seeking anywhere. Supporting this is optional.
- * If it is not supported then the seek function will return <0.
- *)
-  AVSEEK_SIZE = $10000;
-
-(**
- * Passing this flag as into the "whence" parameter to a seek function causes it to
- * seek by any means (like reopening and linear reading) or other normally unreasonable
- * means that can be extremely slow.
- * This may be ignored by the seek code.
- *)
-  AVSEEK_FORCE = $20000;
-
-(**
- * fseek() equivalent for AVIOContext.
- * @return new position or AVERROR.
- *)
-function avio_seek(s: PAVIOContext; offset: cint64; whence: cint): cint64;
-  cdecl; external av__format;
-
-(**
- * Skip given number of bytes forward
- * @return new position or AVERROR.
- *)
-function avio_skip(s: PAVIOContext; offset: cint64): cint64;
-  cdecl; external av__format;
-
-{$IFDEF UNIX}
-(**
- * ftell() equivalent for AVIOContext.
- * @return position or AVERROR.
- *)
-function avio_tell(s: PAVIOContext): cint64; {$IFDEF HasInline}inline;{$ENDIF}
-{$ELSE}
-{$ENDIF}
-
-(**
- * Get the filesize.
- * @return filesize or AVERROR
- *)
-function avio_size(s: PAVIOContext): cint64;
-  cdecl; external av__format;
-
-(**
- * feof() equivalent for AVIOContext.
- * @return non zero if and only if end of file
- *)
-function avio_feof(s: PAVIOContext): cint;
-  cdecl; external av__format;
-
-(** @warning Writes up to 4 KiB per call *)
-function avio_printf(s: PAVIOContext; fmt: {const} PAnsiChar; args: array of const): cint;
-  cdecl; external av__format;
-
-(**
- * Force flushing of buffered data.
- *
- * For write streams, force the buffered data to be immediately written to the output,
- * without to wait to fill the internal buffer.
- *
- * For read streams, discard all currently buffered data, and advance the
- * reported file position to that of the underlying stream. This does not
- * read new data, and does not perform any seeks.
- *)
-procedure avio_flush(s: PAVIOContext);
-  cdecl; external av__format;
-
-(**
- * Read size bytes from AVIOContext into buf.
- * @return number of bytes read or AVERROR
- *)
-function avio_read(s: PAVIOContext; buf: Pbyte; size: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed
- * to read fewer bytes than requested. The missing bytes can be read in the next
- * call. This always tries to read at least 1 byte.
- * Useful to reduce latency in certain cases.
- * @return number of bytes read or AVERROR
- *)
-function avio_read_partial(s: PAVIOContext; buf: Pbyte; size: cint): cint;
-  cdecl; external av__format;
-
-(**
- * @name Functions for reading from AVIOContext
- * @
- *
- * @note return 0 if EOF, so you cannot use it if EOF handling is
- *       necessary
- *)
-function avio_r8(s: PAVIOContext): cint;
-  cdecl; external av__format;
-
-function avio_rl16(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rl24(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rl32(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rl64(s: PAVIOContext): cuint64;
-  cdecl; external av__format;
-
-function avio_rb16(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rb24(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rb32(s: PAVIOContext): cuint;
-  cdecl; external av__format;
-
-function avio_rb64(s: PAVIOContext): cuint64;
-  cdecl; external av__format;
-
-(**
- * @
- *)
-(**
- * Read a string from pb into buf. The reading will terminate when either
- * a NULL character was encountered, maxlen bytes have been read, or nothing
- * more can be read from pb. The result is guaranteed to be NULL-terminated, it
- * will be truncated if buf is too small.
- * Note that the string is not interpreted or validated in any way, it
- * might get truncated in the middle of a sequence for multi-byte encodings.
- *
- * @return number of bytes read (is always <= maxlen).
- * If reading ends on EOF or error, the return value will be one more than
- * bytes actually read.
- *)
-function avio_get_str(pb: PAVIOContext; maxlen: cint; buf: PAnsiChar; buflen: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Read a UTF-16 string from pb and convert it to UTF-8.
- * The reading will terminate when either a null or invalid character was
- * encountered or maxlen bytes have been read.
- * @return number of bytes read (is always <= maxlen)
- *)
-function avio_get_str16le(pb: PAVIOContext; maxlen: cint; buf: PAnsiChar; buflen: cint): cint;
-  cdecl; external av__format;
-
-function avio_get_str16be(pb: PAVIOContext; maxlen: cint; buf: PAnsiChar; buflen: cint): cint;
-  cdecl; external av__format;
-
-(**
- * @name URL open modes
- * The flags argument to avio_open must be one of the following
- * constants, optionally ORed with other flags.
- * @{
- *)
-const
-  AVIO_FLAG_READ  = 1;                                      (**< read-only *)
-  AVIO_FLAG_WRITE = 2;                                      (**< write-only *)
-  AVIO_FLAG_READ_WRITE = {(AVIO_FLAG_READ|AVIO_FLAG_WRITE)} 3;  (**< read-write pseudo flag *)
-(**
- * @
- *)
-
-const
-(**
- * Use non-blocking mode.
- * If this flag is set, operations on the context will return
- * AVERROR(EAGAIN) if they can not be performed immediately.
- * If this flag is not set, operations on the context will never return
- * AVERROR(EAGAIN).
- * Note that this flag does not affect the opening/connecting of the
- * context. Connecting a protocol will always block if necessary (e.g. on
- * network protocols) but never hang (e.g. on busy devices).
- * Warning:  non-blocking protocols is work-in-progress; this flag may be
- * silently ignored.
- *)
-  AVIO_FLAG_NONBLOCK = 8;
-
-(**
- * Use direct mode.
- * avio_read and avio_write should if possible be satisfied directly
- * instead of going through a buffer, and avio_seek will always
- * call the underlying seek function directly.
- *)
-  AVIO_FLAG_DIRECT = $8000;
-
-(**
- * Create and initialize a AVIOContext for accessing the
- * resource indicated by url.
- * @note When the resource indicated by url has been opened in
- * read+write mode, the AVIOContext can be used only for writing.
- *
- * @param s Used to return the pointer to the created AVIOContext.
- * In case of failure the pointed to value is set to NULL.
- * @param flags flags which control how the resource indicated by url
- * is to be opened
- * @return 0 in case of success, a negative value corresponding to an
- * AVERROR code in case of failure
- *)
-function avio_open(s: PPAVIOContext; url: {const} PAnsiChar; flags: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Create and initialize a AVIOContext for accessing the
- * resource indicated by url.
- * @note When the resource indicated by url has been opened in
- * read+write mode, the AVIOContext can be used only for writing.
- *
- * @param s Used to return the pointer to the created AVIOContext.
- * In case of failure the pointed to value is set to NULL.
- * @param flags flags which control how the resource indicated by url
- * is to be opened
- * @param int_cb an interrupt callback to be used at the protocols level
- * @param options  A dictionary filled with protocol-private options. On return
- * this parameter will be destroyed and replaced with a dict containing options
- * that were not found. May be NULL.
- * @return 0 in case of success, a negative value corresponding to an
- * AVERROR code in case of failure
- *)
-function avio_open2(s: PPAVIOContext; {const} url: PAnsiChar; flags: cint;
-	{const} int_cb: PAVIOInterruptCB; options: PPAVDictionary): cint;
-  cdecl; external av__format;
-
-(**
- * Close the resource accessed by the AVIOContext s and free it.
- * This function can only be used if s was opened by avio_open().
- *
- * The internal buffer is automatically flushed before closing the
- * resource.
- *
- * @return 0 on success, an AVERROR < 0 on error.
- * @see avio_close
- *)
-function avio_close(s: PAVIOContext): cint;
-  cdecl; external av__format;
-
-(**
- * Close the resource accessed by the AVIOContext *s, free it
- * and set the pointer pointing to it to NULL.
- * This function can only be used if s was opened by avio_open().
- *
- * The internal buffer is automatically flushed before closing the
- * resource.
- *
- * @return 0 on success, an AVERROR < 0 on error.
- * @see avio_close
- *)
-function avio_closep(s: PPAVIOContext): cint;
-  cdecl; external av__format;
-
-(**
- * Open a write only memory stream.
- *
- * @param s new IO context
- * @return zero if no error.
- *)
-function avio_open_dyn_buf(s: PPAVIOContext): cint;
-  cdecl; external av__format;
-
-(**
- * Return the written size and a pointer to the buffer.
- * The AVIOContext stream is left intact.
- * The buffer must NOT be freed.
- * No padding is added to the buffer.
- *
- * @param s IO context
- * @param pbuffer pointer to a byte buffer
- * @return the length of the byte buffer
- *)
-function avio_get_dyn_buf(s: PAVIOContext; var pbuffer: Pcuint8): cint;
-  cdecl; external av__format;
-
-(**
- * Return the written size and a pointer to the buffer. The buffer
- * must be freed with av_free().
- * Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
- *
- * @param s IO context
- * @param pbuffer pointer to a byte buffer
- * @return the length of the byte buffer
- *)
-function avio_close_dyn_buf(s: PAVIOContext; var pbuffer: Pcuint8): cint;
-  cdecl; external av__format;
-
-(**
- * Iterate through names of available protocols.
- *
- * @param opaque A private pointer representing current protocol.
- *        It must be a pointer to NULL on first iteration and will
- *        be updated by successive calls to avio_enum_protocols.
- * @param output If set to 1, iterate over output protocols,
- *               otherwise over input protocols.
- *
- * @return A static string containing the name of current protocol or NULL
- *)
-function avio_enum_protocols(var opaque: Pointer; output: cint): {const} PAnsiChar;
-  cdecl; external av__format;
-
-(**
- * Pause and resume playing - only meaningful if using a network streaming
- * protocol (e.g. MMS).
- * @param pause 1 for pause, 0 for resume
- *)
-function avio_pause(h: PAVIOContext; pause: cint): cint;
-  cdecl; external av__format;
-
-(**
- * Seek to a given timestamp relative to some component stream.
- * Only meaningful if using a network streaming protocol (e.g. MMS.).
- * @param stream_index The stream index that the timestamp is relative to.
- *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE
- *        units from the beginning of the presentation.
- *        If a stream_index >= 0 is used and the protocol does not support
- *        seeking based on component streams, the call will fail with ENOTSUP.
- * @param timestamp timestamp in AVStream.time_base units
- *        or if there is no stream specified then in AV_TIME_BASE units.
- * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
- *        and AVSEEK_FLAG_ANY. The protocol may silently ignore
- *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
- *        fail with ENOTSUP if used and not supported.
- * @return >= 0 on success
- * @see AVInputFormat: : read_seek
- *)
-function avio_seek_time(h: PAVIOContext; stream_index: cint;
-                        timestamp: cint64; flags: cint): cint64;
-  cdecl; external av__format;
-
-(* Avoid a warning. The header can not be included because it breaks c++. *)
-type
-  PAVBPrint = ^TAVBPrint;
-  TAVBPrint = record
-	end;
-
-(**
- * Read contents of h into print buffer, up to max_size bytes, or up to EOF.
- *
- * @return 0 for success (max_size bytes read or EOF reached), negative error
- * code otherwise
- *)
-function avio_read_to_bprint(h: PAVIOContext; pb: PAVBPrint; max_size: size_t): cint;
-  cdecl; external av__format;
-
-(**
- * Accept and allocate a client context on a server context.
- * @param  s the server context
- * @param  c the client context, must be unallocated
- * @return   >= 0 on success or a negative value corresponding
- *           to an AVERROR on failure
- *)
-function avio_accept(s: PAVIOContext; c: PPAVIOContext): cint;
-  cdecl; external av__format;
-
-(**
- * Perform one step of the protocol handshake to accept a new client.
- * This function must be called on a client returned by avio_accept() before
- * using it as a read/write context.
- * It is separate from avio_accept() because it may block.
- * A step of the handshake is defined by places where the application may
- * decide to change the proceedings.
- * For example, on a protocol with a request header and a reply header, each
- * one can constitute a step because the application may use the parameters
- * from the request to change parameters in the reply; or each individual
- * chunk of the request can constitute a step.
- * If the handshake is already finished, avio_handshake() does nothing and
- * returns 0 immediately.
- *
- * @param  c the client context to perform the handshake on
- * @return   0   on a complete and successful handshake
- *           > 0 if the handshake progressed, but is not complete
- *           < 0 for an AVERROR code
- *)
-function avio_handshake(c: PAVIOContext): cint;
-  cdecl; external av__format;
-
+    we_do_not_use_av_class: pointer;
+    buffer: ^cuchar;
+    we_do_not_use_buffer_size: cint;
+    we_do_not_use_buf_ptr: pcuchar;
+    we_do_not_use_buf_end: pcuchar;
+    opaque: pointer;
+    we_do_not_use_read_packet: cfunctionpointer;
+    we_do_not_use_write_packet: cfunctionpointer;
+    we_do_not_use_seek: cfunctionpointer;
+    pos: cint64;
+    eof_reached: cint;
+    we_do_not_use_write_flag: cint;
+    we_do_not_use_max_packet_size: cint;
+    we_do_not_use_checksum: culong;
+    we_do_not_use_checksum_ptr: pcuchar;
+    we_do_not_use_update_checksum: cfunctionpointer;
+    error: cint;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  TReadWriteFunc = function(opaque: pointer; buf: pbytearray; buf_size: cint): cint; cdecl;
+  TSeekFunc = function(opaque: pointer; offset: cint64; whence: cint): cint64; cdecl;
+function avio_alloc_context(buffer: pcuint8; buffer_size: cint; write_flag: cint; opaque: pointer; read_packet: TReadWriteFunc; write_packet: TReadWriteFunc; seek: TSeekFunc): PAVIOContext; cdecl; external 'libavformat';
+function avio_feof(s: PAVIOContext): cint; cdecl; external 'libavformat';
+function avio_size(s: PAVIOContext): cint64; cdecl; external 'libavformat';
 implementation
-
-(**
- * For SEEK_CUR on Windows
- * values taken from stdio.h of C
- *)
-{$IFNDEF SEEK_SET}
-const
-  SEEK_SET = 0;
-{$ENDIF}
-
-{$IFNDEF SEEK_CUR}
-const
-  SEEK_CUR = 1;
-{$ENDIF}
-
-{$IFNDEF SEEK_END}
-const
-  SEEK_END = 2;
-{$ENDIF}
-
-function avio_tell(s: PAVIOContext): cint64; {$IFDEF HasInline}inline;{$ENDIF}
-begin
-  Result := avio_seek(s, 0, SEEK_CUR);
-end;
-
-
 end.
diff --git a/src/lib/ffmpeg-4.0/avutil.pas b/src/lib/ffmpeg-4.0/avutil.pas
index c3b17d29b..a208314ed 100644
--- a/src/lib/ffmpeg-4.0/avutil.pas
+++ b/src/lib/ffmpeg-4.0/avutil.pas
@@ -1,46 +1,14 @@
-(*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversions of
- *
- * libavutil/avutil.h:
- * version: 54.7.100
- *
- *)
-
 unit avutil;
 
 {$IFDEF FPC}
   {$MODE DELPHI}
+  {$MODESWITCH ADVANCEDRECORDS}
   {$PACKENUM 4}    (* use 4-byte enums *)
   {$PACKRECORDS C} (* C/C++-compatible record packing *)
-  {$MACRO ON}      (* Turn macro support on *)
 {$ELSE}
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I ff_api-defines.inc}  (* FF_API_* defines *)
-
 {$IFDEF DARWIN}
   {$linklib libavutil}
 {$ENDIF}
@@ -53,12 +21,14 @@ interface
   {$IFDEF UNIX}
   BaseUnix,
   {$ENDIF}
+  SysUtils,
   UConfig;
 
+
 const
   (* Max. supported version by this header *)
   LIBAVUTIL_MAX_VERSION_MAJOR   = 56;
-  LIBAVUTIL_MAX_VERSION_MINOR   = 31;
+  LIBAVUTIL_MAX_VERSION_MINOR   = 70;
   LIBAVUTIL_MAX_VERSION_RELEASE = 100;
   LIBAVUTIL_MAX_VERSION = (LIBAVUTIL_MAX_VERSION_MAJOR * VERSION_MAJOR) +
                           (LIBAVUTIL_MAX_VERSION_MINOR * VERSION_MINOR) +
@@ -82,285 +52,135 @@ interface
 {$IFEND}
 
 type
-{$IFNDEF FPC}
-  // defines for Delphi
-  size_t = cardinal;
-{$ENDIF}
-  Psize_t = ^size_t;
-
-(**
- * Return the LIBAVUTIL_VERSION_INT constant.
- *)
-function avutil_version(): cuint;
-  cdecl; external av__util;
-
-(**
- * Return an informative version string. This usually is the actual release
- * version number or a git commit description. This string has no fixed format
- * and can change any time. It should never be parsed by code.
- *)
-function av_version_info(): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Return the libavutil build-time configuration.
- *)
-function avutil_configuration(): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Return the libavutil license.
- *)
-function avutil_license(): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * @addtogroup lavu_media Media Type
- * @brief Media Type
- *)
+  (*
+   * We use this record as the last element of records that are not supposed
+   * to be allocated by pascal code either because the declaration of the
+   * record has never been completed or because FFmpeg does the allocation
+   * internally.
+   *
+   * The exceed_stack array has been declared as 10MB array because the default
+   * soft stack limit on Linux is less than that. So every time someone tries
+   * to allocate this structure on the stack, it will crash unless the soft
+   * limit has been raised.
+   *
+   * The existence of a constructor will cause Free Pascal to issue a warning
+   * if an element of this type has been created without calling the
+   * constructor.
+   *)
+  incomplete_record = record
+    exceed_stack: array [0..10000000] of byte;
+    constructor Never_Call(dummy: integer);
+  end;
 
 type
-
-  PAVFile = pointer;
-
-  TAVMediaType = (
-    AVMEDIA_TYPE_UNKNOWN = -1,  ///< Usually treated as AVMEDIA_TYPE_DATA
-    AVMEDIA_TYPE_VIDEO,
-    AVMEDIA_TYPE_AUDIO,
-    AVMEDIA_TYPE_DATA,          ///< Opaque data information usually continuous
-    AVMEDIA_TYPE_SUBTITLE,
-    AVMEDIA_TYPE_ATTACHMENT,    ///< Opaque data information usually sparse
-    AVMEDIA_TYPE_NB
-  );
-
-(**
- * Return a string describing the media_type enum, NULL if media_type
- * is unknown.
- *)
-function av_get_media_type_string(media_type: TAVMediaType): PAnsiChar;
-  cdecl; external av__util;
+  (*
+   * The C standard allows for function pointers to have a different size than
+   * data pointers. In practice the size differs only on exotic architectures.
+   *)
+  cfunctionpointer = procedure;cdecl;
+  (*
+   * Here we assume that the size of an enum is the same regardless of the
+   * values it needs to hold. This is not always the case. The AMD64 System V
+   * ABI says:
+   *
+   *     C++ and some implementations of C permit enums larger than an int.
+   *     The underlying type is bumped to an unsigned int, long int or
+   *     unsigned long int, in that order.
+   *
+   * Apart from that there are systems where the default enum size is smaller
+   * than an int. But these are unlikely to run FFmpeg.
+   *
+   * So don't use this type to replace enums that don't fit into 32 bits.
+   *)
+  cenum = cint;
 
 const
-  FF_LAMBDA_SHIFT = 7;
-  FF_LAMBDA_SCALE = (1 shl FF_LAMBDA_SHIFT);
-  FF_QP2LAMBDA    = 118; ///< factor to convert from H.263 QP to lambda
-  FF_LAMBDA_MAX   = (256*128-1);
-
-  FF_QUALITY_SCALE = FF_LAMBDA_SCALE; //FIXME maybe remove
-
-(**
- * @brief Undefined timestamp value
- *
- * Usually reported by demuxer that work on containers that do not provide
- * either pts or dts.
- *)
-
-  AV_NOPTS_VALUE   = $8000000000000000;
-
-(**
- * Internal time base represented as integer
- *)
-
-  AV_TIME_BASE     = 1000000;
-
-(**
- * Internal time base represented as fractional value
- *)
-
-  AV_TIME_BASE_Q   : TAVRational = (num: 1; den: AV_TIME_BASE);
-
-(**
- * @}
- * @}
- * @defgroup lavu_picture Image related
- *
- * AVPicture types, pixel formats and basic image planes manipulation.
- *
- * @
- *)
+  AV_LOG_FATAL = 8;
+  AV_NOPTS_VALUE = -9223372036854775808;
+  AV_NUM_DATA_POINTERS = 8;
+  AV_TIME_BASE = 1000000;
+{$IFDEF UNIX}
+  EAGAIN = ESysEAGAIN;
+{$ELSE}
+  EAGAIN = 11;
+{$ENDIF}
 
 type
-  TAVPictureType = (
-    AV_PICTURE_TYPE_NONE = 0, ///< Undefined
-    AV_PICTURE_TYPE_I,     ///< Intra
-    AV_PICTURE_TYPE_P,     ///< Predicted
-    AV_PICTURE_TYPE_B,     ///< Bi-dir predicted
-    AV_PICTURE_TYPE_S,     ///< S(GMC)-VOP MPEG-4
-    AV_PICTURE_TYPE_SI,    ///< Switching Intra
-    AV_PICTURE_TYPE_SP,    ///< Switching Predicted
-    AV_PICTURE_TYPE_BI     ///< BI type
+  TAVSampleFormat = (
+    AV_SAMPLE_FMT_U8,
+    AV_SAMPLE_FMT_S16,
+    AV_SAMPLE_FMT_S32,
+    AV_SAMPLE_FMT_FLT,
+    AV_SAMPLE_FMT_DBL
   );
-
-(**
- * Return a single letter to describe the given picture type
- * pict_type.
- *
- * @param[in] pict_type the picture type @return a single character
- * representing the picture type, '?' if pict_type is unknown
- *)
-function av_get_picture_type_char(pict_type: TAVPictureType): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Return x default pointer in case p is NULL.
- *)
-function av_x_if_null(p: {const} pointer; x: {const} pointer): pointer; {$IFDEF HasInline}inline;{$ENDIF}
-
-(**
- * Compute the length of an integer list.
- *
- * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
- * @param term    list terminator (usually 0 or -1)
- * @param list    pointer to the list
- * @return  length of the list, in elements, not counting the terminator
- *)
-function av_int_list_length_for_size(elsize: cuint;
-                                     {const} list: pointer; term: cuint64): cuint; {av_pure}
-  cdecl; external av__util;
-
-(**
- * Compute the length of an integer list.
- *
- * @param term  list terminator (usually 0 or -1)
- * @param list  pointer to the list
- * @return  length of the list, in elements, not counting the terminator
- *)
-function av_int_list_length({const} list: pointer; term: cuint64): cuint;
-
-(**
- * Open a file using a UTF-8 filename.
- * The API of this function matches POSIX fopen(), errors are returned through
- * errno.
- *)
-function av_fopen_utf8(path: {const} Pchar; mode: {const} Pchar): PAVFile;
-  cdecl; external av__util;
-
-(**
- * Return the fractional representation of the internal time base.
- *)
-function av_get_time_base_q: TAVRational;
-  cdecl; external av__util;
-
-const AV_FOURCC_MAX_STRING_SIZE = 32;
-
-function av_fourcc2str(fourcc: cuint64): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Fill the provided buffer with a string containing a FourCC (four-character
- * code) representation.
- *
- * @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
- * @param fourcc the fourcc to represent
- * @return the buffer in input
- *)
-function av_fourcc_make_string(buf: PAnsiChar; fourcc: cuint64): PAnsiChar;
-  cdecl; external av__util;
-
-{$INCLUDE libavutil/cpu.pas}
-
-{$INCLUDE libavutil/dict.pas}
-
-{$INCLUDE libavutil/error.pas}
-
-{$INCLUDE libavutil/mathematics.pas}
-
-{$INCLUDE libavutil/mem.pas}
-
-{$INCLUDE libavutil/log.pas}
-
-{$INCLUDE libavutil/pixfmt.pas}
-
-{$INCLUDE libavutil/samplefmt.pas}
-
-{$INCLUDE libavutil/opt.pas}
-
-{$INCLUDE libavutil/buffer.pas}
-
-{$INCLUDE libavutil/frame.pas}
-
-
-(* libavutil/common.h *) // until now MKTAG and MKBETAG is all from common.h KMS 19/5/2010
-
-(**
- * MKTAG and MKBETAG are usually used to convert a magic string to an enumeration index.
- * In Pascal this can probably not be used and the functions could be removed.
- * KMS 8/6/2012
- *)
-function MKTAG  (a, b, c, d: AnsiChar): integer; {$IFDEF HasInline}inline;{$ENDIF}
-function MKBETAG(a, b, c, d: AnsiChar): integer; {$IFDEF HasInline}inline;{$ENDIF}
-
+  PAVPixelFormat = ^TAVPixelFormat;
+  TAVPixelFormat = (
+    AV_PIX_FMT_RGB24 = 2,
+    AV_PIX_FMT_BGR24,
+    AV_PIX_FMT_RGBA = 26,
+    AV_PIX_FMT_BGRA = 28
+  );
+  TAVMediaType = (
+    AVMEDIA_TYPE_VIDEO,
+    AVMEDIA_TYPE_AUDIO
+  );
+  ppcuint8 = ^pcuint8;
+  PAVFrame = ^TAVFrame;
+  PPAVFrame = ^PAVFrame;
+  TAVFrame = record
+    data: array [0..AV_NUM_DATA_POINTERS-1] of ^cuint8;
+    linesize: array [0..AV_NUM_DATA_POINTERS-1] of cint;
+    extended_data: ^pcuint8;
+    we_do_not_use_width: cint;
+    we_do_not_use_height: cint;
+    nb_samples: cint;
+    we_do_not_use_format: cint;
+    we_do_not_use_key_frame: cint;
+    we_do_not_use_pict_type: cenum;
+    we_do_not_use_sample_aspect_ratio: TAVRational;
+    pts: cint64;
+    pkt_pts: cint64;
+    pkt_dts: cint64;
+    we_do_not_use_coded_picture_number: cint;
+    we_do_not_use_display_picture_number: cint;
+    we_do_not_use_quality: cint;
+    we_do_not_use_opaque: pointer;
+    we_do_not_use_error: array [0..AV_NUM_DATA_POINTERS-1] of cuint64;
+    repeat_pict: cint;
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+  PAVDictionary = ^TAVDictionary;
+  PPAVDictionary = ^PAVDictionary;
+  TAVDictionary = record
+    do_not_instantiate_this_record: incomplete_record;
+  end;
+procedure av_free(ptr: pointer); cdecl; external 'libavutil';
+procedure av_freep(ptr: pointer); cdecl; external 'libavutil';
+function av_malloc(size: csize_t): pointer; cdecl; external 'libavutil';
+function avutil_version(): cuint; cdecl; external 'libavutil';
+function av_frame_alloc(): PAVFrame; cdecl; external 'libavutil';
+procedure av_frame_free(frame: PPAVFrame); cdecl; external 'libavutil';
+function av_image_alloc(pointers: ppcuint8; linesizes: pcint; w: cint; h: cint; pix_fmt: TAVPixelFormat; align: cint): cint; cdecl; external 'libavutil';
+function AVERROR(e: cint): cint; {$IFDEF HasInline}inline;{$ENDIF}
+function av_opt_set_int(obj: pointer; name: PAnsiChar; val: cint64; search_flags: cint): cint; cdecl; external 'libavutil';
+function av_opt_set_channel_layout(obj: pointer; name: PAnsiChar; ch_layout: cint64; search_flags: cint): cint; cdecl; external 'libavutil';
+function av_opt_set_sample_fmt(obj: pointer; name: PAnsiChar; fmt: TAVSampleFormat; search_flags: cint): cint; cdecl; external 'libavutil';
+function av_samples_alloc(var audio_data: pcuint8; linesize: pcint; nb_channels: cint; nb_samples: cint; sample_fmt: TAVSampleFormat; align: cint): cint; cdecl; external 'libavutil';
+function av_get_packed_sample_fmt(sample_fmt: TAVSampleFormat): TAVSampleFormat; cdecl; external 'libavutil';
+function av_get_bytes_per_sample(sample_fmt: TAVSampleFormat): cint; cdecl; external 'libavutil';
+procedure av_log_set_level(level: cint); cdecl; external 'libavutil';
 implementation
-
-uses
-  SysUtils;
-
-function av_x_if_null(p: {const} pointer; x: {const} pointer): pointer; {$IFDEF HasInline}inline;{$ENDIF}
+function AVERROR(e: cint): cint; {$IFDEF HasInline}inline;{$ENDIF}
 begin
-  if p = nil then
-    Result := x
+  if EAGAIN < 0 then
+    AVERROR := e
   else
-    Result := p;
+    AVERROR := -e;
 end;
 
-function av_int_list_length({const} list: pointer; term: cuint64): cuint;
-begin
-  // KMS 2013: It is not really clear whether it should be sizeof(pointer) or sizeof(cint).
-  // Going for the larger one (pointer) should at least prevent buffer overflows.
-  // So, the result is either 4 byte or 8 byte.
-  Result := av_int_list_length_for_size(sizeof(pointer), list, term);
-end;
-
-(* libavutil/common.h *)
-
-function MKTAG(a, b, c, d: AnsiChar): integer; {$IFDEF HasInline}inline;{$ENDIF}
-begin
-  Result := (ord(a) or (ord(b) shl 8) or (ord(c) shl 16) or (ord(d) shl 24));
-end;
-
-function MKBETAG(a, b, c, d: AnsiChar): integer; {$IFDEF HasInline}inline;{$ENDIF}
-begin
-  Result := (ord(d) or (ord(c) shl 8) or (ord(b) shl 16) or (ord(a) shl 24));
-end;
-
-(* libavutil/error.h *)
-
-function av_make_error_string(errbuf: Pchar; errbuf_size: size_t; errnum: cint): Pchar; {$IFDEF HasInline}inline;{$ENDIF}
-begin
-  av_strerror(errnum, errbuf, errbuf_size);
-  av_make_error_string := errbuf;
-end;
-
-function av_err2str(errnum: cint): pchar; {$IFDEF HasInline}inline;{$ENDIF}
-var
-  errbuf: Pchar;
-begin
-  errbuf := stralloc(AV_ERROR_MAX_STRING_SIZE);
-  av_make_error_string(errbuf, AV_ERROR_MAX_STRING_SIZE, errnum);
-  av_err2str := errbuf;
-end;
-
-(* libavutil/mem.h *)
-
-function av_size_mult(a: size_t; b: size_t; r: Psize_t): size_t;
-  cdecl; external av__util;
-(* To Be Implemented, March 2012 KMS *)
-//function av_size_mult(a: size_t; b: size_t; r: pointer): size_t;
-//begin
-//    {
-//    size_t t = a * b;
-//    /* Hack inspired from glibc: only try the division if nelem and elsize
-//     * are both greater than sqrt(SIZE_MAX). */
-//    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)
-//        return AVERROR(EINVAL);
-//    *r = t;
-//    return 0;
-//}
-//end;
-
-function AVERROR(e: integer): integer;
+constructor incomplete_record.Never_Call(dummy: integer);
 begin
-  AVERROR := AVERROR_SIGN * e;
+  abort;
 end;
 
 end.
diff --git a/src/lib/ffmpeg-4.0/ff_api-defines.inc b/src/lib/ffmpeg-4.0/ff_api-defines.inc
deleted file mode 100644
index 9ac8eeddc..000000000
--- a/src/lib/ffmpeg-4.0/ff_api-defines.inc
+++ /dev/null
@@ -1,169 +0,0 @@
-// prevent pasdoc from parsing this file
-{$IFNDEF PASDOC}
-
-(**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- *)
-
-(** avcodec defines *)
-{$ifndef FF_API_LOWRES}
-{$define FF_API_LOWRES           := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_DEBUG_MV}
-{$define FF_API_DEBUG_MV         := (LIBAVCODEC_VERSION_MAJOR < 58)}
-{$endif}
-{$ifndef FF_API_AVCTX_TIMEBASE}
-{$define FF_API_AVCTX_TIMEBASE   := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_CODED_FRAME}
-{$define FF_API_CODED_FRAME      := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_SIDEDATA_ONLY_PKT}
-{$define FF_API_SIDEDATA_ONLY_PKT:= (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_VDPAU_PROFILE}
-{$define FF_API_VDPAU_PROFILE    := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_CONVERGENCE_DURATION}
-{$define FF_API_CONVERGENCE_DURATION := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_AVPICTURE}
-{$define FF_API_AVPICTURE        := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_AVPACKET_OLD_API}
-{$define FF_API_AVPACKET_OLD_API := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_RTP_CALLBACK}
-{$define FF_API_RTP_CALLBACK     := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_VBV_DELAY}
-{$define FF_API_VBV_DELAY        := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_CODER_TYPE}
-{$define FF_API_CODER_TYPE       := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_STAT_BITS}
-{$define FF_API_STAT_BITS        := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_PRIVATE_OPT}
-{$define FF_API_PRIVATE_OPT      := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_ASS_TIMING}
-{$define FF_API_ASS_TIMING       := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_OLD_BSF}
-{$define FF_API_OLD_BSF          := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_COPY_CONTEXT}
-{$define FF_API_COPY_CONTEXT     := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_GET_CONTEXT_DEFAULTS}
-{$define FF_API_GET_CONTEXT_DEFAULTS := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_NVENC_OLD_NAME}
-{$define FF_API_NVENC_OLD_NAME   := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_STRUCT_VAAPI_CONTEXT}
-{$define FF_API_STRUCT_VAAPI_CONTEXT := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_MERGE_SD_API}
-{$define FF_API_MERGE_SD_API     := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_TAG_STRING}
-{$define FF_API_TAG_STRING       := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_GETCHROMA}
-{$define FF_API_GETCHROMA        := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_CODEC_GET_SET}
-{$define FF_API_CODEC_GET_SET    := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_USER_VISIBLE_AVHWACCEL}
-{$define FF_API_USER_VISIBLE_AVHWACCEL := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_LOCKMGR}
-{$define FF_API_LOCKMGR          := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_NEXT}
-{$define FF_API_NEXT             := (LIBAVCODEC_VERSION_MAJOR < 59)}
-{$endif}
-
-(* avutil defines *)
-{$ifndef FF_API_VAAPI}
-{$define FF_API_VAAPI                    := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_FRAME_QP}
-{$define FF_API_FRAME_QP                 := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_PLUS1_MINUS1}
-{$define FF_API_PLUS1_MINUS1             := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_ERROR_FRAME}
-{$define FF_API_ERROR_FRAME              := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_PKT_PTS}
-{$define FF_API_PKT_PTS                  := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_CRYPTO_SIZE_T}
-{$define FF_API_CRYPTO_SIZE_T            := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_FRAME_GET_SET}
-{$define FF_API_FRAME_GET_SET            := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-{$ifndef FF_API_PSEUDOPAL}
-{$define FF_API_PSEUDOPAL                := (LIBAVUTIL_VERSION_MAJOR < 57)}
-{$endif}
-
-(** avformat FF_API defines *)
-{$ifndef FF_API_COMPUTE_PKT_FIELDS2}
-{$define FF_API_COMPUTE_PKT_FIELDS2   := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_OLD_OPEN_CALLBACKS}
-{$define FF_API_OLD_OPEN_CALLBACKS    := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_LAVF_AVCTX}
-{$define FF_API_LAVF_AVCTX            := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_HTTP_USER_AGENT}
-{$define FF_API_HTTP_USER_AGENT       := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_HLS_WRAP}
-{$define FF_API_HLS_WRAP              := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_LAVF_KEEPSIDE_FLAG}
-{$define FF_API_LAVF_KEEPSIDE_FLAG    := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_OLD_ROTATE_API}
-{$define FF_API_OLD_ROTATE_API        := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_FORMAT_GET_SET}
-{$define FF_API_FORMAT_GET_SET        := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_OLD_AVIO_EOF_0}
-{$define FF_API_OLD_AVIO_EOF_0        := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_LAVF_FFSERVER}
-{$define FF_API_LAVF_FFSERVER         := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_FORMAT_FILENAME}
-{$define FF_API_FORMAT_FILENAME       := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_OLD_RTSP_OPTIONS}
-{$define FF_API_OLD_RTSP_OPTIONS      := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-{$ifndef FF_API_NEXT}
-{$define FF_API_NEXT                  := (LIBAVFORMAT_VERSION_MAJOR < 59)}
-{$endif}
-
-{$ifndef FF_API_R_FRAME_RATE}
-{$define FF_API_R_FRAME_RATE          := 1}
-{$endif}
-
-(** swscale FF_API defines *)
-{$ifndef FF_API_SWS_VECTOR}
-{$define FF_API_SWS_VECTOR            := (LIBSWSCALE_VERSION_MAJOR < 6)}
-{$endif}
-
-{$ENDIF PASDOC}
diff --git a/src/lib/ffmpeg-4.0/libavcodec/audioconvert.pas b/src/lib/ffmpeg-4.0/libavcodec/audioconvert.pas
deleted file mode 100644
index cf6c96bbd..000000000
--- a/src/lib/ffmpeg-4.0/libavcodec/audioconvert.pas
+++ /dev/null
@@ -1,294 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/channel_layout.h and libavcodec/audioconvert.h
- * avutil version 52.66.100; avcodec version 55.52.102
- *
- *)
-
-(** libavutil/channel_layout.h **)
-
-(**
- * @file
- * audio  channel layout utility functions
- *)
-
-(**
- * @defgroup channel_masks Audio channel masks
- *
- * A channel layout is a 64-bits integer with a bit set for every channel.
- * The number of bits set must be equal to the number of channels.
- * The value 0 means that the channel layout is not known.
- * @note this data structure is not powerful enough to handle channels
- * combinations that have the same channel multiple times, such as
- * dual-mono.
- *
- *)
-const
-  {* Audio channel masks *}
-  AV_CH_FRONT_LEFT             = $00000001;
-  AV_CH_FRONT_RIGHT            = $00000002;
-  AV_CH_FRONT_CENTER           = $00000004;
-  AV_CH_LOW_FREQUENCY          = $00000008;
-  AV_CH_BACK_LEFT              = $00000010;
-  AV_CH_BACK_RIGHT             = $00000020;
-  AV_CH_FRONT_LEFT_OF_CENTER   = $00000040;
-  AV_CH_FRONT_RIGHT_OF_CENTER  = $00000080;
-  AV_CH_BACK_CENTER            = $00000100;
-  AV_CH_SIDE_LEFT              = $00000200;
-  AV_CH_SIDE_RIGHT             = $00000400;
-  AV_CH_TOP_CENTER             = $00000800;
-  AV_CH_TOP_FRONT_LEFT         = $00001000;
-  AV_CH_TOP_FRONT_CENTER       = $00002000;
-  AV_CH_TOP_FRONT_RIGHT        = $00004000;
-  AV_CH_TOP_BACK_LEFT          = $00008000;
-  AV_CH_TOP_BACK_CENTER        = $00010000;
-  AV_CH_TOP_BACK_RIGHT         = $00020000;
-  AV_CH_STEREO_LEFT            = $20000000;  ///< Stereo downmix.
-  AV_CH_STEREO_RIGHT           = $40000000;  ///< See AV_CH_STEREO_LEFT.
-  AV_CH_WIDE_LEFT              = $0000000080000000;
-  AV_CH_WIDE_RIGHT             = $0000000100000000;
-  AV_CH_SURROUND_DIRECT_LEFT   = $0000000200000000;
-  AV_CH_SURROUND_DIRECT_RIGHT  = $0000000400000000;
-  AV_CH_LOW_FREQUENCY_2        = $0000000800000000;
-
-(** Channel mask value used for AVCodecContext.request_channel_layout
- *  to indicate that the user requests the channel order of the decoder output
- *  to be the native codec channel order.
- *)
-  AV_CH_LAYOUT_NATIVE          = $8000000000000000;
-
-(**
- * @}
- * @defgroup channel_mask_c Audio channel convenience macros
- * @{
- * *)
-  AV_CH_LAYOUT_MONO            = (AV_CH_FRONT_CENTER);
-  AV_CH_LAYOUT_STEREO          = (AV_CH_FRONT_LEFT or AV_CH_FRONT_RIGHT);
-  AV_CH_LAYOUT_2POINT1         = (AV_CH_LAYOUT_STEREO or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_2_1             = (AV_CH_LAYOUT_STEREO or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_SURROUND        = (AV_CH_LAYOUT_STEREO or AV_CH_FRONT_CENTER);
-  AV_CH_LAYOUT_3POINT1         = (AV_CH_LAYOUT_SURROUND or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_4POINT0         = (AV_CH_LAYOUT_SURROUND or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_4POINT1         = (AV_CH_LAYOUT_4POINT0 or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_2_2             = (AV_CH_LAYOUT_STEREO or AV_CH_SIDE_LEFT or AV_CH_SIDE_RIGHT);
-  AV_CH_LAYOUT_QUAD            = (AV_CH_LAYOUT_STEREO or AV_CH_BACK_LEFT or AV_CH_BACK_RIGHT);
-  AV_CH_LAYOUT_5POINT0         = (AV_CH_LAYOUT_SURROUND or AV_CH_SIDE_LEFT or AV_CH_SIDE_RIGHT);
-  AV_CH_LAYOUT_5POINT1         = (AV_CH_LAYOUT_5POINT0 or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_5POINT0_BACK    = (AV_CH_LAYOUT_SURROUND or AV_CH_BACK_LEFT or 
-                                  AV_CH_BACK_RIGHT);
-  AV_CH_LAYOUT_5POINT1_BACK    = (AV_CH_LAYOUT_5POINT0_BACK or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_6POINT0         = (AV_CH_LAYOUT_5POINT0 or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_6POINT0_FRONT   = (AV_CH_LAYOUT_2_2 or AV_CH_FRONT_LEFT_OF_CENTER or 
-                                  AV_CH_FRONT_RIGHT_OF_CENTER);
-  AV_CH_LAYOUT_HEXAGONAL       = (AV_CH_LAYOUT_5POINT0_BACK or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_6POINT1         = (AV_CH_LAYOUT_5POINT1 or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_6POINT1_BACK    = (AV_CH_LAYOUT_5POINT1_BACK or AV_CH_BACK_CENTER);
-  AV_CH_LAYOUT_6POINT1_FRONT   = (AV_CH_LAYOUT_6POINT0_FRONT or AV_CH_LOW_FREQUENCY);
-  AV_CH_LAYOUT_7POINT0         = (AV_CH_LAYOUT_5POINT0 or AV_CH_BACK_LEFT or AV_CH_BACK_RIGHT);
-  AV_CH_LAYOUT_7POINT0_FRONT   = (AV_CH_LAYOUT_5POINT0 or AV_CH_FRONT_LEFT_OF_CENTER or 
-                                  AV_CH_FRONT_RIGHT_OF_CENTER);
-  AV_CH_LAYOUT_7POINT1         = (AV_CH_LAYOUT_5POINT1 or AV_CH_BACK_LEFT or AV_CH_BACK_RIGHT);
-  AV_CH_LAYOUT_7POINT1_WIDE    = (AV_CH_LAYOUT_5POINT1 or AV_CH_FRONT_LEFT_OF_CENTER or 
-                                  AV_CH_FRONT_RIGHT_OF_CENTER);
-  AV_CH_LAYOUT_OCTAGONAL       = (AV_CH_LAYOUT_5POINT0 or AV_CH_BACK_LEFT or AV_CH_BACK_CENTER or 
-                                  AV_CH_BACK_RIGHT);
-  AV_CH_LAYOUT_HEXADECAGONAL   = (AV_CH_LAYOUT_OCTAGONAL or AV_CH_WIDE_LEFT or AV_CH_WIDE_RIGHT or AV_CH_TOP_BACK_LEFT or
-                                  AV_CH_TOP_BACK_RIGHT or AV_CH_TOP_BACK_CENTER or AV_CH_TOP_FRONT_CENTER or
-                                  AV_CH_TOP_FRONT_LEFT or AV_CH_TOP_FRONT_RIGHT);
-  AV_CH_LAYOUT_STEREO_DOWNMIX  = (AV_CH_STEREO_LEFT or AV_CH_STEREO_RIGHT);
-
-type
-  TAVMatrixEncoding = (
-    AV_MATRIX_ENCODING_NONE,
-    AV_MATRIX_ENCODING_DOLBY,
-    AV_MATRIX_ENCODING_DPLII,
-    AV_MATRIX_ENCODING_DPLIIX,
-    AV_MATRIX_ENCODING_DPLIIZ,
-    AV_MATRIX_ENCODING_DOLBYEX,
-    AV_MATRIX_ENCODING_DOLBYHEADPHONE,
-    AV_MATRIX_ENCODING_NB
-    );
-
-(**
- * Return a channel layout id that matches name, or 0 if no match is found.
- *
- * name can be one or several of the following notations,
- * separated by '+' or '|':
- * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
- *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
- * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
- *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
- * - a number of channels, in decimal, optionally followed by 'c', yielding
- *   the default channel layout for that number of channels (@see
- *   av_get_default_channel_layout);
- * - a channel layout mask, in hexadecimal starting with "0x" (see the
- *   AV_CH_* macros).
- *
- * Example: "stereo+FC" = "2+FC" = "2c+1c" = "0x7"
- *)
-function av_get_channel_layout(name: {const} PAnsiChar): cuint64;
-  cdecl; external av__util;
-
-(**
- * Return a description of a channel layout.
- * If nb_channels is <= 0, it is guessed from the channel_layout.
- *
- * @param buf put here the string containing the channel layout
- * @param buf_size size in bytes of the buffer
- *)
-procedure av_get_channel_layout_string(buf: PAnsiChar; buf_size: cint; nb_channels: cint; channel_layout: cuint64);
-  cdecl; external av__util;
-
-type
-// Type definition from libavutil/bprint.h
-// The actual record is padded to a certain number of bytes.
-// As of now (2013) this number is 1024.
-  PAVBPrint = ^TAVBPrint;
-  TAVBPrint = record
-    case integer of
-    0 : (paddedRecord: array[1..1024] of byte);
-    1 : (
-        str: PAnsiChar;  //** string so far */
-        len: cuint;      //** length so far */
-        size: cuint;     //** allocated memory */
-        size_max: cuint; //** maximum allocated memory */
-        reserved_internal_buffer: Pchar
-	);
-  end;
-
-(**
- * Append a description of a channel layout to a bprint buffer.
- *)
-procedure av_bprint_channel_layout(bp: PAVBPrint; nb_channels: cint; channel_layout: cuint64);
-  cdecl; external av__util;
-
-(**
- * Return the number of channels in the channel layout.
- *)
-function av_get_channel_layout_nb_channels(channel_layout: cuint64): cint;
-  cdecl; external av__util;
-
-(**
- * Return default channel layout for a given number of channels.
- *)
-function av_get_default_channel_layout(nb_channels: cint): cint64;
-  cdecl; external av__util;
-
-(**
- * Get the index of a channel in channel_layout.
- *
- * @param channel a channel layout describing exactly one channel which must be
- *                present in channel_layout.
- *
- * @return index of channel in channel_layout on success, a negative AVERROR
- *         on error.
- *)
-function av_get_channel_layout_channel_index(channel_layout: cuint64;
-                                             channel: cuint64): cint;
-  cdecl; external av__util;
-
-(**
- * Get the channel with the given index in channel_layout.
- *)
-function av_channel_layout_extract_channel(channel_layout: cuint64; index: cint): cuint64;
-  cdecl; external av__util;
-
-(**
- * Get the name of a given channel.
- *
- * @return channel name on success, NULL on error.
- *)
-function av_get_channel_name(channel: cuint64): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Get the description of a given channel.
- *
- * @param channel  a channel layout with a single channel
- * @return  channel description on success, NULL on error
- *)
-function av_get_channel_description(channel: cuint64): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Get the value and name of a standard channel layout.
- *
- * @param[in]  index   index in an internal list, starting at 0
- * @param[out] layout  channel layout mask
- * @param[out] name    name of the layout
- * @return  0  if the layout exists,
- *          <0 if index is beyond the limits
- *)
-function av_get_standard_channel_layout(index: cuint; layout: Pcuint64;
-                                   name: {const} PPAnsiChar): cint;
-  cdecl; external av__util;
-
-{$IFDEF FF_API_AUDIO_CONVERT}
-  
-(** libavcodec/audioconvert.h **)
-
-// type definition from libavcodec/audioconvert.c
-type
-  PAVAudioConvert = ^TAVAudioConvert;
-  TAVAudioConvert = record
-    in_channels, out_channels: cint;
-    fmt_pair: cint;
-  end;
-
-(**
- * Create an audio sample format converter context
- * @param out_fmt Output sample format
- * @param out_channels Number of output channels
- * @param in_fmt Input sample format
- * @param in_channels Number of input channels
- * @param[in] matrix Channel mixing matrix (of dimension in_channel*out_channels). Set to NULL to ignore.
- * @param flags See AV_CPU_FLAG_xx
- * @return NULL on error
- *)
-function av_audio_convert_alloc(out_fmt: TAVSampleFormat; out_channels: cint;
-                                in_fmt:  TAVSampleFormat; in_channels:  cint;
-                                matrix: {const} Pcfloat; flags: cint): PAVAudioConvert;
-  cdecl; external av__codec;
-
-(**
- * Free audio sample format converter context
- *)
-procedure av_audio_convert_free(ctx: PAVAudioConvert);
-  cdecl; external av__codec;
-
-type
-  P6 = array [1..6] of pointer;
-  I6 = array [1..6] of cint;
-
-(**
- * Convert between audio sample formats
- * @param[in] out array of output buffers for each channel. set to NULL to ignore processing of the given channel.
- * @param[in] out_stride distance between consecutive output samples (measured in bytes)
- * @param[in] in array of input buffers for each channel
- * @param[in] in_stride distance between consecutive input samples (measured in bytes)
- * @param len length of audio frame size (measured in samples)
- *)
-function av_audio_convert(ctx: PAVAudioConvert;
-                          out[6]: {const} P6; out_stride[6]: {const} I6;
-                           in[6]: {const} P6;  in_stride[6]: {const} I6; len: cint): cint;
-  cdecl; external av__codec;
-
-{$IFEND}
diff --git a/src/lib/ffmpeg-4.0/libavutil/buffer.pas b/src/lib/ffmpeg-4.0/libavutil/buffer.pas
deleted file mode 100644
index 5d7a747b0..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/buffer.pas
+++ /dev/null
@@ -1,310 +0,0 @@
-(*
- * AVOptions
- * copyright (c) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/buffer.h
- * avutil version 54.7.100
- *
- *)
-
-const
-(**
- * Always treat the buffer as read-only, even when it has only one
- * reference.
- *)
-  AV_BUFFER_FLAG_READONLY = (1 << 0);
-
-type
-(**
- * @defgroup lavu_buffer AVBuffer
- * @ingroup lavu_data
- *
- * @
- * AVBuffer is an API for reference-counted data buffers.
- *
- * There are two core objects in this API -- AVBuffer and AVBufferRef. AVBuffer
- * represents the data buffer itself; it is opaque and not meant to be accessed
- * by the caller directly, but only through AVBufferRef. However, the caller may
- * e.g. compare two AVBuffer pointers to check whether two different references
- * are describing the same data buffer. AVBufferRef represents a single
- * reference to an AVBuffer and it is the object that may be manipulated by the
- * caller directly.
- *
- * There are two functions provided for creating a new AVBuffer with a single
- * reference -- av_buffer_alloc() to just allocate a new buffer, and
- * av_buffer_create() to wrap an existing array in an AVBuffer. From an existing
- * reference, additional references may be created with av_buffer_ref().
- * Use av_buffer_unref() to free a reference (this will automatically free the
- * data once all the references are freed).
- *
- * The convention throughout this API and the rest of FFmpeg is such that the
- * buffer is considered writable if there exists only one reference to it (and
- * it has not been marked as read-only). The av_buffer_is_writable() function is
- * provided to check whether this is true and av_buffer_make_writable() will
- * automatically create a new writable buffer when necessary.
- * Of course nothing prevents the calling code from violating this convention,
- * however that is safe only when all the existing references are under its
- * control.
- *
- * @note Referencing and unreferencing the buffers is thread-safe and thus
- * may be done from multiple threads simultaneously without any need for
- * additional locking.
- *
- * @note Two different references to the same buffer can point to different
- * parts of the buffer (i.e. their AVBufferRef.data will not be equal).
- *)
-
-(**
- * A reference counted buffer type. It is opaque and is meant to be used through
- * references (AVBufferRef).
- *)
-  TAVBuffer = record
-  end;
-
-(**
- * A reference to a data buffer.
- *
- * The size of this struct is not a part of the public ABI and it is not meant
- * to be allocated directly.
- *)
-  PPAVBufferRef = ^PAVBufferRef;
-  PAVBufferRef = ^TAVBufferRef;
-  TAVBufferRef = record
-    buffer: TAVBuffer;
-    (**
-     * The data buffer. It is considered writable if and only if
-     * this is the only reference to the buffer, in which case
-     * av_buffer_is_writable() returns 1.
-     *)
-    data: PByte;
-    (**
-     * Size of data in bytes.
-     *)
-    size: cint;
-  end;
-
-  //callbacks used in the functions av_buffer_create and av_buffer_pool_init respectively
-  TFree  = procedure(opaque: pointer; data: pbyte);
-  TAlloc = function(size: cint): PAVBufferRef;
-  TAlloc2  = function(opaque: pointer; size: cint): PAVBufferRef;
-  TPoolFree = procedure(opaque: pointer);
-
-(**
- * The buffer pool. This structure is opaque and not meant to be accessed
- * directly. It is allocated with av_buffer_pool_init() and freed with
- * av_buffer_pool_uninit().
- *)
-  PPAVBufferPool = ^PAVBufferPool;
-  PAVBufferPool = ^TAVBufferPool;
-  TAVBufferPool = record
-  end;
-
-(**
- * Allocate an AVBuffer of the given size using av_malloc().
- *
- * @return an AVBufferRef of given size or NULL when out of memory
- *)
-function av_buffer_alloc(size: cint): PAVBufferRef;
-  cdecl; external av__util;
-
-(**
- * Same as av_buffer_alloc(), except the returned buffer will be initialized
- * to zero.
- *)
-function av_buffer_allocz(size: cint): PAVBufferRef;
-  cdecl; external av__util;
-
-(**
- * Create an AVBuffer from an existing array.
- *
- * If this function is successful, data is owned by the AVBuffer. The caller may
- * only access data through the returned AVBufferRef and references derived from
- * it.
- * If this function fails, data is left untouched.
- * @param data   data array
- * @param size   size of data in bytes
- * @param free   a callback for freeing this buffer's data
- * @param opaque parameter to be got for processing or passed to free
- * @param flags  a combination of AV_BUFFER_FLAG_*
- *
- * @return an AVBufferRef referring to data on success, NULL on failure.
- *)
-
-function av_buffer_create(data: PByte; size: cint;
-                          free: TFree;
-                          opaque: pointer; flags: cint): PAVBufferRef;
-  cdecl; external av__util;
-
-(**
- * Default free callback, which calls av_free() on the buffer data.
- * This function is meant to be passed to av_buffer_create(), not called
- * directly.
- *)
-procedure av_buffer_default_free(opaque: pointer; data: pbyte);
-  cdecl; external av__util;
-
-(**
- * Create a new reference to an AVBuffer.
- *
- * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
- * failure.
- *)
-function av_buffer_ref(buf: PAVBufferRef): PAVBufferRef;
-  cdecl; external av__util;
-
-(**
- * Free a given reference and automatically free the buffer if there are no more
- * references to it.
- *
- * @param buf the reference to be freed. The pointer is set to NULL on return.
- *)
-procedure av_buffer_unref(buf: PPAVBufferRef);
-  cdecl; external av__util;
-
-(**
- * @return 1 if the caller may write to the data referred to by buf (which is
- * true if and only if buf is the only reference to the underlying AVBuffer).
- * Return 0 otherwise.
- * A positive answer is valid until av_buffer_ref() is called on buf.
- *)
-function av_buffer_is_writable(buf: {const} PAVBufferRef): cint;
-  cdecl; external av__util;
-
-(**
- * @return the opaque parameter set by av_buffer_create.
- *)
-procedure av_buffer_get_opaque(buf: {const} PAVBufferRef);
-  cdecl; external av__util;
-
-function av_buffer_get_ref_count(buf: {const} PAVBufferRef): cint;
-  cdecl; external av__util;
-
-(**
- * Create a writable reference from a given buffer reference, avoiding data copy
- * if possible.
- *
- * @param buf buffer reference to make writable. On success, buf is either left
- *            untouched, or it is unreferenced and a new writable AVBufferRef is
- *            written in its place. On failure, buf is left untouched.
- * @return 0 on success, a negative AVERROR on failure.
- *)
-function av_buffer_make_writable(buf: PPAVBufferRef): cint;
-  cdecl; external av__util;
-
-(**
- * Reallocate a given buffer.
- *
- * @param buf  a buffer reference to reallocate. On success, buf will be
- *             unreferenced and a new reference with the required size will be
- *             written in its place. On failure buf will be left untouched. *buf
- *             may be NULL, then a new buffer is allocated.
- * @param size required new buffer size.
- * @return 0 on success, a negative AVERROR on failure.
- *
- * @note the buffer is actually reallocated with av_realloc() only if it was
- * initially allocated through av_buffer_realloc(NULL) and there is only one
- * reference to it (i.e. the one passed to this function). In all other cases
- * a new buffer is allocated and the data is copied.
- *)
-function av_buffer_realloc(buf: PPAVBufferRef; size: cint): cint;
-  cdecl; external av__util;
-
-(**
- * @defgroup lavu_bufferpool AVBufferPool
- * @ingroup lavu_data
- *
- * @
- * AVBufferPool is an API for a lock-free thread-safe pool of AVBuffers.
- *
- * Frequently allocating and freeing large buffers may be slow. AVBufferPool is
- * meant to solve this in cases when the caller needs a set of buffers of the
- * same size (the most obvious use case being buffers for raw video or audio
- * frames).
- *
- * At the beginning, the user must call av_buffer_pool_init() to create the
- * buffer pool. Then whenever a buffer is needed, call av_buffer_pool_get() to
- * get a reference to a new buffer, similar to av_buffer_alloc(). This new
- * reference works in all aspects the same way as the one created by
- * av_buffer_alloc(). However, when the last reference to this buffer is
- * unreferenced, it is returned to the pool instead of being freed and will be
- * reused for subsequent av_buffer_pool_get() calls.
- *
- * When the caller is done with the pool and no longer needs to allocate any new
- * buffers, av_buffer_pool_uninit() must be called to mark the pool as freeable.
- * Once all the buffers are released, it will automatically be freed.
- *
- * Allocating and releasing buffers with this API is thread-safe as long as
- * either the default alloc callback is used, or the user-supplied one is
- * thread-safe.
- *)
-
-(**
- * Allocate and initialize a buffer pool.
- *
- * @param size size of each buffer in this pool
- * @param alloc a function that will be used to allocate new buffers when the
- * pool is empty. May be NULL, then the default allocator will be used
- * (av_buffer_alloc()).
- * @return newly created buffer pool on success, NULL on error.
- *)
-function av_buffer_pool_init(size: cint; alloc: TAlloc): PAVBufferPool;
-  cdecl; external av__util;
-
-(**
- * Allocate and initialize a buffer pool with a more complex allocator.
- *
- * @param size size of each buffer in this pool
- * @param opaque arbitrary user data used by the allocator
- * @param alloc a function that will be used to allocate new buffers when the
- *              pool is empty.
- * @param pool_free a function that will be called immediately before the pool
- *                  is freed. I.e. after av_buffer_pool_uninit() is called
- *                  by the caller and all the frames are returned to the pool
- *                  and freed. It is intended to uninitialize the user opaque
- *                  data.
- * @return newly created buffer pool on success, NULL on error.
- *)
-function av_buffer_pool_init2(size: cint; opaque: pointer;
-                              alloc: TAlloc2;
-                              pool_free: TPoolFree): PAVBufferPool;
-  cdecl; external av__util;
-
-(**
- * Mark the pool as being available for freeing. It will actually be freed only
- * once all the allocated buffers associated with the pool are released. Thus it
- * is safe to call this function while some of the allocated buffers are still
- * in use.
- *
- * @param pool pointer to the pool to be freed. It will be set to NULL.
- *)
-procedure av_buffer_pool_uninit(pool: PPAVBufferPool);
-  cdecl; external av__util;
-
-(**
- * Allocate a new AVBuffer, reusing an old buffer from the pool when available.
- * This function may be called simultaneously from multiple threads.
- *
- * @return a reference to the new buffer on success, NULL on error.
- *)
-function av_buffer_pool_get(pool: PAVBufferPool): PAVBufferRef;
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/cpu.pas b/src/lib/ffmpeg-4.0/libavutil/cpu.pas
deleted file mode 100644
index 32d565ecd..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/cpu.pas
+++ /dev/null
@@ -1,135 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/cpu.h
- * avutil version 54.7.100
- *
- *)
-
-const
-
-  AV_CPU_FLAG_FORCE         = $80000000; (* force usage of selected flags (OR) *)
-
-    (* lower 16 bits - CPU features *)
-  AV_CPU_FLAG_MMX           = $0001;     ///< standard MMX
-  AV_CPU_FLAG_MMXEXT        = $0002;     ///< SSE integer functions or AMD MMX ext
-  AV_CPU_FLAG_MMX2          = $0002;     ///< SSE integer functions or AMD MMX ext
-  AV_CPU_FLAG_3DNOW         = $0004;     ///< AMD 3DNOW
-  AV_CPU_FLAG_SSE           = $0008;     ///< SSE functions
-  AV_CPU_FLAG_SSE2          = $0010;     ///< PIV SSE2 functions
-  AV_CPU_FLAG_SSE2SLOW      = $40000000; ///< SSE2 supported, but usually not faster
-                                         ///< than regular MMX/SSE (e.g. Core1)
-  AV_CPU_FLAG_3DNOWEXT      = $0020;     ///< AMD 3DNowExt
-  AV_CPU_FLAG_SSE3          = $0040;     ///< Prescott SSE3 functions
-  AV_CPU_FLAG_SSE3SLOW      = $20000000; ///< SSE3 supported, but usually not faster
-                                         ///< than regular MMX/SSE (e.g. Core1)
-  AV_CPU_FLAG_SSSE3         = $0080;     ///< Conroe SSSE3 functions
-  AV_CPU_FLAG_ATOM          = $10000000; ///< Atom processor, some SSSE3 instructions are slower
-  AV_CPU_FLAG_SSE4          = $0100;     ///< Penryn SSE4.1 functions
-  AV_CPU_FLAG_SSE42         = $0200;     ///< Nehalem SSE4.2 functions
-  AV_CPU_FLAG_AESNI         = $80000;    ///< Advanced Encryption Standard functions
-  AV_CPU_FLAG_AVX           = $4000;     ///< AVX functions: requires OS support even if YMM registers aren't used
-  AV_CPU_FLAG_AVXSLOW       = $8000000;  ///< AVX supported, but slow when using YMM registers (e.g. Bulldozer)
-  AV_CPU_FLAG_XOP           = $0400;     ///< Bulldozer XOP functions
-  AV_CPU_FLAG_FMA4          = $0800;     ///< Bulldozer FMA4 functions
-
-  AV_CPU_FLAG_CMOV          = $1000;     ///< supports cmov instruction
-
-  AV_CPU_FLAG_AVX2          = $8000;     ///< AVX2 functions: requires OS support even if YMM registers aren't used
-  AV_CPU_FLAG_FMA3          = $10000;    ///< Haswell FMA3 functions
-  AV_CPU_FLAG_BMI1          = $20000;    ///< Bit Manipulation Instruction Set 1
-  AV_CPU_FLAG_BMI2          = $40000;    ///< Bit Manipulation Instruction Set 2
-  AV_CPU_FLAG_AVX512        = $100000;   ///< AVX-512 functions: requires OS support even if YMM/ZMM registers aren't used
-
-  AV_CPU_FLAG_ALTIVEC       = $0001;     ///< standard
-  AV_CPU_FLAG_VSX           = $0002;     ///< ISA 2.06
-  AV_CPU_FLAG_POWER8        = $0004;     ///< ISA 2.07
-
-  AV_CPU_FLAG_ARMV5TE       = (1 << 0);
-  AV_CPU_FLAG_ARMV6         = (1 << 1);
-  AV_CPU_FLAG_ARMV6T2       = (1 << 2);
-  AV_CPU_FLAG_VFP           = (1 << 3);
-  AV_CPU_FLAG_VFPV3         = (1 << 4);
-  AV_CPU_FLAG_NEON          = (1 << 5);
-  AV_CPU_FLAG_ARMV8         = (1 << 6);
-  AV_CPU_FLAG_VFP_VM        = (1 << 7); ///< VFPv2 vector mode, deprecated in ARMv7-A and unavailable in various CPUs implementations
-  AV_CPU_FLAG_SETEND        = (1 <<16);
-
-(**
- * Return the flags which specify extensions supported by the CPU.
- * The returned value is affected by av_force_cpu_flags() if that was used
- * before. So av_get_cpu_flags() can easily be used in an application to
- * detect the enabled cpu flags.
- *)
-function av_get_cpu_flags(): cint;
-  cdecl; external av__util;
-
-(**
- * Disables cpu detection and forces the specified flags.
- * -1 is a special case that disables forcing of specific flags.
- *)
-procedure av_force_cpu_flags(flags: cint);
-  cdecl; external av__util;
-
-(**
- * Set a mask on flags returned by av_get_cpu_flags().
- * This function is mainly useful for testing.
- * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
- *)
-procedure av_set_cpu_flags_mask(mask: cint);
-  cdecl; external av__util; deprecated;
-
-(**
- * Parse CPU flags from a string.
- *
- * The returned flags contain the specified flags as well as related unspecified flags.
- *
- * This function exists only for compatibility with libav.
- * Please use av_parse_cpu_caps() when possible.
- * @return a combination of AV_CPU_* flags, negative on error.
- *)
-function av_parse_cpu_flags(s: {const} PAnsiChar): cint;
-  cdecl; external av__util; deprecated;
-
-(**
- * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
- *
- * @return negative on error.
- *)
-function av_parse_cpu_caps(flags: Pcuint; s: {const} PAnsiChar): cint;
-  cdecl; external av__util;
-
-(**
- * @return the number of logical CPU cores present.
- *)
-function av_cpu_count(): cint;
-  cdecl; external av__util;
-
-(**
- * Get the maximum data alignment that may be required by FFmpeg.
- *
- * Note that this is affected by the build configuration and the CPU flags mask,
- * so e.g. if the CPU supports AVX, but libavutil has been built with
- * --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
- *  av_set_cpu_flags_mask(), then this function will behave as if AVX is not
- *  present.
- *)
-function av_cpu_max_align(): size_t;
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/dict.pas b/src/lib/ffmpeg-4.0/libavutil/dict.pas
deleted file mode 100644
index ef54610ca..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/dict.pas
+++ /dev/null
@@ -1,168 +0,0 @@
-(*
- * AVDictionary
- * copyright (c) 2011 Karl-Michael Schindler <karl-michael.schindler@web.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- *
- * Conversion of libavutil/dict.h
- * avutil version 54.7.100
- *
- *)
-
-const
-  AV_DICT_MATCH_CASE      = 1;
-  AV_DICT_IGNORE_SUFFIX   = 2;
-  AV_DICT_DONT_STRDUP_KEY = 4;    (**< Take ownership of a key that's been
-                                       allocated with av_malloc() or another memory allocation function. *)
-  AV_DICT_DONT_STRDUP_VAL = 8;    (**< Take ownership of a value that's been
-                                       allocated with av_malloc() or another memory allocation function. *)
-  AV_DICT_DONT_OVERWRITE  = 16;   (**< Don't overwrite existing entries. *)
-  AV_DICT_APPEND          = 32;   (**< If the entry already exists, append to it.  Note that no
-                                    delimiter is added, the strings are simply concatenated. *)
-  AV_DICT_MULTIKEY        = 64;   (**< Allow to store several equal keys in the dictionary *)
-
-type
-  PAVDictionaryEntry = ^TAVDictionaryEntry;
-  TAVDictionaryEntry = record
-    key:   PAnsiChar;
-    value: PAnsiChar;
-  end;
-  
-(* with the "help" of libavutil/internal.h: *)
-
-  PPAVDictionary = ^PAVDictionary;
-  PAVDictionary = ^TAVDictionary;
-  TAVDictionary = record
-    count: cint;
-    elems: PAVDictionaryEntry;
-  end;
-
-(**
- * Get a dictionary entry with matching key.
- *
- * The returned entry key or value must not be changed, or it will
- * cause undefined behavior.
- *
- * To iterate through all the dictionary entries, you can set the matching key
- * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
- *  
- * @param key matching key  
- * @param prev Set to the previous matching element to find the next.
- *             If set to NULL the first matching element is returned.
- * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
- * @return found entry or NULL in case no matching entry was found in the dictionary
- *)
-function av_dict_get({const} m: PAVDictionary; {const} key: PAnsiChar; {const} prev: PAVDictionaryEntry; flags: cint): PAVDictionaryEntry;
-  cdecl; external av__util;
-
-(**
- * Get number of entries in dictionary.
- *
- * @param m dictionary
- * @return  number of entries in dictionary
- *)
-function av_dict_count({const} m: PAVDictionary): cint;
-  cdecl; external av__util;
-
-(**
- * Set the given entry in *pm, overwriting an existing entry.
- *
- * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
- * these arguments will be freed on error.
- *
- * Warning: Adding a new entry to a dictionary invalidates all existing entries
- * previously returned with av_dict_get.
- *
- * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
- * a dictionary struct is allocated and put in *pm.
- * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
- * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
- *        Passing a NULL value will cause an existing entry to be deleted.
- * @return >= 0 on success otherwise an error code <0
- *)
-function av_dict_set(var pm: PAVDictionary; {const} key: PAnsiChar; {const} value: PAnsiChar; flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Convenience wrapper for av_dict_set that converts the value to a string
- * and stores it.
- *
- * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
- *)
-function av_dict_set_int(var pm: PAVDictionary; {const} key: PAnsiChar;
-                         value: cint64; flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Parse the key/value pairs list and add the parsed entries to a dictionary.
- *
- * In case of failure, all the successfully set entries are stored in
- * *pm. You may need to manually free the created dictionary.
- *
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other
- * @param flags        flags to use when adding to dictionary.
- *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
- *                     are ignored since the key/value tokens will always
- *                     be duplicated.
- * @return             0 on success, negative AVERROR code on failure
- *)
-function av_dict_parse_string(var pm: PAVDictionary; {const} str: PAnsiChar;
-                         {const} key_val_sep: PAnsiChar; {const} pairs_sep: PAnsiChar;
-                         flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Copy entries from one AVDictionary struct into another.
- * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,
- *            this function will allocate a struct for you and put it in *dst
- * @param src pointer to source AVDictionary struct
- * @param flags flags to use when setting entries in *dst
- * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag
- * @return 0 on success, negative AVERROR code on failure. If dst was allocated
- *           by this function, callers should free the associated memory.
- *)
-function av_dict_copy(var dst: PAVDictionary; {const} src: PAVDictionary; flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Get dictionary entries as a string.
- *
- * Create a string containing dictionary's entries.
- * Such string may be passed back to av_dict_parse_string().
- * @note String is escaped with backslashes ('\').
- *
- * @param[in]  m             dictionary
- * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
- *                           Buffer must be freed by the caller when is no longer needed.
- * @param[in]  key_val_sep   character used to separate key from value
- * @param[in]  pairs_sep     character used to separate two pairs from each other
- * @return                   >= 0 on success, negative on error
- * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
- *)
-function av_dict_get_string({const} m: PAVDictionary; buffer: PPAnsiChar;
-                       {const} key_val_sep: AnsiChar; {const} pairs_sep: AnsiChar): cint;
-  cdecl; external av__util;
-
-(**
- * Free all the memory allocated for an AVDictionary struct
- * and all keys and values.
- *)
-procedure av_dict_free(var m: PAVDictionary);
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/error.pas b/src/lib/ffmpeg-4.0/libavutil/error.pas
deleted file mode 100644
index f972aa7dd..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/error.pas
+++ /dev/null
@@ -1,169 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/error.h
- * avutil version 54.7.100
- *
- *)
-
-(**
- * @file
- * error code definitions
- *)
-
-(**
- * @addtogroup lavu_error
- *
- * @
- *)
-
-{* error handling *}
-
-const
-{$IFDEF UNIX}
-  ENOENT = ESysENOENT;
-  EIO    = ESysEIO;
-  ENOMEM = ESysENOMEM;
-  EINVAL = ESysEINVAL;
-  EDOM   = ESysEDOM;
-  ENOSYS = ESysENOSYS;
-  EILSEQ = ESysEILSEQ;
-  EPIPE  = ESysEPIPE;
-  EAGAIN = ESysEAGAIN;
-{$ELSE}
-  ENOENT = 2;
-  EIO    = 5;
-  EAGAIN = 11;
-  ENOMEM = 12;
-  EINVAL = 22;
-  EPIPE  = 32;  // just an assumption. needs to be checked.
-  EDOM   = 33;
-  {$IFDEF MSWINDOWS}
-  // Note: we assume that ffmpeg was compiled with MinGW.
-  // This must be changed if DLLs were compiled with cygwin.
-  ENOSYS = 40;  // MSVC/MINGW: 40, CYGWIN: 88,  LINUX/FPC: 38
-  EILSEQ = 42;  // MSVC/MINGW: 42, CYGWIN: 138, LINUX/FPC: 84
-  {$ENDIF}
-{$ENDIF}
-
-(**
- * We need the sign of the error, because some platforms have 
- * E* and errno already negated. The previous version failed
- * with Delphi, because it needed EINVAL defined.
- * Warning: This code is platform dependent and assumes constants 
- * to be 32 bit.
- * This version does the following steps:
- * 1) shr 30:        shifts the sign bit to bit position 2
- * 2) and $00000002: sets all other bits to zero
- *                   positive EINVAL gives 0, negative gives 2
- * 3) - 1:           positive EINVAL gives -1, negative 1
- *)
-const
-  AVERROR_SIGN = (EINVAL shr 30) and $00000002 - 1;
-
-(*
-#if EDOM > 0
-#define AVERROR(e) (-(e)) {**< Returns a negative error code from a POSIX error code, to return from library functions. *}
-#define AVUNERROR(e) (-(e)) {**< Returns a POSIX error code from a library function error return value. *}
-#else
-{* Some platforms have E* and errno already negated. *}
-#define AVERROR(e) (e)
-#define AVUNERROR(e) (e)
-#endif
-*)
-function AVERROR(e: integer): integer;
-
-const
-
-  // Note: function calls as constant-initializers are invalid
-  AVERROR_BSF_NOT_FOUND      = -(ord($F8) or (ord('B') shl 8) or (ord('S') shl 16) or (ord('F') shl 24)); ///< Bitstream filter not found
-  AVERROR_BUG                = -(ord('B') or (ord('U') shl 8) or (ord('G') shl 16) or (ord('!') shl 24)); ///< Internal bug, also see AVERROR_BUG2
-  AVERROR_BUFFER_TOO_SMALL   = -(ord('B') or (ord('U') shl 8) or (ord('F') shl 16) or (ord('S') shl 24)); ///< Buffer too small
-  AVERROR_DECODER_NOT_FOUND  = -(ord($F8) or (ord('D') shl 8) or (ord('E') shl 16) or (ord('C') shl 24)); ///< Decoder not found
-  AVERROR_DEMUXER_NOT_FOUND  = -(ord($F8) or (ord('D') shl 8) or (ord('E') shl 16) or (ord('M') shl 24)); ///< Demuxer not found
-  AVERROR_ENCODER_NOT_FOUND  = -(ord($F8) or (ord('E') shl 8) or (ord('N') shl 16) or (ord('C') shl 24)); ///< Encoder not found
-  AVERROR_EOF                = -(ord('E') or (ord('O') shl 8) or (ord('F') shl 16) or (ord(' ') shl 24)); ///< End of file
-  AVERROR_EXIT               = -(ord('E') or (ord('X') shl 8) or (ord('I') shl 16) or (ord('T') shl 24)); ///< Immediate exit was requested; the called function should not be restarted
-  AVERROR_EXTERNAL           = -(ord('E') or (ord('X') shl 8) or (ord('T') shl 16) or (ord(' ') shl 24)); ///< Generic error in an external library
-  AVERROR_FILTER_NOT_FOUND   = -(ord($F8) or (ord('F') shl 8) or (ord('I') shl 16) or (ord('L') shl 24)); ///< Filter not found
-  AVERROR_INVALIDDATA        = -(ord('I') or (ord('N') shl 8) or (ord('D') shl 16) or (ord('A') shl 24)); ///< Invalid data found when processing input
-  AVERROR_MUXER_NOT_FOUND    = -(ord($F8) or (ord('M') shl 8) or (ord('U') shl 16) or (ord('X') shl 24)); ///< Muxer not found
-  AVERROR_OPTION_NOT_FOUND   = -(ord($F8) or (ord('O') shl 8) or (ord('P') shl 16) or (ord('T') shl 24)); ///< Option not found
-  AVERROR_PATCHWELCOME       = -(ord('P') or (ord('A') shl 8) or (ord('W') shl 16) or (ord('E') shl 24)); ///< Not yet implemented in FFmpeg, patches welcome
-  AVERROR_PROTOCOL_NOT_FOUND = -(ord($F8) or (ord('P') shl 8) or (ord('R') shl 16) or (ord('O') shl 24)); ///< Protocol not found
-  AVERROR_STREAM_NOT_FOUND   = -(ord($F8) or (ord('S') shl 8) or (ord('T') shl 16) or (ord('R') shl 24)); ///< Stream not found
-
-(**
- * This is semantically identical to AVERROR_BUG
- * it has been introduced in Libav after our AVERROR_BUG and with a modified value.
- *)
-  AVERROR_BUG2               = -(ord('B') or (ord('U') shl 8) or (ord('G') shl 16) or (ord(' ') shl 24));
-  AVERROR_UNKNOWN            = -(ord('U') or (ord('N') shl 8) or (ord('K') shl 16) or (ord('N') shl 24)); ///< Unknown error, typically from an external library
-  AVERROR_EXPERIMENTAL       = -($2bb2afa8); ///< Requested feature is flagged experimental. Set strict_std_compliance if you really want to use it.
-  AVERROR_INPUT_CHANGED      = -($636e6701); ///< Input changed between calls. Reconfiguration is required. (can be OR-ed with AVERROR_OUTPUT_CHANGED)
-  AVERROR_OUTPUT_CHANGED     = -($636e6702); ///< Output changed between calls. Reconfiguration is required. (can be OR-ed with AVERROR_INPUT_CHANGED)
-(* HTTP & RTSP errors *)
-  AVERROR_HTTP_BAD_REQUEST   = -(ord($F8) or (ord('4') shl 8) or (ord('0') shl 16) or (ord('0') shl 24));
-  AVERROR_HTTP_UNAUTHORIZED  = -(ord($F8) or (ord('4') shl 8) or (ord('0') shl 16) or (ord('1') shl 24));
-  AVERROR_HTTP_FORBIDDEN     = -(ord($F8) or (ord('4') shl 8) or (ord('0') shl 16) or (ord('3') shl 24));
-  AVERROR_HTTP_NOT_FOUND     = -(ord($F8) or (ord('4') shl 8) or (ord('0') shl 16) or (ord('4') shl 24));
-  AVERROR_HTTP_OTHER_4XX     = -(ord($F8) or (ord('4') shl 8) or (ord('X') shl 16) or (ord('X') shl 24));
-  AVERROR_HTTP_SERVER_ERROR  = -(ord($F8) or (ord('5') shl 8) or (ord('X') shl 16) or (ord('X') shl 24));
-
-  AV_ERROR_MAX_STRING_SIZE   = 64;
-
-(*
- * Put a description of the AVERROR code errnum in errbuf.
- * In case of failure the global variable errno is set to indicate the
- * error. Even in case of failure av_strerror() will print a generic
- * error message indicating the errnum provided to errbuf.
- *
- * @param errnum      error code to describe
- * @param errbuf      buffer to which description is written
- * @param errbuf_size the size in bytes of errbuf
- * @return 0 on success, a negative value if a description for errnum
- * cannot be found
- *)
-function av_strerror(errnum: cint; errbuf: PAnsiChar; errbuf_size: size_t): cint;
-  cdecl; external av__util;
-
-(**
- * Fill the provided buffer with a string containing an error string
- * corresponding to the AVERROR code errnum.
- *
- * @param errbuf         a buffer
- * @param errbuf_size    size in bytes of errbuf
- * @param errnum         error code to describe
- * @return the buffer in input, filled with the error description
- * @see av_strerror()
- *)
-function av_make_error_string(errbuf: Pchar; errbuf_size: size_t; errnum: cint): Pchar; {$IFDEF HasInline}inline;{$ENDIF}
-// Note: defined in avutil.pas
-
-(**
- * Convenience macro, the return value should be used only directly in
- * function arguments but never stand-alone.
- *)
-function av_err2str(errnum: cint): pchar; {$IFDEF HasInline}inline;{$ENDIF}
-// Note: defined in avutil.pas
-
-(**
- * @}
- *)
diff --git a/src/lib/ffmpeg-4.0/libavutil/frame.pas b/src/lib/ffmpeg-4.0/libavutil/frame.pas
deleted file mode 100644
index eb97e27b5..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/frame.pas
+++ /dev/null
@@ -1,928 +0,0 @@
-(*
- * AVOptions
- * copyright (c) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/frame.h
- * avutil version 54.7.100
- *
-*)
-
-const
-  AV_NUM_DATA_POINTERS = 8;
-
-    (** from the definitions of TAVFrame *)
-
-    (**
-     * The frame data may be corrupted, e.g. due to decoding errors.
-     *)
-  AV_FRAME_FLAG_CORRUPT = (1 << 0);
-  (**
-   * A flag to mark the frames which need to be decoded, but shouldn't be output.
-   *)
-  AV_FRAME_FLAG_DISCARD = (1 << 2);
-
-  FF_DECODE_ERROR_INVALID_BITSTREAM = 1;
-  FF_DECODE_ERROR_MISSING_REFERENCE = 2;
-
-
-type
-(* is already in pixfmt.pas
-  TAVColorSpace = (
-    AVCOL_SPC_RGB         = 0,
-    AVCOL_SPC_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
-    AVCOL_SPC_UNSPECIFIED = 2,
-    AVCOL_SPC_FCC         = 4,
-    AVCOL_SPC_BT470BG     = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
-    AVCOL_SPC_SMPTE170M   = 6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above
-    AVCOL_SPC_SMPTE240M_  = 7,
-    AVCOL_SPC_YCGCO       = 8,  ///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
-    AVCOL_SPC_BT2020_NCL  = 9,  ///< ITU-R BT2020 non-constant luminance system
-    AVCOL_SPC_BT2020_CL   = 10, ///< ITU-R BT2020 constant luminance system
-    AVCOL_SPC_NB                ///< Not part of ABI
-  );
-
-  TAVColorRange = (
-    AVCOL_RANGE_UNSPECIFIED = 0,
-    AVCOL_RANGE_MPEG        = 1, ///< the normal 219*2^(n-8) "MPEG" YUV ranges
-    AVCOL_RANGE_JPEG        = 2, ///< the normal     2^n-1   "JPEG" YUV ranges
-    AVCOL_RANGE_NB               ///< Not part of ABI
-  );
-*)
-
-(* Note: AVPanScan is defined in avcodec.h but is here to avoid reference problems - Brian-ch 28/09/2014
- *
- * Pan Scan area.
- * This specifies the area which should be displayed.
- * Note there may be multiple such areas for one frame.
- *)
-  PAVPanScan = ^TAVPanScan;
-  TAVPanScan = record {24}
-    (*** id.
-     * - encoding: set by user.
-     * - decoding: set by libavcodec. *)
-    id: cint;
-
-    (*** width and height in 1/16 pel
-     * - encoding: set by user.
-     * - decoding: set by libavcodec. *)
-    width: cint;
-    height: cint;
-
-    (*** position of the top left corner in 1/16 pel for up to 3 fields/frames.
-     * - encoding: set by user.
-     * - decoding: set by libavcodec. *)
-    position: array [0..2] of array [0..1] of cint16;
-  end; {TAVPanScan}
-
-  (**
-   * @defgroup lavu_frame AVFrame
-   * @ingroup lavu_data
-   *
-   * @
-   * AVFrame is an abstraction for reference-counted raw multimedia data.
-   *)
-  TAVFrameSideDataType = (
-    (**
-     * The data is the AVPanScan struct defined in libavcodec.
-     *)
-    AV_FRAME_DATA_PANSCAN,
-    (**
-     * ATSC A53 Part 4 Closed Captions.
-     * A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.
-     * The number of bytes of CC data is AVFrameSideData.size.
-     *)
-    AV_FRAME_DATA_A53_CC,
-    (**
-     * Stereoscopic 3d metadata.
-     * The data is the AVStereo3D struct defined in libavutil/stereo3d.h.
-     *)
-    AV_FRAME_DATA_STEREO3D,
-    (**
-     * The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.
-     *)
-    AV_FRAME_DATA_MATRIXENCODING,
-    (**
-     * Metadata relevant to a downmix procedure.
-     * The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.
-     *)
-    AV_FRAME_DATA_DOWNMIX_INFO,
-    (**
-     * ReplayGain information in the form of the AVReplayGain struct.
-     *)
-    AV_FRAME_DATA_REPLAYGAIN,
-    (**
-     * This side data contains a 3x3 transformation matrix describing an affine
-     * transformation that needs to be applied to the frame for correct
-     * presentation.
-     *
-     * See libavutil/display.h for a detailed description of the data.
-     *)
-    AV_FRAME_DATA_DISPLAYMATRIX,
-    (**
-     * Active Format Description data consisting of a single byte as specified
-     * in ETSI TS 101 154 using AVActiveFormatDescription enum.
-     *)
-    AV_FRAME_DATA_AFD,
-    (**
-     * Motion vectors exported by some codecs (on demand through the export_mvs
-     * flag set in the libavcodec AVCodecContext flags2 option).
-     * The data is the AVMotionVector struct defined in
-     * libavutil/motion_vector.h.
-     *)
-    AV_FRAME_DATA_MOTION_VECTORS,
-    (**
-     * Recommmends skipping the specified number of samples. This is exported
-     * only if the "skip_manual" AVOption is set in libavcodec.
-     * This has the same format as AV_PKT_DATA_SKIP_SAMPLES.
-     * @code
-     * u32le number of samples to skip from start of this packet
-     * u32le number of samples to skip from end of this packet
-     * u8    reason for start skip
-     * u8    reason for end   skip (0=padding silence, 1=convergence)
-     * @endcode
-     *)
-    AV_FRAME_DATA_SKIP_SAMPLES,
-    (**
-     * This side data must be associated with an audio frame and corresponds to
-     * enum AVAudioServiceType defined in avcodec.h.
-     *)
-    AV_FRAME_DATA_AUDIO_SERVICE_TYPE,
-    (**
-     * Mastering display metadata associated with a video frame. The payload is
-     * an AVMasteringDisplayMetadata type and contains information about the
-     * mastering display color volume.
-     *)
-    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA,
-    (**
-     * The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.
-     * This is set on the first frame of a GOP that has a temporal reference of 0.
-     *)
-    AV_FRAME_DATA_GOP_TIMECODE,
-    (**
-      * The data represents the AVSphericalMapping structure defined in
-      * libavutil/spherical.h.
-      *)
-    AV_FRAME_DATA_SPHERICAL,
-    (**
-     * Content light level (based on CTA-861.3). This payload contains data in
-     * the form of the AVContentLightMetadata struct.
-     *)
-    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL,
-    (**
-     * The data contains an ICC profile as an opaque octet buffer following the
-     * format described by ISO 15076-1 with an optional name defined in the
-     * metadata key entry "name".
-     *)
-    AV_FRAME_DATA_ICC_PROFILE,
-{$IFDEF FF_API_FRAME_QP}
-    (**
-     * Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.
-     * The contents of this side data are undocumented and internal; use
-     * av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a
-     * meaningful way instead.
-     */)
-    AV_FRAME_DATA_QP_TABLE_PROPERTIES,
-
-    (**
-     * Raw QP table data. Its format is described by
-     * AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and
-     * av_frame_get_qp_table() to access this instead.
-     *)
-    AV_FRAME_DATA_QP_TABLE_DATA
-{$ENDIF}
-  );
-
-	TAVActiveFormatDescription = (
-    AV_AFD_SAME         = 8,
-    AV_AFD_4_3          = 9,
-    AV_AFD_16_9         = 10,
-    AV_AFD_14_9         = 11,
-    AV_AFD_4_3_SP_14_9  = 13,
-    AV_AFD_16_9_SP_14_9 = 14,
-    AV_AFD_SP_4_3       = 15
-	); {TAVActiveFormatDescription}
-
-  PAVFrameSideData = ^TAVFrameSideData;
-(**
- * Structure to hold side data for an AVFrame.
- *
- * sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added
- * to the end with a minor bump.
- *)
-  TAVFrameSideData = record
-    type_: TAVFrameSideDataType;
-    data:  PByte;
-    size:  cint;
-    metadata: TAVDictionary;
-    buf: PAVBufferRef;
-  end; {TAVFrameSideData}
-
-(**
- * This structure describes decoded (raw) audio or video data.
- *
- * AVFrame must be allocated using av_frame_alloc(). Note that this only
- * allocates the AVFrame itself, the buffers for the data must be managed
- * through other means (see below).
- * AVFrame must be freed with av_frame_free().
- *
- * AVFrame is typically allocated once and then reused multiple times to hold
- * different data (e.g. a single AVFrame to hold frames received from a
- * decoder). In such a case, av_frame_unref() will free any references held by
- * the frame and reset it to its original clean state before it
- * is reused again.
- *
- * The data described by an AVFrame is usually reference counted through the
- * AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
- * AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
- * least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
- * every single data plane must be contained in one of the buffers in
- * AVFrame.buf or AVFrame.extended_buf.
- * There may be a single buffer for all the data, or one separate buffer for
- * each plane, or anything in between.
- *
- * sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
- * to the end with a minor bump.
- *
- * Fields can be accessed through AVOptions, the name string used, matches the
- * C structure field name for fields accessible through AVOptions. The AVClass
- * for AVFrame can be obtained from avcodec_get_frame_class()
- *)
-  PPAVFrame = ^PAVFrame;
-  PAVFrame = ^TAVFrame;
-  TAVFrame = record
-    (**
-     * pointer to the picture/channel planes.
-     * This might be different from the first allocated byte
-     *
-     * Some decoders access areas outside 0,0 - width,height, please
-     * see avcodec_align_dimensions2(). Some filters and swscale can read
-     * up to 16 bytes beyond the planes, if these filters are to be used,
-     * then 16 extra bytes must be allocated.
-     *
-     * NOTE: Except for hwaccel formats, pointers not needed by the format
-     * MUST be set to NULL.
-     *)
-    data: array [0..AV_NUM_DATA_POINTERS - 1] of pbyte;
-
-    (**
-     * For video, size in bytes of each picture line.
-     * For audio, size in bytes of each plane.
-     *
-     * For audio, only linesize[0] may be set. For planar audio, each channel
-     * plane must be the same size.
-     *
-     * For video the linesizes should be multiples of the CPUs alignment
-     * preference, this is 16 or 32 for modern desktop CPUs.
-     * Some code requires such alignment other code can be slower without
-     * correct alignment, for yet other it makes no difference.
-     *
-     * @note The linesize may be larger than the size of usable data -- there
-     * may be extra padding present for performance reasons.
-     *)
-    linesize: array [0..AV_NUM_DATA_POINTERS - 1] of cint;
-
-    (**
-     * pointers to the data planes/channels.
-     *
-     * For video, this should simply point to data[].
-     *
-     * For planar audio, each channel has a separate data pointer, and
-     * linesize[0] contains the size of each channel buffer.
-     * For packed audio, there is just one data pointer, and linesize[0]
-     * contains the total size of the buffer for all channels.
-     *
-     * Note: Both data and extended_data will always be set by get_buffer(),
-     * but for planar audio with more channels that can fit in data,
-     * extended_data must be used in order to access all channels.
-     *)
-    extended_data: ^pbyte;
-
-    (**
-     * @name Video dimensions
-     * Video frames only. The coded dimensions (in pixels) of the video frame,
-     * i.e. the size of the rectangle that contains some well-defined values.
-     *
-     * @note The part of the frame intended for display/presentation is further
-     * restricted by the @ref cropping "Cropping rectangle".
-     *)
-    width, height: cint;
-    (**
-     * number of audio samples (per channel) described by this frame
-     *)
-    nb_samples: cint;
-
-    (**
-     * format of the frame, -1 if unknown or unset
-     * Values correspond to enum AVPixelFormat for video frames,
-     * enum AVSampleFormat for audio)
-     *)
-    format: cint;
-
-    (**
-     * 1 -> keyframe, 0-> not
-     *)
-    key_frame: cint;
-
-    (**
-     * Picture type of the frame
-     *)
-    pict_type: TAVPictureType;
-
-    (**
-     * sample aspect ratio for the video frame, 0/1 if unknown/unspecified
-     *)
-    sample_aspect_ratio: TAVRational;
-
-    (**
-     * presentation timestamp in time_base units (time when frame should be shown to user)
-     *)
-    pts: cint64;
-
-{$IFDEF FF_API_PKT_PTS}
-    (**
-     * PTS copied from the AVPacket that was decoded to produce this frame.
-     *)
-    pkt_pts: cint64; {deprecated}
-{$ENDIF}
-
-    (**
-     * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
-     * This is also the Presentation time of this AVFrame calculated from
-     * only AVPacket.dts values without pts values.
-     *)
-    pkt_dts: cint64;
-
-    (**
-     * picture number in bitstream order
-     *)
-    coded_picture_number: cint;
-
-    (**
-     * picture number in display order
-     *)
-    display_picture_number: cint;
-
-    (**
-     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
-     *)
-    quality: cint;
-
-    (**
-     * for some private data of the user
-     *)
-    opaque: pointer;
-
-{$IFDEF FF_API_ERROR_FRAME}
-    (**
-     * @deprecated unused
-     *)
-    error: array [0..AV_NUM_DATA_POINTERS - 1] of cuint64; {deprecated}
-{$ENDIF}
-
-    (**
-     * When decoding, this signals how much the picture must be delayed.
-     * extra_delay = repeat_pict / (2*fps)
-     *)
-    repeat_pict: cint;
-
-    (**
-     * The content of the picture is interlaced.
-     *)
-    interlaced_frame: cint;
-
-    (**
-     * If the content is interlaced, is top field displayed first.
-     *)
-    top_field_first: cint;
-
-    (**
-     * Tell user application that palette has changed from previous frame.
-     *)
-    palette_has_changed: cint;
-
-    (**
-     * reordered opaque 64 bits (generally an integer or a double precision float
-     * PTS but can be anything).
-     * The user sets AVCodecContext.reordered_opaque to represent the input at
-     * that time,
-     * the decoder reorders values as needed and sets AVFrame.reordered_opaque
-     * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
-     * @deprecated in favor of pkt_pts
-     *)
-    reordered_opaque: cint64;
-
-    (**
-     * Sample rate of the audio data.
-     *)
-    sample_rate: cint;
-
-    (**
-     * Channel layout of the audio data.
-     *)
-    channel_layout: cuint64;
-
-    (**
-     * AVBuffer references backing the data for this frame. If all elements of
-     * this array are NULL, then this frame is not reference counted. This array
-     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
-     * also be non-NULL for all j < i.
-     *
-     * There may be at most one AVBuffer per data plane, so for video this array
-     * always contains all the references. For planar audio with more than
-     * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
-     * this array. Then the extra AVBufferRef pointers are stored in the
-     * extended_buf array.
-     *)
-    buf: array [0..AV_NUM_DATA_POINTERS - 1] of PAVBufferRef;
-
-    (**
-     * For planar audio which requires more than AV_NUM_DATA_POINTERS
-     * AVBufferRef pointers, this array will hold all the references which
-     * cannot fit into AVFrame.buf.
-     *
-     * Note that this is different from AVFrame.extended_data, which always
-     * contains all the pointers. This array only contains the extra pointers,
-     * which cannot fit into AVFrame.buf.
-     *
-     * This array is always allocated using av_malloc() by whoever constructs
-     * the frame. It is freed in av_frame_unref().
-     *)
-    extended_buf: PPAVBufferRef;
-
-    (**
-     * Number of elements in extended_buf.
-     *)
-    nb_extended_buf: cint;
-
-    side_data: ^PAVFrameSideData;
-    nb_side_data: cint;
-
-    (**
-     * @defgroup lavu_frame_flags AV_FRAME_FLAGS
-     * @ingroup lavu_frame
-     * Flags describing additional frame properties.
-     *
-     * @
-     *)
-
-    (**
-     * Frame flags, a combination of @ref lavu_frame_flags
-     *)
-    flags: cint;
-
-    (**
-     * MPEG vs JPEG YUV range.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    color_range: TAVColorRange;
-
-    color_primaries: TAVColorPrimaries;
-
-    color_trc: TAVColorTransferCharacteristic;
-
-    (**
-     * YUV colorspace type.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     *)
-    colorspace: TAVColorSpace;
-
-    chroma_location: TAVChromaLocation;
-
-    (**
-     * frame timestamp estimated using various heuristics, in stream time base
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-    best_effort_timestamp: cint64;
-
-    (**
-     * reordered pos from the last AVPacket that has been input into the decoder
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    pkt_pos: cint64;
-
-    (**
-     * duration of the corresponding packet, expressed in
-     * AVStream->time_base units, 0 if unknown.
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    pkt_duration: cint64;
-
-    (**
-     * metadata.
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     *)
-    metadata: PAVDictionary;
-
-    (**
-     * decode error flags of the frame, set to a combination of
-     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
-     * were errors during the decoding.
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-    decode_error_flags: cint;
-
-    (**
-     * number of audio channels, only used for audio.
-     * - encoding: unused
-     * - decoding: Read by user.
-     *)
-    channels: cint;
-
-    (**
-     * size of the corresponding packet containing the compressed
-     * frame.
-     * It is set to a negative value if unknown.
-     * - encoding: unused
-     * - decoding: set by libavcodec, read by user.
-     *)
-    pkt_size: cint;
-
-{$IFDEF FF_API_FRAME_QP}
-    (**
-     * QP table
-     *)
-    qscale_table: PByte; {deprecated}
-    (**
-     * QP store stride
-     *)
-    qstride: cint; {deprecated}
-
-    qscale_type: cint; {deprecated}
-
-    qp_table_buf: PAVBufferRef; {deprecated}
-{$ENDIF}
-    (**
-     * For hwaccel-format frames, this should be a reference to the
-     * AVHWFramesContext describing the frame.
-     *)
-    hw_frames_ctx: PAVBufferRef;
-
-    (**
-     * AVBufferRef for free use by the API user. FFmpeg will never check the
-     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
-     * the frame is unreferenced. av_frame_copy_props() calls create a new
-     * reference with av_buffer_ref() for the target frame's opaque_ref field.
-     *
-     * This is unrelated to the opaque field, although it serves a similar
-     * purpose.
-     *)
-    opaque_ref: PAVBufferRef;
-
-   (**
-     * @anchor cropping
-     * @name Cropping
-     * Video frames only. The number of pixels to discard from the the
-     * top/bottom/left/right border of the frame to obtain the sub-rectangle of
-     * the frame intended for presentation.
-     *)
-    crop_top: size_t;
-    crop_bottom: size_t;
-    crop_left: size_t;
-    crop_right: size_t;
-    (**
-     * AVBufferRef for internal use by a single libav* library.
-     * Must not be used to transfer data between libraries.
-     * Has to be NULL when ownership of the frame leaves the respective library.
-     *
-     * Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
-     *
-     * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
-     * av_frame_copy_props() calls create a new reference with av_buffer_ref()
-     * for the target frame's private_ref field.
-     *)
-    private_ref: PAVBufferRef;
-  end; {TAVFrame}
-
-{$IFDEF FF_API_FRAME_GET_SET}
-(**
- * Accessors for some AVFrame fields. These used to be provided for ABI
- * compatibility, and do not need to be used anymore.
- *)
-function  av_frame_get_best_effort_timestamp(frame: {const} PAVFrame): cint64;
-  cdecl; external av__codec; overload; deprecated;
-procedure av_frame_set_best_effort_timestamp(frame: PAVFrame; val: cint64);
-  cdecl; external av__codec; overload; deprecated;
-function  av_frame_get_pkt_duration         (frame: {const} PAVFrame): cint64;
-  cdecl; external av__codec; overload; deprecated;
-procedure av_frame_get_pkt_duration         (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec; overload; deprecated;
-function  av_frame_get_pkt_pos              (frame: {const} PAVFrame): cint64;
-  cdecl; external av__codec; overload; deprecated;
-procedure av_frame_get_pkt_pos              (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec; overload; deprecated;
-function  av_frame_get_channel_layout       (frame: {const} PAVFrame): cint64;
-  cdecl; external av__codec; overload; deprecated;
-procedure av_frame_get_channel_layout       (frame: PAVFrame; val: cint64);
-  cdecl; external av__codec; overload; deprecated;
-function  av_frame_get_channels             (frame: {const} PAVFrame): cint;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_channels             (frame: PAVFrame; val: cint);
-  cdecl; external av__codec; deprecated;
-function  av_frame_get_sample_rate          (frame: {const} PAVFrame): cint;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_sample_rate          (frame: PAVFrame; val: cint);
-  cdecl; external av__codec; deprecated;
-function  av_frame_get_metadata             (frame: {const} PAVFrame): PAVDictionary;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_metadata             (frame: PAVFrame; val: PAVDictionary);
-  cdecl; external av__codec; deprecated;
-function  av_frame_get_decode_error_flags   (frame: {const} PAVFrame): cint;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_decode_error_flags   (frame: PAVFrame; val: cint);
-  cdecl; external av__codec; deprecated;
-function  av_frame_get_pkt_size             (frame: {const} PAVFrame): cint;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_pkt_size             (frame: PAVFrame; val: cint);
-  cdecl; external av__codec; deprecated;
-function avpriv_frame_get_metadatap(frame: PAVFrame): PPAVDictionary;
-  cdecl; external av__codec; deprecated;
-{$IFDEF FF_API_FRAME_QP}
-function av_frame_get_qp_table(f: PAVFrame; stride: pcint; type_: pcint): PByte;
-  cdecl; external av__codec; deprecated;
-function av_frame_set_qp_table(f: PAVFrame; buf: PAVBufferRef; stride: cint; type_: cint): cint;
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-function av_frame_get_colorspace(frame: {const} PAVFrame): TAVColorSpace;
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_colorspace(frame: PAVFrame; val: TAVColorSpace);
-  cdecl; external av__codec; deprecated;
-procedure av_frame_set_color_range(frame: PAVFrame; val: TAVColorSpace);
-  cdecl; external av__codec; deprecated;
-{$ENDIF}
-
-(**
- * Get the name of a colorspace.
- * @return a static string identifying the colorspace; can be NULL.
- *)
-function av_get_colorspace_name(val: TAVColorSpace): PAnsiChar;
-  cdecl; external av__codec;
-
-(**
- * Allocate an AVFrame and set its fields to default values.  The resulting
- * struct must be freed using av_frame_free().
- *
- * @return An AVFrame filled with default values or NULL on failure.
- *
- * @note this only allocates the AVFrame itself, not the data buffers. Those
- * must be allocated through other means, e.g. with av_frame_get_buffer() or
- * manually.
- *)
-function av_frame_alloc(): PAVFrame;
-  cdecl; external av__util;
-
-(**
- * Free the frame and any dynamically allocated objects in it,
- * e.g. extended_data. If the frame is reference counted, it will be
- * unreferenced first.
- *
- * @param frame frame to be freed. The pointer will be set to NULL.
- *)
-procedure av_frame_free(frame: PPAVFrame);
-  cdecl; external av__util;
-
-(**
- * Set up a new reference to the data described by the source frame.
- *
- * Copy frame properties from src to dst and create a new reference for each
- * AVBufferRef from src.
- *
- * If src is not reference counted, new buffers are allocated and the data is
- * copied.
- *
- * @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
- *           or newly allocated with av_frame_alloc() before calling this
- *           function, or undefined behavior will occur.
- *
- * @return 0 on success, a negative AVERROR on error
- *)
-function av_frame_ref(dst: PAVFrame; src: {const} PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Create a new frame that references the same data as src.
- *
- * This is a shortcut for av_frame_alloc()+av_frame_ref().
- *
- * @return newly created AVFrame on success, NULL on error.
- *)
-function av_frame_clone(src: {const} PAVFrame): PAVFrame;
-  cdecl; external av__codec;
-
-(**
- * Unreference all the buffers referenced by frame and reset the frame fields.
- *)
-procedure av_frame_unref(frame: PAVFrame);
-  cdecl; external av__util;
-
-(**
- * Move everything contained in src to dst and reset src.
- *
- * @warning: dst is not unreferenced, but directly overwritten without reading
- *           or deallocating its contents. Call av_frame_unref(dst) manually
- *           before calling this function to ensure that no memory is leaked.
- *)
-procedure av_frame_move_ref(dst, src: PAVFrame);
-  cdecl; external av__codec;
-
-(**
- * Allocate new buffer(s) for audio or video data.
- *
- * The following fields must be set on frame before calling this function:
- * - format (pixel format for video, sample format for audio)
- * - width and height for video
- * - nb_samples and channel_layout for audio
- *
- * This function will fill AVFrame.data and AVFrame.buf arrays and, if
- * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
- * For planar formats, one buffer will be allocated for each plane.
- *
- * @warning: if frame already has been allocated, calling this function will
- *           leak memory. In addition, undefined behavior can occur in certain
- *           cases.
- *
- * @param frame frame in which to store the new buffers.
- * @param align Required buffer size alignment. If equal to 0, alignment will be
- *              chosen automatically for the current CPU. It is highly
- *              recommended to pass 0 here unless you know what you are doing.
- *
- * @return 0 on success, a negative AVERROR on error.
- *)
-function av_frame_get_buffer(frame: PAVFrame; align: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * Check if the frame data is writable.
- *
- * @return A positive value if the frame data is writable (which is true if and
- * only if each of the underlying buffers has only one reference, namely the one
- * stored in this frame). Return 0 otherwise.
- *
- * If 1 is returned the answer is valid until av_buffer_ref() is called on any
- * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
- *
- * @see av_frame_make_writable(), av_buffer_is_writable()
- *)
-function av_frame_is_writable(frame: PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Ensure that the frame data is writable, avoiding data copy if possible.
- *
- * Do nothing if the frame is writable, allocate new buffers and copy the data
- * if it is not.
- *
- * @return 0 on success, a negative AVERROR on error.
- *
- * @see av_frame_is_writable(), av_buffer_is_writable(),
- * av_buffer_make_writable()
- *)
-function av_frame_make_writable(frame: PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Copy the frame data from src to dst.
- *
- * This function does not allocate anything, dst must be already initialized and
- * allocated with the same parameters as src.
- *
- * This function only copies the frame data (i.e. the contents of the data /
- * extended data arrays), not any other properties.
- *
- * @return >= 0 on success, a negative AVERROR on error.
- *)
-function av_frame_copy(dst: PAVFrame; src: {const} PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Copy only "metadata" fields from src to dst.
- *
- * Metadata for the purpose of this function are those fields that do not affect
- * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
- * aspect ratio (for video), but not width/height or channel layout.
- * Side data is also copied.
- *)
-function av_frame_copy_props(dst: PAVFrame; src: {const} PAVFrame): cint;
-  cdecl; external av__codec;
-
-(**
- * Get the buffer reference a given data plane is stored in.
- *
- * @param plane index of the data plane of interest in frame->extended_data.
- *
- * @return the buffer reference that contains the plane or NULL if the input
- * frame is not valid.
- *)
-function av_frame_get_plane_buffer(frame: PAVFrame; plane: cint): PAVBufferRef;
-  cdecl; external av__codec;
-
-(**
- * Add a new side data to a frame.
- *
- * @param frame a frame to which the side data should be added
- * @param type type of the added side data
- * @param size size of the side data
- *
- * @return newly added side data on success, NULL on error
- *)
-function av_frame_new_side_data(frame: PAVFrame;
-                                          type_: TAVFrameSideDataType;
-                                          size: cint): PAVFrameSideData;
-  cdecl; external av__codec;
-
-(**
- * Add a new side data to a frame from an existing AVBufferRef
- *
- * @param frame a frame to which the side data should be added
- * @param type  the type of the added side data
- * @param buf   an AVBufferRef to add as side data. The ownership of
- *              the reference is transferred to the frame.
- *
- * @return newly added side data on success, NULL on error. On failure
- *         the frame is unchanged and the AVBufferRef remains owned by
- *         the caller.
- *)
-function av_frame_new_side_data_from_buf(frame: PAVFrame;
-                                                 type_: TAVFrameSideDataType;
-                                                 buf: PAVBufferRef): PAVFrameSideData;
-  cdecl; external av__codec;
-
-(**
- * @return a pointer to the side data of a given type on success, NULL if there
- * is no side data with such type in this frame.
- *)
-function av_frame_get_side_data(frame: {const} PAVFrame; type_: TAVFrameSideDataType): PAVFrameSideData;
-  cdecl; external av__codec;
-
-(**
- * If side data of the supplied type exists in the frame, free it and remove it
- * from the frame.
- *)
-procedure av_frame_remove_side_data(frame: PAVFrame; type_: TAVFrameSideDataType);
-  cdecl; external av__codec;
-
-
-(**
- * Flags for frame cropping.
- *)
-const
-  (**
-   * Apply the maximum possible cropping, even if it requires setting the
-   * AVFrame.data[] entries to unaligned pointers. Passing unaligned data
-   * to FFmpeg API is generally not allowed, and causes undefined behavior
-   * (such as crashes). You can pass unaligned data only to FFmpeg APIs that
-   * are explicitly documented to accept it. Use this flag only if you
-   * absolutely know what you are doing.
-   *)
-  AV_FRAME_CROP_UNALIGNED     = 1 << 0;
-
-(**
- * Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
- * crop_bottom fields. If cropping is successful, the function will adjust the
- * data pointers and the width/height fields, and set the crop fields to 0.
- *
- * In all cases, the cropping boundaries will be rounded to the inherent
- * alignment of the pixel format. In some cases, such as for opaque hwaccel
- * formats, the left/top cropping is ignored. The crop fields are set to 0 even
- * if the cropping was rounded or ignored.
- *
- * @param frame the frame which should be cropped
- * @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
- *
- * @return >= 0 on success, a negative AVERROR on error. If the cropping fields
- * were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
- *)
-function av_frame_apply_cropping(frame: PAVFrame; flags: cint): cint;
-  cdecl; external av__codec;
-
-(**
- * @return a string identifying the side data type
- *)
-function av_frame_side_data_name(type_: TAVFrameSideDataType): PAnsiChar;
-  cdecl; external av__codec;
diff --git a/src/lib/ffmpeg-4.0/libavutil/log.pas b/src/lib/ffmpeg-4.0/libavutil/log.pas
deleted file mode 100644
index f86216441..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/log.pas
+++ /dev/null
@@ -1,530 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/log.h
- * avutil version 54.7.100
- *
- *)
-
-(**
- * @file
- * log
- *)
-
-type
-  (* from opt.h *)
-  TAVOptionType = (
-    AV_OPT_TYPE_FLAGS,
-    AV_OPT_TYPE_INT,
-    AV_OPT_TYPE_INT64,
-    AV_OPT_TYPE_DOUBLE,
-    AV_OPT_TYPE_FLOAT,
-    AV_OPT_TYPE_STRING,
-    AV_OPT_TYPE_RATIONAL,
-    AV_OPT_TYPE_BINARY,  ///< offset must point to a pointer immediately followed by an int for the length
-    AV_OPT_TYPE_DICT,
-    AV_OPT_TYPE_UINT64,
-    AV_OPT_TYPE_CONST,
-    AV_OPT_TYPE_BOOL,
-    AV_OPT_TYPE_CHANNEL_LAYOUT,
-    AV_OPT_TYPE_COLOR,
-    AV_OPT_TYPE_DURATION,
-    AV_OPT_TYPE_PIXEL_FMT,
-    AV_OPT_TYPE_SAMPLE_FMT,
-    AV_OPT_TYPE_IMAGE_SIZE,  ///< offset must point to two consecutive integers
-    AV_OPT_TYPE_VIDEO_RATE ///< offset must point to AVRational
-  );
-
-const
-  AV_OPT_FLAG_ENCODING_PARAM  = 1;   ///< a generic parameter which can be set by the user for muxing or encoding
-  AV_OPT_FLAG_DECODING_PARAM  = 2;   ///< a generic parameter which can be set by the user for demuxing or decoding
-  AV_OPT_FLAG_AUDIO_PARAM     = 8;
-  AV_OPT_FLAG_VIDEO_PARAM     = 16;
-  AV_OPT_FLAG_SUBTITLE_PARAM  = 32;
-  (**
-   * The option is intended for exporting values to the caller.
-   *)
-  AV_OPT_FLAG_EXPORT          = 64;
-  (**
-   * The option may not be set through the AVOptions API, only read.
-   * This flag only makes sense when AV_OPT_FLAG_EXPORT is also set.
-   *)
-  AV_OPT_FLAG_READONLY        = 128;
-  AV_OPT_FLAG_BSF_PARAM       = 1 shl 8;  ///< a generic parameter which can be set by the user for bit stream filtering
-  AV_OPT_FLAG_FILTERING_PARAM = 1 shl 16; ///< a generic parameter which can be set by the user for filtering
-
-type
-  (**
-   * AVOption
-   *)
-  PAVOption = ^TAVOption;
-  TAVOption = record
-    name: {const} PAnsiChar;
-    
-    (**
-     * short English help text
-     * @todo What about other languages?
-     *)
-    help: {const} PAnsiChar;
-
-    (**
-     * The offset relative to the context structure where the option
-     * value is stored. It should be 0 for named constants.
-     *)
-    offset: cint;
-    type_: TAVOptionType;
-
-    (**
-     * the default value for scalar options
-     *)
-    default_val: record
-      case cint of
-        0: (i64: cint64);
-        1: (dbl: cdouble);
-        2: (str: PAnsiChar);
-        (* TODO those are unused now *)
-        3: (q: TAVRational);
-      end;
-    min: cdouble;                ///< minimum valid value for the option
-    max: cdouble;                ///< maximum valid value for the option
-
-    flags: cint;
-//FIXME think about enc-audio, ... style flags
-
-    (**
-     * The logical unit to which the option belongs. Non-constant
-     * options and corresponding named constants share the same
-     * unit. May be NULL.
-     *)
-    unit_: {const} PAnsiChar;
-  end;
-
-type
-  PAVClassCategory = ^TAVClassCategory;
-  TAVClassCategory = (
-    AV_CLASS_CATEGORY_NA = 0,
-    AV_CLASS_CATEGORY_INPUT,
-    AV_CLASS_CATEGORY_OUTPUT,
-    AV_CLASS_CATEGORY_MUXER,
-    AV_CLASS_CATEGORY_DEMUXER,
-    AV_CLASS_CATEGORY_ENCODER,
-    AV_CLASS_CATEGORY_DECODER,
-    AV_CLASS_CATEGORY_FILTER,
-    AV_CLASS_CATEGORY_BITSTREAM_FILTER,
-    AV_CLASS_CATEGORY_SWSCALER,
-    AV_CLASS_CATEGORY_SWRESAMPLER,
-    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
-    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,
-    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT,
-    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT,
-    AV_CLASS_CATEGORY_DEVICE_OUTPUT,
-    AV_CLASS_CATEGORY_DEVICE_INPUT,
-    AV_CLASS_CATEGORY_NB ///< not part of ABI/API
-  );
-
-(*
-#define AV_IS_INPUT_DEVICE(category) \
-    (((category) == AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT) || \
-     ((category) == AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT) || \
-     ((category) == AV_CLASS_CATEGORY_DEVICE_INPUT))
-
-#define AV_IS_OUTPUT_DEVICE(category) \
-    (((category) == AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT) || \
-     ((category) == AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT) || \
-     ((category) == AV_CLASS_CATEGORY_DEVICE_OUTPUT))
-*)
-
-// struct AVOptionRanges;
-
-  (**
-   * A single allowed range of values, or a single allowed value.
-   *)
-  PAVOptionRange  = ^TAVOptionRange;
-  PPAVOptionRange = ^PAVOptionRange;
-  TAVOptionRange = record
-    str: {const} PAnsiChar;
-    (**
-     * Value range.
-     * For string ranges this represents the min/max length.
-     * For dimensions this represents the min/max pixel count or width/height in multi-component case.
-     *)
-    value_min, value_max: cdouble;
-		(**
-     * Value's component range.
-     * For string this represents the unicode range for chars, 0-127 limits to ASCII.
-     *)
-    component_min, component_max: cdouble;
-		(**
-     * Range flag.
-     * If set to 1 the struct encodes a range, if set to 0 a single value.
-     *)
-    is_range: cint;
-  end;
-
-  (**
-   * List of AVOptionRange structs.
-   *)
-  PAVOptionRanges  = ^TAVOptionRanges;
-  PPAVOptionRanges = ^PAVOptionRanges;
-  TAVOptionRanges = record
-    (**
-     * Array of option ranges.
-     *
-     * Most of option types use just one component.
-     * Following describes multi-component option types:
-     *
-     * AV_OPT_TYPE_IMAGE_SIZE:
-     * component index 0: range of pixel count (width * height).
-     * component index 1: range of width.
-     * component index 2: range of height.
-     *
-     * @note To obtain multi-component version of this structure, user must
-     *       provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or
-     *       av_opt_query_ranges_default function.
-     *
-     * Multi-component range can be read as in following example:
-     *
-     * @code
-     * int range_index, component_index;
-     * AVOptionRanges *ranges;
-     * AVOptionRange *range[3]; //may require more than 3 in the future.
-     * av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);
-     * for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {
-     *     for (component_index = 0; component_index < ranges->nb_components; component_index++)
-     *         range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];
-     *     //do something with range here.
-     * }
-     * av_opt_freep_ranges(&ranges);
-     * @endcode
-     *)
-    range:     PPAVOptionRange;
-    (**
-     * Number of ranges per component.
-     *)
-    nb_ranges: cint;
-    (**
-     * Number of componentes.
-     *)
-    nb_components: cint;
-  end;
-
-(**
- * Describe the class of an AVClass context structure. That is an
- * arbitrary struct of which the first field is a pointer to an
- * AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
- *)
-  PAVClass = ^TAVClass;
-  TAVClass = record
-    (**
-     * The name of the class; usually it is the same name as the
-     * context structure type to which the AVClass is associated.
-     *)
-    class_name: PAnsiChar;
-
-    (**
-     * A pointer to a function which returns the name of a context
-     * instance ctx associated with the class.
-     *)
-    item_name: function(ctx: pointer): PAnsiChar; cdecl;
-
-    (**
-     * a pointer to the first option specified in the class if any or NULL
-     *
-     * @see av_set_default_options()
-     *)
-    option: PAVOption;
-
-    (**
-     * LIBAVUTIL_VERSION with which this structure was created.
-     * This is used to allow fields to be added without requiring major
-     * version bumps everywhere.
-     *)
-    version: cint;
-
-    (**
-     * Offset in the structure where log_level_offset is stored.
-     * 0 means there is no such variable
-     *)
-    log_level_offset_offset: cint;
-
-    (**
-     * Offset in the structure where a pointer to the parent context for
-     * logging is stored. For example a decoder could pass its AVCodecContext
-     * to eval as such a parent context, which an av_log() implementation
-     * could then leverage to display the parent context.
-     * The offset can be NULL.
-     *)
-    parent_log_context_offset: cint;
-    
-    (**
-     * Return next AVOptions-enabled child or NULL
-     *)
-    child_next: function (obj: pointer; prev: pointer): pointer; cdecl;
-
-    (**
-     * Return an AVClass corresponding to the next potential
-     * AVOptions-enabled child.
-     *
-     * The difference between child_next and this is that
-     * child_next iterates over _already existing_ objects, while
-     * child_class_next iterates over _all possible_ children.
-     *)
-    child_class_next: function (prev: {const} PAVClass): {const} PAVClass; cdecl;
-
-    (**
-     * Category used for visualization (like color)
-     * This is only set if the category is equal for all objects using this class.
-     * available since version (51 << 16 | 56 << 8 | 100)
-     *)
-    category: TAVClassCategory;
-
-    (**
-     * Callback to return the category.
-     * available since version (51 << 16 | 59 << 8 | 100)
-     *)
-    get_category: function (ctx: pointer): PAVClassCategory; cdecl;
-
-    (**
-     * Callback to return the supported/allowed ranges.
-     * available since version (52.12)
-     *)
-    query_ranges: function (P: PPAVOptionRanges; obj: pointer; key: {const} PAnsiChar; flags: cint): cint; cdecl;
-end;
-
-const
-(**
- * Print no output.
- *)
-  AV_LOG_QUIET   = -8;
-
-(**
- * Something went really wrong and we will crash now.
- *)
-  AV_LOG_PANIC   =  0;
-
-(**
- * Something went wrong and recovery is not possible.
- * For example, no header was found for a format which depends
- * on headers or an illegal combination of parameters is used.
- *)
-  AV_LOG_FATAL   =  8;
-
-(**
- * Something went wrong and cannot losslessly be recovered.
- * However, not all future data is affected.
- *)
-  AV_LOG_ERROR   = 16;
-
-(**
- * Something somehow does not look correct. This may or may not
- * lead to problems. An example would be the use of '-vstrict -2'.
- *)
-  AV_LOG_WARNING = 24;
-
-(**
- * Standard information.
- *)
-  AV_LOG_INFO    = 32;
-
-(**
- * Detailed information.
- *)
-	AV_LOG_VERBOSE = 40;
-
-(**
- * Stuff which is only useful for libav* developers.
- *)
-  AV_LOG_DEBUG   = 48;
-
-(**
- * Extremely verbose debugging, useful for libav* development.
- *)
-  AV_LOG_TRACE    = 56;
-
-  AV_LOG_MAX_OFFSET = (AV_LOG_DEBUG - AV_LOG_QUIET);
-
-(**
- * Sets additional colors for extended debugging sessions.
- * @code
-   av_log(ctx, AV_LOG_DEBUG|AV_LOG_C(134), "Message in purple\n");
-   @endcode
- * Requires 256color terminal support. Uses outside debugging is not
- * recommended.
- *)
-{** to be translated if needed
-  AV_LOG_C(x) (x << 8)
-**}
-
-(**
- * Send the specified message to the log if the level is less than or equal
- * to the current av_log_level. By default, all logging messages are sent to
- * stderr. This behavior can be altered by setting a different logging callback
- * function.
- * @see av_log_set_callback
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct or NULL if general log.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- *)
-{** to be translated if needed
-void av_log(void *avcl, int level, const char *fmt, ...) av_printf_format(3, 4);
-**}
-
-type
-  va_list = pointer;
-
-(**
- * Send the specified message to the log if the level is less than or equal
- * to the current av_log_level. By default, all logging messages are sent to
- * stderr. This behavior can be altered by setting a different logging callback
- * function.
- * @see av_log_set_callback
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- * @param vl The arguments referenced by the format string.
- *)
-procedure av_vlog(avcl: pointer; level: cint; fmt: {const} PAnsiChar; vl: va_list);
-  cdecl; external av__util;
-
-(**
- * Get the current log level
- *
- * @see lavu_log_constants
- *
- * @return Current log level
- *)
-function av_log_get_level(): cint;
-  cdecl; external av__util;
-
-(**
- * Set the log level
- *
- * @see lavu_log_constants
- *
- * @param level Logging level
- *)
-procedure av_log_set_level(level: cint);
-  cdecl; external av__util;
-
-(**
- * Set the logging callback
- *
- * @note The callback must be thread safe, even if the application does not use
- *       threads itself as some codecs are multithreaded.
- *
- * @see av_log_default_callback
- *
- * @param callback A logging function with a compatible signature.
- *)
-{** to be translated if needed
-void av_log_set_callback(void (*callback)(void*, int, const char*, va_list));
-**}
-
-(**
- * Default logging callback
- *
- * It prints the message to stderr, optionally colorizing it.
- *
- * @param avcl A pointer to an arbitrary struct of which the first field is a
- *        pointer to an AVClass struct.
- * @param level The importance level of the message expressed using a @ref
- *        lavu_log_constants "Logging Constant".
- * @param fmt The format string (printf-compatible) that specifies how
- *        subsequent arguments are converted to output.
- * @param vl The arguments referenced by the format string.
- *)
-{** to be translated if needed
-void av_log_default_callback(void* avcl, int level, const char *fmt, va_list vl);
-**}
-
-(**
- * Return the context name
- *
- * @param  ctx The AVClass context
- *
- * @return The AVClass class_name
- *)
-function av_default_item_name(ctx: pointer): PAnsiChar;
-  cdecl; external av__util;
-function av_default_get_category(ptr: pointer): TAVClassCategory;
-  cdecl; external av__util;
-
-(**
- * Format a line of log the same way as the default callback.
- * @param line          buffer to receive the formatted line
- * @param line_size     size of the buffer
- * @param print_prefix  used to store whether the prefix must be printed;
- *                      must point to a persistent integer initially set to 1
- *)
-procedure av_log_format_line(ptr: pointer; level: cint; fmt: {const} PAnsiChar; vl: va_list;
-                        line: PAnsiChar; line_size: cint; print_prefix: Pcint);
-  cdecl; external av__util;
-
-(**
- * Format a line of log the same way as the default callback.
- * @param line          buffer to receive the formatted line;
- *                      may be NULL if line_size is 0
- * @param line_size     size of the buffer; at most line_size-1 characters will
- *                      be written to the buffer, plus one null terminator
- * @param print_prefix  used to store whether the prefix must be printed;
- *                      must point to a persistent integer initially set to 1
- * @return Returns a negative value if an error occurred, otherwise returns
- *         the number of characters that would have been written for a
- *         sufficiently large buffer, not including the terminating null
- *         character. If the return value is not less than line_size, it means
- *         that the log message was truncated to fit the buffer.
- *)
-function av_log_format_line2(ptr: pointer; level: cint; fmt: {const} PAnsiChar; vl: va_list;
-                             line: PAnsiChar; line_size: cint; print_prefix: Pcint): cint;
-  cdecl; external av__util;
-
-
-const
-(**
- * Skip repeated messages, this requires the user app to use av_log() instead of
- * (f)printf as the 2 would otherwise interfere and lead to
- * "Last message repeated x times" messages below (f)printf messages with some
- * bad luck.
- * Also to receive the last, "last repeated" line if any, the user app must
- * call av_log(NULL, AV_LOG_QUIET, "%s", ""); at the end
- *)
-  AV_LOG_SKIP_REPEATED = 1;
-
-(**
- * Include the log severity in messages originating from codecs.
- *
- * Results in messages such as:
- * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts
- *)
-  AV_LOG_PRINT_LEVEL = 2;
-
-procedure av_log_set_flags(arg: cint);
-  cdecl; external av__util;
-
-function av_log_get_flags: cint;
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/mathematics.pas b/src/lib/ffmpeg-4.0/libavutil/mathematics.pas
deleted file mode 100644
index f6df13681..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/mathematics.pas
+++ /dev/null
@@ -1,222 +0,0 @@
-(*
- * copyright (c) 2005-2012 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/mathematics.h
- * avutil version 54.7.100
- *
- *)
-
-(**
- * @file
- * @addtogroup lavu_math
- * Mathematical utilities for working with timestamp and time base.
- *)
-
-const
-  M_E          = 2.7182818284590452354;   // e
-  M_LN2        = 0.69314718055994530942;  // log_e 2
-  M_LN10       = 2.30258509299404568402;  // log_e 10
-  M_LOG2_10    = 3.32192809488736234787;  // log_2 10
-  M_PHI        = 1.61803398874989484820;  // phi / golden ratio
-  M_PI         = 3.14159265358979323846;  // pi
-  M_PI_2       = 1.57079632679489661923;  // pi/2
-  M_SQRT1_2    = 0.70710678118654752440;  // 1/sqrt(2)
-  M_SQRT2      = 1.41421356237309504880;  // sqrt(2)
-  NAN          = $7fc00000;     
-  INFINITY     = $7f800000;     
-
-(**
- * @addtogroup lavu_math
- * @
- *)
-
-type
-  (**
-   * Rounding methods.
-   *)
-  TAVRounding = (
-    AV_ROUND_ZERO     = 0, ///< Round toward zero.
-    AV_ROUND_INF      = 1, ///< Round away from zero.
-    AV_ROUND_DOWN     = 2, ///< Round toward -infinity.
-    AV_ROUND_UP       = 3, ///< Round toward +infinity.
-    AV_ROUND_NEAR_INF = 5, ///< Round to nearest and halfway cases away from zero.
-    (**
-     * Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
-     * unchanged, avoiding special cases for #AV_NOPTS_VALUE.
-     *
-     * Unlike other values of the enumeration AVRounding, this value is a
-     * bitmask that must be used in conjunction with another value of the
-     * enumeration through a bitwise OR, in order to set behavior for normal
-     * cases.
-     *
-     * @code{.c}
-     * av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
-     * // Rescaling 3:
-     * //     Calculating 3 * 1 / 2
-     * //     3 / 2 is rounded up to 2
-     * //     => 2
-     *
-     * av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
-     * // Rescaling AV_NOPTS_VALUE:
-     * //     AV_NOPTS_VALUE == INT64_MIN
-     * //     AV_NOPTS_VALUE is passed through
-     * //     => AV_NOPTS_VALUE
-     * @endcode
-     *)
-    AV_ROUND_PASS_MINMAX = 8192
-  );
-
-(**
- * Compute the greatest common divisor of two integer operands.
- *
- * @param a,b Operands
- * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
- * if a == 0 and b == 0, returns 0.
- *)
-function av_gcd(a, b: cint64): cint64;
-  cdecl; external av__util; {av_const}
-
-(**
- * Rescale a 64-bit integer with rounding to nearest.
- *
- * The operation is mathematically equivalent to `a * b / c`, but writing that
- * directly can overflow.
- *
- * This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
- *
- * @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
- *)
-function av_rescale (a, b, c: cint64): cint64;
-  cdecl; external av__util; {av_const}
-
-(**
- * Rescale a 64-bit integer with specified rounding.
- *
- * The operation is mathematically equivalent to `a * b / c`, but writing that
- * directly can overflow, and does not support different rounding methods.
- *
- * @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
- *)
-function av_rescale_rnd (a, b, c: cint64; rnd: TAVRounding): cint64;
-  cdecl; external av__util; {av_const}
-
-(**
- * Rescale a 64-bit integer by 2 rational numbers.
- *
- * The operation is mathematically equivalent to `a * bq / cq`.
- *
- * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
- *
- * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
- *)
-function av_rescale_q (a: cint64; bq, cq: TAVRational): cint64;
-  cdecl; external av__util; {av_const}
-
-(**
- * Rescale a 64-bit integer by 2 rational numbers with specified rounding.
- *
- * The operation is mathematically equivalent to `a * bq / cq`.
- *
- * @see av_rescale(), av_rescale_rnd(), av_rescale_q()
- *)
-function av_rescale_q_rnd(a: cint64; bq, cq: TAVRational;
-                          rnd: TAVRounding): cint64;
-  cdecl; external av__util; {av_const}
-
-(**
- * Compare two timestamps each in its own time base.
- *
- * @return One of the following values:
- *         - -1 if `ts_a` is before `ts_b`
- *         - 1 if `ts_a` is after `ts_b`
- *         - 0 if they represent the same position
- *
- * @warning
- * The result of the function is undefined if one of the timestamps is outside
- * the `int64_t` range when represented in the other's timebase.
- *)
-function av_compare_ts(ts_a: cint64; tb_a: TAVRational; ts_b: cint64; tb_b: TAVRational): cint;
-  cdecl; external av__util;
- 
-(**
- * Compare the remainders of two integer operands divided by a common divisor.
- *
- * In other words, compare the least significant `log2(mod)` bits of integers
- * `a` and `b`.
- *
- * @code{.c}
- * av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
- * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
- * @endcode
- *
- * @param a,b Operands
- * @param mod Divisor; must be a power of 2
- * @return
- *         - a negative value if `a % mod < b % mod`
- *         - a positive value if `a % mod > b % mod`
- *         - zero             if `a % mod == b % mod`
- *)
-function av_compare_mod(a, b, modVar: cuint64): cint64;
-  cdecl; external av__util;
-
-(**
- * Rescale a timestamp while preserving known durations.
- *
- * This function is designed to be called per audio packet to scale the input
- * timestamp to a different time base. Compared to a simple av_rescale_q()
- * call, this function is robust against possible inconsistent frame durations.
- *
- * The `last` parameter is a state variable that must be preserved for all
- * subsequent calls for the same stream. For the first call, `*last` should be
- * initialized to #AV_NOPTS_VALUE.
- *
- * @param[in]     in_tb    Input time base
- * @param[in]     in_ts    Input timestamp
- * @param[in]     fs_tb    Duration time base; typically this is finer-grained
- *                         (greater) than `in_tb` and `out_tb`
- * @param[in]     duration Duration till the next call to this function (i.e.
- *                         duration of the current packet/frame)
- * @param[in,out] last     Pointer to a timestamp expressed in terms of
- *                         `fs_tb`, acting as a state variable
- * @param[in]     out_tb   Output timebase
- * @return        Timestamp expressed in terms of `out_tb`
- *
- * @note In the context of this function, "duration" is in term of samples, not
- *       seconds.
- *)
-function av_rescale_delta(in_tb: TAVRational; in_ts: cint64;  fs_tb: TAVRational; duration: cint; last: Pcint64; out_tb: TAVRational): cint64;
-  cdecl; external av__util;
-
-(**
- * Add a value to a timestamp.
- *
- * This function guarantees that when the same value is repeatly added that
- * no accumulation of rounding errors occurs.
- *
- * @param ts Input timestamp
- * @param ts_tb Input timestamp timebase
- * @param inc value to add to ts
- * @param inc_tb inc timebase
- *)
-function av_add_stable(ts_tb: TAVRational; ts: cint64; inc_tb: TAVRational; inc: cint64): cint64;
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/mem.pas b/src/lib/ffmpeg-4.0/libavutil/mem.pas
deleted file mode 100644
index 30a878999..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/mem.pas
+++ /dev/null
@@ -1,578 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/mem.h
- * avutil version 52.66.100
- *
- *)
-
-(**
- * @file
- * error code definitions
- *)
-
-(* Memory handling functions *)
-
-(**
- * @defgroup lavu_mem_funcs Heap Management
- * Functions responsible for allocating, freeing, and copying memory.
- *
- * All memory allocation functions have a built-in upper limit of `INT_MAX`
- * bytes. This may be changed with av_max_alloc(), although exercise extreme
- * caution when doing so.
- *
- * @{
- *)
-
-(**
- * Allocate a memory block with alignment suitable for all memory accesses
- * (including vectors if available on the CPU).
- *
- * @param size Size in bytes for the memory block to be allocated
- * @return Pointer to the allocated block, or `NULL` if the block cannot
- *         be allocated
- * @see av_mallocz()
- * @see av_mallocz()
- *)
-function av_malloc(size: size_t): pointer;
-  cdecl; external av__util; {av_malloc_attrib av_alloc_size(1)}
-
-(**
- * Allocate a memory block with alignment suitable for all memory accesses
- * (including vectors if available on the CPU) and zero all the bytes of the
- * block.
- *
- * @param size Size in bytes for the memory block to be allocated
- * @return Pointer to the allocated block, or `NULL` if it cannot be allocated
- * @see av_malloc()
- *)
-function av_mallocz(size: size_t): pointer;
-  cdecl; external av__util; {av_malloc_attrib av_alloc_size(1)}
-
-(**
- * Allocate a memory block for an array with av_malloc().
- *
- * The allocated memory will have size `size * nmemb` bytes.
- *
- * @param nmemb Number of element
- * @param size  Size of a single element
- * @return Pointer to the allocated block, or `NULL` if the block cannot
- *         be allocated
- * @see av_malloc()
- *)
-function av_malloc_array(nmemb: size_t; size: size_t): pointer; {av_alloc_size(1, 2)}
-  cdecl; external av__util;
-
-(**
- * Allocate a memory block for an array with av_mallocz().
- *
- * The allocated memory will have size `size * nmemb` bytes.
- *
- * @param nmemb Number of elements
- * @param size  Size of the single element
- * @return Pointer to the allocated block, or `NULL` if the block cannot
- *         be allocated
- *
- * @see av_mallocz()
- * @see av_malloc_array()
- *)
-function av_mallocz_array(nmemb: size_t; size: size_t): pointer; {av_alloc_size(1, 2)}
-  cdecl; external av__util;
-
-(**
- * Allocate a block of nmemb * size bytes with alignment suitable for all
- * memory accesses (including vectors if available on the CPU) and
- * zero all the bytes of the block.
- * The allocation will fail if nmemb * size is greater than or equal
- * to INT_MAX.
- * @param nmemb
- * @param size
- * @return Pointer to the allocated block, NULL if it cannot be allocated.
- *)
-function av_calloc(nmemb: size_t; size: size_t): pointer;
-  cdecl; external av__util; {av_malloc_attrib}
-
-(**
- * Allocate, reallocate, or free a block of memory.
- *
- * If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
- * zero, free the memory block pointed to by `ptr`. Otherwise, expand or
- * shrink that block of memory according to `size`.
- *
- * @param ptr  Pointer to a memory block already allocated with
- *             av_realloc() or `NULL`
- * @param size Size in bytes of the memory block to be allocated or
- *             reallocated
- *
- * @return Pointer to a newly-reallocated block or `NULL` if the block
- *         cannot be reallocated or the function is used to free the memory block
- *
- * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
- *          correctly aligned.
- * @see av_fast_realloc()
- * @see av_reallocp()
- *)
-function av_realloc(ptr: pointer; size: size_t): pointer;
-  cdecl; external av__util; {av_alloc_size(2)}
-
-(**
- * Allocate, reallocate, or free a block of memory through a pointer to a
- * pointer.
- *
- * If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
- * zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
- * shrink that block of memory according to `size`.
- *
- * @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
- *                     with av_realloc(), or a pointer to `NULL`. The pointer
- *                     is updated on success, or freed on failure.
- * @param[in]     size Size in bytes for the memory block to be allocated or
- *                     reallocated
- *
- * @return Zero on success, an AVERROR error code on failure
- *
- * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
- *          correctly aligned.
- *)
-function av_reallocp(ptr: pointer; elsize: size_t): cint;
-  cdecl; external av__util;
-
-(**
- * Allocate, reallocate, or free a block of memory.
- *
- * This function does the same thing as av_realloc(), except:
- * - It takes two size arguments and allocates `nelem * elsize` bytes,
- *   after checking the result of the multiplication for integer overflow.
- * - It frees the input block in case of failure, thus avoiding the memory
- *   leak with the classic
- *   @code{.c}
- *   buf = realloc(buf);
- *   if (!buf)
- *       return -1;
- *   @endcode
- *   pattern.
- *)
-function av_realloc_f(ptr: pointer; nelem: size_t; elsize: size_t): pointer;
-  cdecl; external av__util;
-
-(**
- * Allocate, reallocate, or free an array.
- *
- * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
- * `nmemb` is zero, free the memory block pointed to by `ptr`.
- *
- * @param ptr   Pointer to a memory block already allocated with
- *              av_realloc() or `NULL`
- * @param nmemb Number of elements in the array
- * @param size  Size of the single element of the array
- *
- * @return Pointer to a newly-reallocated block or NULL if the block
- *         cannot be reallocated or the function is used to free the memory block
- *
- * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
- *          correctly aligned.
- * @see av_reallocp_array()
- *)
-function av_realloc_array(ptr: pointer; nmemb, size: size_t): pointer; {av_alloc_size(2, 3)}
-  cdecl; external av__util;
-
-(**
- * Allocate, reallocate, or free an array through a pointer to a pointer.
- *
- * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
- * zero, free the memory block pointed to by `*ptr`.
- *
- * @param[in,out] ptr   Pointer to a pointer to a memory block already
- *                      allocated with av_realloc(), or a pointer to `NULL`.
- *                      The pointer is updated on success, or freed on failure.
- * @param[in]     nmemb Number of elements
- * @param[in]     size  Size of the single element
- *
- * @return Zero on success, an AVERROR error code on failure
- *
- * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
- *          correctly aligned.
- *)
-function av_reallocp_array(ptr: pointer; nmemb, size: size_t): cint; {av_alloc_size(2, 3)}
-  cdecl; external av__util;
-
-(**
- * Reallocate the given buffer if it is not large enough, otherwise do nothing.
- *
- * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
- *
- * If the given buffer is not large enough, and reallocation fails, `NULL` is
- * returned and `*size` is set to 0, but the original buffer is not changed or
- * freed.
- *
- * A typical use pattern follows:
- *
- * @code{.c}
- * uint8_t *buf = ...;
- * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
- * if (!new_buf) {
- *     // Allocation failed; clean up original buffer
- *     av_freep(&buf);
- *     return AVERROR(ENOMEM);
- * }
- * @endcode
- *
- * @param[in,out] ptr      Already allocated buffer, or `NULL`
- * @param[in,out] size     Pointer to current size of buffer `ptr`. `*size` is
- *                         changed to `min_size` in case of success or 0 in
- *                         case of failure
- * @param[in]     min_size New size of buffer `ptr`
- * @return `ptr` if the buffer is large enough, a pointer to newly reallocated
- *         buffer if the buffer was not large enough, or `NULL` in case of
- *         error
- * @see av_realloc()
- * @see av_fast_malloc()
- *)
-function av_fast_realloc(ptr: pointer; size: Pcuint; min_size: size_t): pointer;
-  cdecl; external av__util;
-
-(**
- * Allocate a buffer, reusing the given one if large enough.
- *
- * Contrary to av_fast_realloc(), the current buffer contents might not be
- * preserved and on error the old buffer is freed, thus no special handling to
- * avoid memleaks is necessary.
- *
- * `*ptr` is allowed to be `NULL`, in which case allocation always happens if
- * `size_needed` is greater than 0.
- *
- * @code{.c}
- * uint8_t *buf = ...;
- * av_fast_malloc(&buf, &current_size, size_needed);
- * if (!buf) {
- *     // Allocation failed; buf already freed
- *     return AVERROR(ENOMEM);
- * }
- * @endcode
- *
- * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
- *                         `*ptr` will be overwritten with pointer to new
- *                         buffer on success or `NULL` on failure
- * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
- *                         changed to `min_size` in case of success or 0 in
- *                         case of failure
- * @param[in]     min_size New size of buffer `*ptr`
- * @see av_realloc()
- * @see av_fast_mallocz()
- *)
-procedure av_fast_malloc(ptr: pointer; size: Pcuint; min_size: size_t);
-  cdecl; external av__util;
-
-(**
- * Allocate and clear a buffer, reusing the given one if large enough.
- *
- * Like av_fast_malloc(), but all newly allocated space is initially cleared.
- * Reused buffer is not cleared.
- *
- * `*ptr` is allowed to be `NULL`, in which case allocation always happens if
- * `size_needed` is greater than 0.
- *
- * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
- *                         `*ptr` will be overwritten with pointer to new
- *                         buffer on success or `NULL` on failure
- * @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
- *                         changed to `min_size` in case of success or 0 in
- *                         case of failure
- * @param[in]     min_size New size of buffer `*ptr`
- * @see av_fast_malloc()
- *)
-procedure av_fast_mallocz(ptr: pointer; size: Pcuint; min_size: size_t);
-  cdecl; external av__util;
-
-(**
- * Free a memory block which has been allocated with a function of av_malloc()
- * or av_realloc() family.
- *
- * @param ptr Pointer to the memory block which should be freed.
- *
- * @note `ptr = NULL` is explicitly allowed.
- * @note It is recommended that you use av_freep() instead, to prevent leaving
- *       behind dangling pointers.
- * @see av_freep()
- *)
-procedure av_free(ptr: pointer);
-  cdecl; external av__util;
-
-(**
- * Free a memory block which has been allocated with a function of av_malloc()
- * or av_realloc() family, and set the pointer pointing to it to `NULL`.
- *
- * @code{.c}
- * uint8_t *buf = av_malloc(16);
- * av_free(buf);
- * // buf now contains a dangling pointer to freed memory, and accidental
- * // dereference of buf will result in a use-after-free, which may be a
- * // security risk.
- *
- * uint8_t *buf = av_malloc(16);
- * av_freep(&buf);
- * // buf is now NULL, and accidental dereference will only result in a
- * // NULL-pointer dereference.
- * @endcode
- *
- * @param ptr Pointer to the pointer to the memory block which should be freed
- * @note `*ptr = NULL` is safe and leads to no action.
- * @see av_free()
- *)
-procedure av_freep (ptr: pointer);
-  cdecl; external av__util;
-
-(**
- * Duplicate a string.
- *
- * @param s String to be duplicated
- * @return Pointer to a newly-allocated string containing a
- *         copy of `s` or `NULL` if the string cannot be allocated
- * @see av_strndup()
- *)
-function av_strdup({const} s: PAnsiChar): PAnsiChar;
-  cdecl; external av__util; {av_malloc_attrib}
-
-(**
- * Duplicate a substring of a string.
- *
- * @param s   String to be duplicated
- * @param len Maximum length of the resulting string (not counting the
- *            terminating byte)
- * @return Pointer to a newly-allocated string containing a
- *         substring of `s` or `NULL` if the string cannot be allocated
- *)
-function av_strndup({const} s: PAnsiChar; len: size_t): PAnsiChar;
-  cdecl; external av__util; {av_malloc_attrib}
-
-(**
- * Duplicate a buffer with av_malloc().
- *
- * @param p    Buffer to be duplicated
- * @param size Size in bytes of the buffer copied
- * @return Pointer to a newly allocated buffer containing a
- *         copy of `p` or `NULL` if the buffer cannot be allocated
- *)
-function av_memdup({const} p: pointer; size: size_t): pointer;
-  cdecl; external av__util;
-
-(**
- * Overlapping memcpy() implementation.
- *
- * @param dst  Destination buffer
- * @param back Number of bytes back to start copying (i.e. the initial size of
- *             the overlapping window); must be > 0
- * @param cnt  Number of bytes to copy; must be >= 0
- *
- * @note `cnt > back` is valid, this will copy the bytes we just copied,
- *       thus creating a repeating pattern with a period length of `back`.
- *)
-procedure av_memcpy_backptr(dst: Pcuint8; back: cint; cnt: cint);
-  cdecl; external av__util;
-
-(**
- * @}
- *)
-
-(**
- * @defgroup lavu_mem_dynarray Dynamic Array
- *
- * Utilities to make an array grow when needed.
- *
- * Sometimes, the programmer would want to have an array that can grow when
- * needed. The libavutil dynamic array utilities fill that need.
- *
- * libavutil supports two systems of appending elements onto a dynamically
- * allocated array, the first one storing the pointer to the value in the
- * array, and the second storing the value directly. In both systems, the
- * caller is responsible for maintaining a variable containing the length of
- * the array, as well as freeing of the array after use.
- *
- * The first system stores pointers to values in a block of dynamically
- * allocated memory. Since only pointers are stored, the function does not need
- * to know the size of the type. Both av_dynarray_add() and
- * av_dynarray_add_nofree() implement this system.
- *
- * @code
- * type **array = NULL; //< an array of pointers to values
- * int    nb    = 0;    //< a variable to keep track of the length of the array
- *
- * type to_be_added  = ...;
- * type to_be_added2 = ...;
- *
- * av_dynarray_add(&array, &nb, &to_be_added);
- * if (nb == 0)
- *     return AVERROR(ENOMEM);
- *
- * av_dynarray_add(&array, &nb, &to_be_added2);
- * if (nb == 0)
- *     return AVERROR(ENOMEM);
- *
- * // Now:
- * //  nb           == 2
- * // &to_be_added  == array[0]
- * // &to_be_added2 == array[1]
- *
- * av_freep(&array);
- * @endcode
- *
- * The second system stores the value directly in a block of memory. As a
- * result, the function has to know the size of the type. av_dynarray2_add()
- * implements this mechanism.
- *
- * @code
- * type *array = NULL; //< an array of values
- * int   nb    = 0;    //< a variable to keep track of the length of the array
- *
- * type to_be_added  = ...;
- * type to_be_added2 = ...;
- *
- * type *addr = av_dynarray2_add((void ** )&array, &nb, sizeof(*array), NULL);
- * if (!addr)
- *     return AVERROR(ENOMEM);
- * memcpy(addr, &to_be_added, sizeof(to_be_added));
- *
- * // Shortcut of the above.
- * type *addr = av_dynarray2_add((void ** )&array, &nb, sizeof(*array),
- *                               (const void * )&to_be_added2);
- * if (!addr)
- *     return AVERROR(ENOMEM);
- *
- * // Now:
- * //  nb           == 2
- * //  to_be_added  == array[0]
- * //  to_be_added2 == array[1]
- *
- * av_freep(&array);
- * @endcode
- *
- * @{
- *)
-
-
-(**
- * Add the pointer to an element to a dynamic array.
- *
- * The array to grow is supposed to be an array of pointers to
- * structures, and the element to add must be a pointer to an already
- * allocated structure.
- *
- * The array is reallocated when its size reaches powers of 2.
- * Therefore, the amortized cost of adding an element is constant.
- *
- * In case of success, the pointer to the array is updated in order to
- * point to the new grown array, and the number pointed to by `nb_ptr`
- * is incremented.
- * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
- * `*nb_ptr` is set to 0.
- *
- * @param[in,out] tab_ptr Pointer to the array to grow
- * @param[in,out] nb_ptr  Pointer to the number of elements in the array
- * @param[in]     elem    Element to add
- * @see av_dynarray_add_nofree(), av_dynarray2_add()
- *)
-procedure av_dynarray_add(tab_ptr: pointer; nb_ptr: Pcint; elem: pointer);
-  cdecl; external av__util;
-
-(**
- * Add an element to a dynamic array.
- *
- * Function has the same functionality as av_dynarray_add(),
- * but it doesn't free memory on fails. It returns error code
- * instead and leave current buffer untouched.
- *
- * @return >=0 on success, negative otherwise
- * @see av_dynarray_add(), av_dynarray2_add()
- *)
-function av_dynarray_add_nofree(tab_ptr: pointer; nb_ptr: Pcint; elem: pointer): cint;
-  cdecl; external av__util;
-
-(**
- * Add an element of size `elem_size` to a dynamic array.
- *
- * The array is reallocated when its number of elements reaches powers of 2.
- * Therefore, the amortized cost of adding an element is constant.
- *
- * In case of success, the pointer to the array is updated in order to
- * point to the new grown array, and the number pointed to by `nb_ptr`
- * is incremented.
- * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
- * `*nb_ptr` is set to 0.
- *
- * @param[in,out] tab_ptr   Pointer to the array to grow
- * @param[in,out] nb_ptr    Pointer to the number of elements in the array
- * @param[in]     elem_size Size in bytes of an element in the array
- * @param[in]     elem_data Pointer to the data of the element to add. If
- *                          `NULL`, the space of the newly added element is
- *                          allocated but left uninitialized.
- *
- * @return Pointer to the data of the element to copy in the newly allocated
- *         space
- * @see av_dynarray_add(), av_dynarray_add_nofree()
- *)
-function av_dynarray2_add(tab_ptr: Pointer; nb_ptr: Pcint; elem_size: size_t;
-                       {const} elem_data: Pcuint8): pointer;
-  cdecl; external av__util;
-
-(**
- * @}
- *)
-
-(**
- * @defgroup lavu_mem_misc Miscellaneous Functions
- *
- * Other functions related to memory allocation.
- *
- * @{
- *)
-
-(**
- * Multiply two `size_t` values checking for overflow.
- *
- * @param[in]  a,b Operands of multiplication
- * @param[out] r   Pointer to the result of the operation
- * @return 0 on success, AVERROR(EINVAL) on overflow
- *)
-//static inline int av_size_mult(size_t a, size_t b, size_t *r)
-{
-    size_t t = a * b;
-    /* Hack inspired from glibc: don't try the division if nelem and elsize
-     * are both less than sqrt(SIZE_MAX). */
-    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)
-        return AVERROR(EINVAL);
-    *r = t;
-    return 0;
-}
-
-(**
- * Set the maximum size that may be allocated in one block.
- *
- * The value specified with this function is effective for all libavutil's @ref
- * lavu_mem_funcs "heap management functions."
- *
- * By default, the max value is defined as `INT_MAX`.
- *
- * @param max Value to be set as the new maximum size
- *
- * @warning Exercise extreme caution when using this function. Don't touch
- *          this if you do not understand the full consequence of doing so.
- *)
-procedure av_max_alloc(max: size_t);
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/libavutil/opt.pas b/src/lib/ffmpeg-4.0/libavutil/opt.pas
deleted file mode 100644
index 87ec68aa5..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/opt.pas
+++ /dev/null
@@ -1,507 +0,0 @@
-(*
- * AVOptions
- * copyright (c) 2005 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/opt.h
- * avutil version 54.7.100
- *
- *)
-
-(**
- * Show the obj options.
- *
- * @param req_flags requested flags for the options to show. Show only the
- * options for which it is opt->flags & req_flags.
- * @param rej_flags rejected flags for the options to show. Show only the
- * options for which it is !(opt->flags & req_flags).
- * @param av_log_obj log context to use for showing the options
- *)
-function av_opt_show2(obj: pointer; av_log_obj: pointer; req_flags: cint; rej_flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Set the values of all AVOption fields to their default values.
- *
- * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
- *)
-procedure av_opt_set_defaults(s: pointer);
-  cdecl; external av__util;
-
-(**
- * Set the values of all AVOption fields to their default values. Only these
- * AVOption fields for which (opt->flags & mask) == flags will have their
- * default applied to s.
- *
- * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
- * @param mask combination of AV_OPT_FLAG_*
- * @param flags combination of AV_OPT_FLAG_*
- *)
-procedure av_opt_set_defaults2(s: Pointer; mask: cint; flags: cint);
-  cdecl; external av__util; deprecated;
-
-(**
- * Parse the key/value pairs list in opts. For each key/value pair
- * found, stores the value in the field in ctx that is named like the
- * key. ctx must be an AVClass context, storing is done using
- * AVOptions.
- *
- * @param opts options string to parse, may be NULL
- * @param key_val_sep a 0-terminated list of characters used to
- * separate key from value
- * @param pairs_sep a 0-terminated list of characters used to separate
- * two pairs from each other
- * @return the number of successfully set key/value pairs, or a negative
- * value corresponding to an AVERROR code in case of error:
- * AVERROR(EINVAL) if opts cannot be parsed,
- * the error code issued by av_set_string3() if a key/value pair
- * cannot be set
-*)
-function av_set_options_string(ctx: pointer; opts: {const} PAnsiChar;
-                      key_val_sep: {const} PAnsiChar; pairs_sep: {const} PAnsiChar): cint;
-  cdecl; external av__util;
-
-(**
- * Parse the key-value pairs list in opts. For each key=value pair found,
- * set the value of the corresponding option in ctx.
- *
- * @param ctx          the AVClass object to set options on
- * @param opts         the options string, key-value pairs separated by a
- *                     delimiter
- * @param shorthand    a NULL-terminated array of options names for shorthand
- *                     notation: if the first field in opts has no key part,
- *                     the key is taken from the first element of shorthand;
- *                     then again for the second, etc., until either opts is
- *                     finished, shorthand is finished or a named option is
- *                     found; after that, all options must be named
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @return  the number of successfully set key=value pairs, or a negative
- *          value corresponding to an AVERROR code in case of error:
- *          AVERROR(EINVAL) if opts cannot be parsed,
- *          the error code issued by av_set_string3() if a key/value pair
- *          cannot be set
- *
- * Options names must use only the following characters: a-z A-Z 0-9 - . / _
- * Separators must use characters distinct from option names and from each
- * other.
- *)
-function av_opt_set_from_string(ctx: pointer; opts: {const} PAnsiChar;
-                           shorthand: {const} PAnsiChar;
-                           key_val_sep: {const} PAnsiChar; pairs_sep: {const} PAnsiChar): cint;
-  cdecl; external av__util;
-
-(**
- * Free all allocated objects in obj.
- *)
-procedure av_opt_free(obj: pointer);
-  cdecl; external av__util;
-
-(**
- * Check whether a particular flag is set in a flags field.
- *
- * @param field_name the name of the flag field option
- * @param flag_name the name of the flag to check
- * @return non-zero if the flag is set, zero if the flag isn't set,
- *         isn't of the right type, or the flags field doesn't exist.
- *)
-function av_opt_flag_is_set(obj: pointer; field_name: {const} PAnsiChar; flag_name: {const} PAnsiChar): cint;
-  cdecl; external av__util;
-
-(**
- * Set all the options from a given dictionary on an object.
- *
- * @param obj a struct whose first element is a pointer to AVClass
- * @param options options to process. This dictionary will be freed and replaced
- *                by a new one containing all options not found in obj.
- *                Of course this new dictionary needs to be freed by caller
- *                with av_dict_free().
- *
- * @return 0 on success, a negative AVERROR if some option was found in obj,
- *         but could not be set.
- *
- * @see av_dict_copy()
- *)
-function av_opt_set_dict(obj: pointer; var options: PAVDictionary): cint;
-  cdecl; external av__util;
-
-(**
- * Set all the options from a given dictionary on an object.
- *
- * @param obj a struct whose first element is a pointer to AVClass
- * @param options options to process. This dictionary will be freed and replaced
- *                by a new one containing all options not found in obj.
- *                Of course this new dictionary needs to be freed by caller
- *                with av_dict_free().
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- *
- * @return 0 on success, a negative AVERROR if some option was found in obj,
- *         but could not be set.
- *
- * @see av_dict_copy()
- *)
-function av_opt_set_dict2(obj: pointer; var options: PAVDictionary; search_flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Extract a key-value pair from the beginning of a string.
- *
- * @param ropts        pointer to the options string, will be updated to
- *                     point to the rest of the string (one of the pairs_sep
- *                     or the final NUL)
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @param flags        flags; see the AV_OPT_FLAG_* values below
- * @param rkey         parsed key; must be freed using av_free()
- * @param rval         parsed value; must be freed using av_free()
- *
- * @return  >=0 for success, or a negative value corresponding to an
- *          AVERROR code in case of error; in particular:
- *          AVERROR(EINVAL) if no key is present
- *
- *)
-function av_opt_get_key_value(ropts: {const} PPAnsiChar;
-                     key_val_sep: {const} PAnsiChar; pairs_sep: {const} PAnsiChar;
-                     flags: byte;
-                     rkey, rval: PPAnsiChar): cint;
-  cdecl; external av__util;
-
-const
-  (**
-   * Accept to parse a value without a key; the key will then be returned
-   * as NULL.
-   *)
-  AV_OPT_FLAG_IMPLICIT_KEY = 1;
-
-(**
- * @defgroup opt_eval_funcs Evaluating option strings
- * @
- * This group of functions can be used to evaluate option strings
- * and get numbers out of them. They do the same thing as av_opt_set(),
- * except the result is written into the caller-supplied pointer.
- *
- * @param obj a struct whose first element is a pointer to AVClass.
- * @param o an option for which the string is to be evaluated.
- * @param val string to be evaluated.
- * @param *_out value of the string will be written here.
- *
- * @return 0 on success, a negative number on failure.
- *)
-function av_opt_eval_flags (obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; flags_out:  Pcint):       cint;
-  cdecl; external av__util;
-function av_opt_eval_int   (obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; int_out:    Pcint):       cint;
-  cdecl; external av__util;
-function av_opt_eval_int64 (obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; int64_out:  Pcint64):     cint;
-  cdecl; external av__util;
-function av_opt_eval_float (obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; float_out:  Pcfloat):     cint;
-  cdecl; external av__util;
-function av_opt_eval_double(obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; double_out: Pcdouble):    cint;
-  cdecl; external av__util;
-function av_opt_eval_q     (obj: pointer; o: {const} PAVOption; val: {const} PAnsiChar; q_out:      PAVRational): cint;
-  cdecl; external av__util;
-(**
- * @
- *)
-
-const
-  AV_OPT_SEARCH_CHILDREN = (1 << 0); (**< Search in possible children of the
-                                      given object first.*)
-(**
- *  The obj passed to av_opt_find() is fake -- only a double pointer to AVClass
- *  instead of a required pointer to a struct containing AVClass. This is
- *  useful for searching for options without needing to allocate the corresponding
- *  object.
- *)
-  AV_OPT_SEARCH_FAKE_OBJ = (1 << 1);
-
-(**
- *  In av_opt_get, return NULL if the option has a pointer type and is set to NULL,
- *  rather than returning an empty string.
- *)
-  AV_OPT_ALLOW_NULL = (1 << 2);
-(**
- *  Allows av_opt_query_ranges and av_opt_query_ranges_default to return more than
- *  one component for certain option types.
- *  @see AVOptionRanges for details.
- *)
-  AV_OPT_MULTI_COMPONENT_RANGE = (1 << 12);
-
-(**
- * Look for an option in an object. Consider only options which
- * have all the specified flags set.
- *
- * @param[in] obj A pointer to a struct whose first element is a
- *                pointer to an AVClass.
- * @param[in] name The name of the option to look for.
- * @param[in] unit When searching for named constants, name of the unit
- *                 it belongs to.
- * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- *
- * @return A pointer to the option found, or NULL if no option
- *         was found.
- *
- * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
- * directly with av_set_string3(). Use special calls which take an options
- * AVDictionary (e.g. avformat_open_input()) to set options found with this
- * flag.
- *)
-function av_opt_find(obj: pointer; name: {const} PAnsiChar; unit_: {const} PAnsiChar;
-                     opt_flags: cint; search_flags: cint): PAVOption;
-  cdecl; external av__util;
-
-(**
- * Look for an option in an object. Consider only options which
- * have all the specified flags set.
- *
- * @param[in] obj A pointer to a struct whose first element is a
- *                pointer to an AVClass.
- *                Alternatively a double pointer to an AVClass, if
- *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.
- * @param[in] name The name of the option to look for.
- * @param[in] unit When searching for named constants, name of the unit
- *                 it belongs to.
- * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- * @param[out] target_obj if non-NULL, an object to which the option belongs will be
- * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
- * in search_flags. This parameter is ignored if search_flags contain
- * AV_OPT_SEARCH_FAKE_OBJ.
- *
- * @return A pointer to the option found, or NULL if no option
- *         was found.
- *)
-function av_opt_find2(obj: pointer; name: {const} PAnsiChar; unit_: {const} PAnsiChar;
-                      opt_flags: cint; search_flags: cint; out target_obj: pointer): {const} PAVOption;
-  cdecl; external av__util;
-
-(**
- * Iterate over all AVOptions belonging to obj.
- *
- * @param obj an AVOptions-enabled struct or a double pointer to an
- *            AVClass describing it.
- * @param prev result of the previous call to av_opt_next() on this object
- *             or NULL
- * @return next AVOption or NULL
- *)
-function av_opt_next(obj: {const} pointer; prev: {const} PAVOption): {const} PAVOption;
-  cdecl; external av__util;
-
-(**
- * Iterate over AVOptions-enabled children of obj.
- *
- * @param prev result of a previous call to this function or NULL
- * @return next AVOptions-enabled child or NULL
- *)
-function av_opt_child_next(obj: pointer; prev: pointer): pointer;
-  cdecl; external av__util;
-
-(**
- * Iterate over potential AVOptions-enabled children of parent.
- *
- * @param prev result of a previous call to this function or NULL
- * @return AVClass corresponding to next potential child or NULL
- *)
-function av_opt_child_class_next(parent: {const} PAVClass; prev: {const} PAVClass): {const} PAVClass;
-  cdecl; external av__util;
-
-(**
- * @defgroup opt_set_funcs Option setting functions
- * @
- * Those functions set the field of obj with the given name to value.
- *
- * @param[in] obj A struct whose first element is a pointer to an AVClass.
- * @param[in] name the name of the field to set
- * @param[in] val The value to set. In case of av_opt_set() if the field is not
- * of a string type, then the given string is parsed.
- * SI postfixes and some named scalars are supported.
- * If the field is of a numeric type, it has to be a numeric or named
- * scalar. Behavior with more than one scalar and +- infix operators
- * is undefined.
- * If the field is of a flags type, it has to be a sequence of numeric
- * scalars or named flags separated by '+' or '-'. Prefixing a flag
- * with '+' causes it to be set without affecting the other flags;
- * similarly, '-' unsets a flag.
- * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
- * is passed here, then the option may be set on a child of obj.
- *
- * @return 0 if the value has been set, or an AVERROR code in case of
- * error:
- * AVERROR_OPTION_NOT_FOUND if no matching option exists
- * AVERROR(ERANGE) if the value is out of range
- * AVERROR(EINVAL) if the value is not valid
- *)
-function av_opt_set           (obj: pointer; name: {const} PAnsiChar; val: {const} PAnsiChar; search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_int       (obj: pointer; name: {const} PAnsiChar; val: cint64;            search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_double    (obj: pointer; name: {const} PAnsiChar; val: cdouble;           search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_q         (obj: pointer; name: {const} PAnsiChar; val: TAVRational;       search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_bin       (obj: pointer; name: {const} PAnsiChar; val: {const} cuint8;    search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_image_size(obj: pointer; name: {const} PAnsiChar; w, h,                   search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_pixel_fmt (obj: pointer; name: {const} PAnsiChar; fmt: TAVPixelFormat;    search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_sample_fmt(obj: pointer; name: {const} PAnsiChar; fmt: TAVSampleFormat;    search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_video_rate(obj: pointer; name: {const} PAnsiChar; val: TAVRational;       search_flags: cint): cint;
-  cdecl; external av__util;
-function av_opt_set_channel_layout(obj: pointer; name: {const} PAnsiChar; ch_layout: cint64; search_flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * @note Any old dictionary present is discarded and replaced with a copy of the new one. The
- * caller still owns val is and responsible for freeing it.
- *)
-function av_opt_set_dict_val(obj: pointer; name: {const} PAnsiChar; val: {const} PAVDictionary; search_flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Set a binary option to an integer list.
- *
- * @param obj    AVClass object to set options on
- * @param name   name of the binary option
- * @param val    pointer to an integer list (must have the correct type with
- *               regard to the contents of the list)
- * @param term   list terminator (usually 0 or -1)
- * @param flags  search flags
- *)
-{to be translated
-#define av_opt_set_int_list(obj, name, val, term, flags) \
-    (av_int_list_length(val, term) > INT_MAX / sizeof(*(val)) ? \
-     AVERROR(EINVAL) : \
-     av_opt_set_bin(obj, name, (const uint8_t *)(val), \
-                    av_int_list_length(val, term) * sizeof(*(val)), flags))
-}
-(**
- * @
- *)
-
-(**
- * @defgroup opt_get_funcs Option getting functions
- * @
- * Those functions get a value of the option with the given name from an object.
- *
- * @param[in] obj a struct whose first element is a pointer to an AVClass.
- * @param[in] name name of the option to get.
- * @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
- * is passed here, then the option may be found in a child of obj.
- * @param[out] out_val value of the option will be written here
- * @return >=0 on success, a negative error code otherwise
- *)
-(**
- * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
- *
- * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has
- * AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set
- * to NULL instead of an allocated empty string.
- *)
-function av_opt_get           (obj: pointer; name: {const} PAnsiChar; search_flags: cint; out out_val: Pcuint8):     cint;
-  cdecl; external av__util;
-function av_opt_get_int       (obj: pointer; name: {const} PAnsiChar; search_flags: cint;     out_val: Pcint64):     cint;
-  cdecl; external av__util;
-function av_opt_get_double    (obj: pointer; name: {const} PAnsiChar; search_flags: cint;     out_val: Pcdouble):    cint;
-  cdecl; external av__util;
-function av_opt_get_q         (obj: pointer; name: {const} PAnsiChar; search_flags: cint;     out_val: PAVRational): cint;
-  cdecl; external av__util;
-function av_opt_get_image_size(obj: pointer; name: {const} PAnsiChar; search_flags: cint; w_out, h_out: Pcint):      cint;
-  cdecl; external av__util;
-function av_opt_get_pixel_fmt (obj: pointer; name: {const} PAnsiChar; search_flags: cint; out_fmt: PAVPixelFormat):  cint;
-  cdecl; external av__util;
-function av_opt_get_sample_fmt(obj: pointer; name: {const} PAnsiChar; search_flags: cint; out_fmt: PAVPixelFormat):  cint;
-  cdecl; external av__util;
-function av_opt_get_video_rate(obj: pointer; name: {const} PAnsiChar; search_flags: cint; out_val: PAVRational):     cint;
-  cdecl; external av__util;
-function av_opt_get_channel_layout(obj: pointer; name: {const} PAnsiChar; search_flags: cint; ch_layout: Pcint64):   cint;
-  cdecl; external av__util;
-(**
- * @param[out] out_val The returned dictionary is a copy of the actual value and must
- * be freed with av_dict_free() by the caller
- *)
-function av_opt_get_dict_val  (obj: pointer; name: {const} PAnsiChar; search_flags: cint; out out_val: PAVDictionary): cint;
-  cdecl; external av__util;
-(**
- * @
- *)
-(**
- * Gets a pointer to the requested field in a struct.
- * This function allows accessing a struct even when its fields are moved or
- * renamed since the application making the access has been compiled,
- *
- * @returns a pointer to the field, it can be cast to the correct type and read
- *          or written to.
- *)
-function av_opt_ptr(avclass: {const} PAVClass; obj: pointer; name: {const} PAnsiChar): pointer;
-  cdecl; external av__util;
-
-(**
- * Free an AVOptionRanges struct and set it to NULL.
- *)
-procedure av_opt_freep_ranges(ranges: PPAVOptionRanges);
-  cdecl; external av__util;
-
-(**
- * Get a list of allowed ranges for the given option.
- *
- * The returned list may depend on other fields in obj like for example profile.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
- *
- * The result must be freed with av_opt_freep_ranges.
- *
- * @return number of compontents returned on success, a negative errro code otherwise
- *)
-function av_opt_query_ranges(P: PPAVOptionRanges; obj: pointer; key: {const} PAnsiChar; flags: cint): cint;
-  cdecl; external av__util;
-
-function av_opt_copy(dest: pointer;src: {const }pointer): cint;
-  cdecl; external av__util;
-
-(**
- * Get a default list of allowed ranges for the given option.
- *
- * This list is constructed without using the AVClass.query_ranges() callback
- * and can be used as fallback from within the callback.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
- *
- * The result must be freed with av_opt_free_ranges.
- *
- * @return number of compontents returned on success, a negative errro code otherwise
- *)
-function av_opt_query_ranges_default(P: PPAVOptionRanges; obj: pointer; key: {const} PAnsiChar; flags: cint): cint;
-  cdecl; external av__util;
-
-(**
- * @
- *)
diff --git a/src/lib/ffmpeg-4.0/libavutil/pixfmt.pas b/src/lib/ffmpeg-4.0/libavutil/pixfmt.pas
deleted file mode 100644
index a8cdad64c..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/pixfmt.pas
+++ /dev/null
@@ -1,599 +0,0 @@
-(*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/pixfmt.h
- * avutil version 54.7.100
- *
- *)
-
-(**
- * @file
- * Pixel format
- *)
-
-const
-  AVPALETTE_SIZE  = 1024;
-  AVPALETTE_COUNT =  256;
-
-type
-(**
- * Pixel format. Notes:
- *
- * @note
- * AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
- * color is put together as:
- *  (A << 24) | (R << 16) | (G << 8) | B
- * This is stored as BGRA on little-endian CPU architectures and ARGB on
- * big-endian CPUs.
- *
- * @par
- * When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
- * image data is stored in AVFrame.data[0]. The palette is transported in
- * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
- * formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
- * also endian-specific). Note also that the individual RGB32 palette
- * components stored in AVFrame.data[1] should be in the range 0..255.
- * This is important as many custom PAL8 video codecs that were designed
- * to run on the IBM VGA graphics adapter use 6-bit palette components.
- *
- * @par
- * For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
- * for pal8. This palette is filled in automatically by the function
- * allocating the picture.
- *)
-
-  PAVPixelFormat = ^TAVPixelFormat;
-  TAVPixelFormat = (
-    AV_PIX_FMT_NONE = -1,
-    AV_PIX_FMT_YUV420P,   ///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
-    AV_PIX_FMT_YUYV422,   ///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
-    AV_PIX_FMT_RGB24,     ///< packed RGB 8:8:8, 24bpp, RGBRGB...
-    AV_PIX_FMT_BGR24,     ///< packed RGB 8:8:8, 24bpp, BGRBGR...
-    AV_PIX_FMT_YUV422P,   ///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
-    AV_PIX_FMT_YUV444P,   ///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
-    AV_PIX_FMT_YUV410P,   ///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
-    AV_PIX_FMT_YUV411P,   ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
-    AV_PIX_FMT_GRAY8,     ///<        Y        ,  8bpp
-    AV_PIX_FMT_MONOWHITE, ///<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
-    AV_PIX_FMT_MONOBLACK, ///<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
-    AV_PIX_FMT_PAL8,      ///< 8 bits with AV_PIX_FMT_RGB32 palette
-    AV_PIX_FMT_YUVJ420P,  ///< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range
-    AV_PIX_FMT_YUVJ422P,  ///< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range
-    AV_PIX_FMT_YUVJ444P,  ///< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range
-    AV_PIX_FMT_UYVY422,   ///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
-    AV_PIX_FMT_UYYVYY411, ///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
-    AV_PIX_FMT_BGR8,      ///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
-    AV_PIX_FMT_BGR4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
-    AV_PIX_FMT_BGR4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
-    AV_PIX_FMT_RGB8,      ///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
-    AV_PIX_FMT_RGB4,      ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
-    AV_PIX_FMT_RGB4_BYTE, ///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
-    AV_PIX_FMT_NV12,      ///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
-    AV_PIX_FMT_NV21,      ///< as above, but U and V bytes are swapped
-
-    AV_PIX_FMT_ARGB,      ///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
-    AV_PIX_FMT_RGBA,      ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
-    AV_PIX_FMT_ABGR,      ///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
-    AV_PIX_FMT_BGRA,      ///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
-
-    AV_PIX_FMT_GRAY16BE,  ///<        Y        , 16bpp, big-endian
-    AV_PIX_FMT_GRAY16LE,  ///<        Y        , 16bpp, little-endian
-    AV_PIX_FMT_YUV440P,   ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
-    AV_PIX_FMT_YUVJ440P,  ///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range
-    AV_PIX_FMT_YUVA420P,  ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
-    AV_PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
-    AV_PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
-
-    AV_PIX_FMT_RGB565BE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
-    AV_PIX_FMT_RGB565LE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
-    AV_PIX_FMT_RGB555BE,  ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian, most significant bit to 0
-    AV_PIX_FMT_RGB555LE,  ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, most significant bit to 0
-
-    AV_PIX_FMT_BGR565BE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
-    AV_PIX_FMT_BGR565LE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
-    AV_PIX_FMT_BGR555BE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian, most significant bit to 1
-    AV_PIX_FMT_BGR555LE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, most significant bit to 1
-{$IFDEF FF_API_VAAPI}
-    (** Deprecated pixel formats *)
-    AV_PIX_FMT_VAAPI_MOCO, ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
-    AV_PIX_FMT_VAAPI_IDCT, ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
-    AV_PIX_FMT_VAAPI_VLD,  ///< HW decoding through VA API, Picture.data[3] contains a VASurfaceID
-
-    AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
-{$ELSE}
-    AV_PIX_FMT_VAAPI,
-{$ENDIF}
-    AV_PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    AV_PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    AV_PIX_FMT_YUV422P16LE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_YUV422P16BE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    AV_PIX_FMT_YUV444P16LE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    AV_PIX_FMT_YUV444P16BE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    AV_PIX_FMT_DXVA2_VLD,    ///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
-
-    AV_PIX_FMT_RGB444LE,  ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, most significant bits to 0
-    AV_PIX_FMT_RGB444BE,  ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian, most significant bits to 0
-    AV_PIX_FMT_BGR444LE,  ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, most significant bits to 1
-    AV_PIX_FMT_BGR444BE,  ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian, most significant bits to 1
-    AV_PIX_FMT_YA8,       ///< 8 bits gray, 8 bits alpha
-(* see const declaration way down
-    AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, ///< alias for AV_PIX_FMT_YA8
-    AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, ///< alias for AV_PIX_FMT_YA8
-*)
-    AV_PIX_FMT_BGR48BE,   ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
-    AV_PIX_FMT_BGR48LE,   ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
-
-    (**
-     * The following 12 formats have the disadvantage of needing 1 format for each bit depth.
-     * Notice that each 9/10 bits sample is stored in 16 bits with extra padding.
-     * If you want to support multiple bit depths, then using AV_PIX_FMT_YUV420P16* with the bpp stored separately is better.
-     *)
-    AV_PIX_FMT_YUV420P9BE, ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    AV_PIX_FMT_YUV420P9LE, ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    AV_PIX_FMT_YUV420P10BE,///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    AV_PIX_FMT_YUV420P10LE,///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    AV_PIX_FMT_YUV422P10BE,///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    AV_PIX_FMT_YUV422P10LE,///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_YUV444P9BE, ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    AV_PIX_FMT_YUV444P9LE, ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    AV_PIX_FMT_YUV444P10BE,///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    AV_PIX_FMT_YUV444P10LE,///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    AV_PIX_FMT_YUV422P9BE, ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    AV_PIX_FMT_YUV422P9LE, ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_GBRP,      ///< planar GBR 4:4:4 24bpp
-    AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, // alias for #AV_PIX_FMT_GBRP
-    AV_PIX_FMT_GBRP9BE,   ///< planar GBR 4:4:4 27bpp, big-endian
-    AV_PIX_FMT_GBRP9LE,   ///< planar GBR 4:4:4 27bpp, little-endian
-    AV_PIX_FMT_GBRP10BE,  ///< planar GBR 4:4:4 30bpp, big-endian
-    AV_PIX_FMT_GBRP10LE,  ///< planar GBR 4:4:4 30bpp, little-endian
-    AV_PIX_FMT_GBRP16BE,  ///< planar GBR 4:4:4 48bpp, big-endian
-    AV_PIX_FMT_GBRP16LE,  ///< planar GBR 4:4:4 48bpp, little-endian
-    AV_PIX_FMT_YUVA422P,  ///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
-    AV_PIX_FMT_YUVA444P,  ///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
-    AV_PIX_FMT_YUVA420P9BE,  ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian
-    AV_PIX_FMT_YUVA420P9LE,  ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian
-    AV_PIX_FMT_YUVA422P9BE,  ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian
-    AV_PIX_FMT_YUVA422P9LE,  ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian
-    AV_PIX_FMT_YUVA444P9BE,  ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
-    AV_PIX_FMT_YUVA444P9LE,  ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
-    AV_PIX_FMT_YUVA420P10BE, ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA420P10LE, ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
-    AV_PIX_FMT_YUVA422P10BE, ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA422P10LE, ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
-    AV_PIX_FMT_YUVA444P10BE, ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA444P10LE, ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
-    AV_PIX_FMT_YUVA420P16BE, ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA420P16LE, ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
-    AV_PIX_FMT_YUVA422P16BE, ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA422P16LE, ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
-    AV_PIX_FMT_YUVA444P16BE, ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
-    AV_PIX_FMT_YUVA444P16LE, ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
-
-    AV_PIX_FMT_VDPAU,        ///< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface
-
-    AV_PIX_FMT_XYZ12LE,      ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
-    AV_PIX_FMT_XYZ12BE,      ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
-    AV_PIX_FMT_NV16,         ///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
-    AV_PIX_FMT_NV20LE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_NV20BE,       ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-
-    AV_PIX_FMT_RGBA64BE,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    AV_PIX_FMT_RGBA64LE,     ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-    AV_PIX_FMT_BGRA64BE,     ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
-    AV_PIX_FMT_BGRA64LE,     ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
-
-    AV_PIX_FMT_YVYU422,   ///< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
-
-    AV_PIX_FMT_YA16BE,       ///< 16 bits gray, 16 bits alpha (big-endian)
-    AV_PIX_FMT_YA16LE,       ///< 16 bits gray, 16 bits alpha (little-endian)
-
-    AV_PIX_FMT_GBRAP,        ///< planar GBRA 4:4:4:4 32bpp
-    AV_PIX_FMT_GBRAP16BE,    ///< planar GBRA 4:4:4:4 64bpp, big-endian
-    AV_PIX_FMT_GBRAP16LE,    ///< planar GBRA 4:4:4:4 64bpp, little-endian
-    (**
-     *  HW acceleration through QSV, data[3] contains a pointer to the
-     *  mfxFrameSurface1 structure.
-     *)
-    AV_PIX_FMT_QSV,
-    (**
-     * HW acceleration though MMAL, data[3] contains a pointer to the
-     * MMAL_BUFFER_HEADER_T structure.
-     *)
-    AV_PIX_FMT_MMAL,
-
-    AV_PIX_FMT_D3D11VA_VLD,  ///< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer
-
-    (**
-     * HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
-     * exactly as for system memory frames.
-     *)
-    AV_PIX_FMT_CUDA,
-
-    AV_PIX_FMT_0RGB,           ///< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
-    AV_PIX_FMT_RGB0,           ///< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
-    AV_PIX_FMT_0BGR,           ///< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
-    AV_PIX_FMT_BGR0,           ///< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined
-
-    AV_PIX_FMT_YUV420P12BE, ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    AV_PIX_FMT_YUV420P12LE, ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    AV_PIX_FMT_YUV420P14BE, ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-    AV_PIX_FMT_YUV420P14LE, ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
-    AV_PIX_FMT_YUV422P12BE, ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    AV_PIX_FMT_YUV422P12LE, ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_YUV422P14BE, ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
-    AV_PIX_FMT_YUV422P14LE, ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
-    AV_PIX_FMT_YUV444P12BE, ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    AV_PIX_FMT_YUV444P12LE, ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    AV_PIX_FMT_YUV444P14BE, ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
-    AV_PIX_FMT_YUV444P14LE, ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
-    AV_PIX_FMT_GBRP12BE,    ///< planar GBR 4:4:4 36bpp, big-endian
-    AV_PIX_FMT_GBRP12LE,    ///< planar GBR 4:4:4 36bpp, little-endian
-    AV_PIX_FMT_GBRP14BE,    ///< planar GBR 4:4:4 42bpp, big-endian
-    AV_PIX_FMT_GBRP14LE,    ///< planar GBR 4:4:4 42bpp, little-endian
-    AV_PIX_FMT_YUVJ411P,    ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range
-
-    AV_PIX_FMT_BAYER_BGGR8,    ///< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples */
-    AV_PIX_FMT_BAYER_RGGB8,    ///< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples */
-    AV_PIX_FMT_BAYER_GBRG8,    ///< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples */
-    AV_PIX_FMT_BAYER_GRBG8,    ///< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples */
-    AV_PIX_FMT_BAYER_BGGR16LE, ///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian */
-    AV_PIX_FMT_BAYER_BGGR16BE, ///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian */
-    AV_PIX_FMT_BAYER_RGGB16LE, ///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian */
-    AV_PIX_FMT_BAYER_RGGB16BE, ///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian */
-    AV_PIX_FMT_BAYER_GBRG16LE, ///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian */
-    AV_PIX_FMT_BAYER_GBRG16BE, ///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian */
-    AV_PIX_FMT_BAYER_GRBG16LE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian */
-    AV_PIX_FMT_BAYER_GRBG16BE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian */
-
-    AV_PIX_FMT_XVMC,           ///< XVideo Motion Acceleration via common packet passing
-
-    AV_PIX_FMT_YUV440P10LE,    ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
-    AV_PIX_FMT_YUV440P10BE,    ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
-    AV_PIX_FMT_YUV440P12LE,    ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
-    AV_PIX_FMT_YUV440P12BE,    ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
-    AV_PIX_FMT_AYUV64LE,    ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
-    AV_PIX_FMT_AYUV64BE,    ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
-
-    AV_PIX_FMT_VIDEOTOOLBOX, ///< hardware decoding through Videotoolbox
-
-    AV_PIX_FMT_P010LE,       ///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian
-    AV_PIX_FMT_P010BE,       ///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian
-
-    AV_PIX_FMT_GBRAP12BE,  ///< planar GBR 4:4:4:4 48bpp, big-endian
-    AV_PIX_FMT_GBRAP12LE,  ///< planar GBR 4:4:4:4 48bpp, little-endian
-
-    AV_PIX_FMT_GBRAP10BE,  ///< planar GBR 4:4:4:4 40bpp, big-endian
-    AV_PIX_FMT_GBRAP10LE,  ///< planar GBR 4:4:4:4 40bpp, little-endian
-
-    AV_PIX_FMT_MEDIACODEC, ///< hardware decoding through MediaCodec
-
-    AV_PIX_FMT_GRAY12BE,   ///<        Y        , 12bpp, big-endian
-    AV_PIX_FMT_GRAY12LE,   ///<        Y        , 12bpp, little-endian
-    AV_PIX_FMT_GRAY10BE,   ///<        Y        , 10bpp, big-endian
-    AV_PIX_FMT_GRAY10LE,   ///<        Y        , 10bpp, little-endian
-
-    AV_PIX_FMT_P016LE, ///< like NV12, with 16bpp per component, little-endian
-    AV_PIX_FMT_P016BE, ///< like NV12, with 16bpp per component, big-endian
-
-    (**
-     * Hardware surfaces for Direct3D11.
-     *
-     * This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
-     * hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
-     *
-     * data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
-     * texture array index of the frame as intptr_t if the ID3D11Texture2D is
-     * an array texture (or always 0 if it's a normal texture).
-     *)
-    AV_PIX_FMT_D3D11,
-
-    AV_PIX_FMT_GRAY9BE,   ///<        Y        , 9bpp, big-endian
-    AV_PIX_FMT_GRAY9LE,   ///<        Y        , 9bpp, little-endian
-
-    AV_PIX_FMT_GBRPF32BE,  ///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian
-    AV_PIX_FMT_GBRPF32LE,  ///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian
-    AV_PIX_FMT_GBRAPF32BE, ///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian
-    AV_PIX_FMT_GBRAPF32LE, ///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian
-
-    (**
-     * DRM-managed buffers exposed through PRIME buffer sharing.
-     *
-     * data[0] points to an AVDRMFrameDescriptor.
-     *)
-    AV_PIX_FMT_DRM_PRIME,
-    (**
-     * Hardware surfaces for OpenCL.
-     *
-     * data[i] contain 2D image objects (typed in C as cl_mem, used
-     * in OpenCL as image2d_t) for each plane of the surface.
-     *)
-    AV_PIX_FMT_OPENCL,
-
-    AV_PIX_FMT_NB        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
-  );
-
-const
-    AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8; ///< alias for AV_PIX_FMT_YA8
-    AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8; ///< alias for AV_PIX_FMT_YA8
-
-{$IFDEF WORDS_BIGENDIAN}
-    AV_PIX_FMT_RGB32   = AV_PIX_FMT_ARGB;
-    AV_PIX_FMT_RGB32_1 = AV_PIX_FMT_RGBA;
-    AV_PIX_FMT_BGR32   = AV_PIX_FMT_ABGR;
-    AV_PIX_FMT_BGR32_1 = AV_PIX_FMT_BGRA;
-    AV_PIX_FMT_0RGB32  = AV_PIX_FMT_0RGB;
-    AV_PIX_FMT_0BGR32  = AV_PIX_FMT_0BGR;
-
-    AV_PIX_FMT_GRAY9   = AV_PIX_FMT_GRAY9BE;
-    AV_PIX_FMT_GRAY10  = AV_PIX_FMT_GRAY10BE;
-    AV_PIX_FMT_GRAY12  = AV_PIX_FMT_GRAY12BE;
-    AV_PIX_FMT_GRAY16  = AV_PIX_FMT_GRAY16BE;
-		AV_PIX_FMT_YA16    = AV_PIX_FMT_YA16BE;
-    AV_PIX_FMT_RGB48   = AV_PIX_FMT_RGB48BE;
-    AV_PIX_FMT_RGB565  = AV_PIX_FMT_RGB565BE;
-    AV_PIX_FMT_RGB555  = AV_PIX_FMT_RGB555BE;
-    AV_PIX_FMT_RGB444  = AV_PIX_FMT_RGB444BE;
-		AV_PIX_FMT_RGBA64  = AV_PIX_FMT_RGBA64BE;
-    AV_PIX_FMT_BGR48   = AV_PIX_FMT_BGR48BE;
-    AV_PIX_FMT_BGR565  = AV_PIX_FMT_BGR565BE;
-    AV_PIX_FMT_BGR555  = AV_PIX_FMT_BGR555BE;
-    AV_PIX_FMT_BGR444  = AV_PIX_FMT_BGR444BE;
-		AV_PIX_FMT_BGRA64  = AV_PIX_FMT_BGRA64BE;
-
-    AV_PIX_FMT_YUV420P9  = AV_PIX_FMT_YUV420P9BE;
-    AV_PIX_FMT_YUV422P9  = AV_PIX_FMT_YUV422P9BE;
-    AV_PIX_FMT_YUV444P9  = AV_PIX_FMT_YUV444P9BE;
-    AV_PIX_FMT_YUV420P10 = AV_PIX_FMT_YUV420P10BE;
-    AV_PIX_FMT_YUV422P10 = AV_PIX_FMT_YUV422P10BE;
-    AV_PIX_FMT_YUV440P10 = AV_PIX_FMT_YUV440P10BE;
-    AV_PIX_FMT_YUV444P10 = AV_PIX_FMT_YUV444P10BE;
-    AV_PIX_FMT_YUV420P12 = AV_PIX_FMT_YUV420P12BE;
-    AV_PIX_FMT_YUV422P12 = AV_PIX_FMT_YUV422P12BE;
-    AV_PIX_FMT_YUV440P12 = AV_PIX_FMT_YUV440P12BE;
-    AV_PIX_FMT_YUV444P12 = AV_PIX_FMT_YUV444P12BE;
-    AV_PIX_FMT_YUV420P14 = AV_PIX_FMT_YUV420P14BE;
-    AV_PIX_FMT_YUV422P14 = AV_PIX_FMT_YUV422P14BE;
-    AV_PIX_FMT_YUV444P14=  AV_PIX_FMT_YUV444P14BE;
-    AV_PIX_FMT_YUV420P16 = AV_PIX_FMT_YUV420P16BE;
-    AV_PIX_FMT_YUV422P16 = AV_PIX_FMT_YUV422P16BE;
-    AV_PIX_FMT_YUV444P16 = AV_PIX_FMT_YUV444P16BE;
-
-    AV_PIX_FMT_GBRP9  = AV_PIX_FMT_GBRP9BE;
-    AV_PIX_FMT_GBRP10 = AV_PIX_FMT_GBRP10BE;
-    AV_PIX_FMT_GBRP12 = AV_PIX_FMT_GBRP12BE;
-    AV_PIX_FMT_GBRP14 = AV_PIX_FMT_GBRP14BE;
-    AV_PIX_FMT_GBRP16 = AV_PIX_FMT_GBRP16BE;
-    AV_PIX_FMT_GBRAP10 = AV_PIX_FMT_GBRAP10BE;
-    AV_PIX_FMT_GBRAP12 = AV_PIX_FMT_GBRAP12BE;
-    AV_PIX_FMT_GBRAP16 = AV_PIX_FMT_GBRAP16BE;
-
-    AV_PIX_FMT_BAYER_BGGR16 = AV_PIX_FMT_BAYER_BGGR16BE;
-    AV_PIX_FMT_BAYER_RGGB16 = AV_PIX_FMT_BAYER_RGGB16BE;
-    AV_PIX_FMT_BAYER_GBRG16 = AV_PIX_FMT_BAYER_GBRG16BE;
-    AV_PIX_FMT_BAYER_GRBG16 = AV_PIX_FMT_BAYER_GRBG16BE;
-
-    AV_PIX_FMT_GBRPF32  = AV_PIX_FMT_GBRPF32BE;
-    AV_PIX_FMT_GBRAPF32 = AV_PIX_FMT_GBRAPF32BE;
-
-    AV_PIX_FMT_YUVA420P9  = AV_PIX_FMT_YUVA420P9BE;
-    AV_PIX_FMT_YUVA422P9  = AV_PIX_FMT_YUVA422P9BE;
-    AV_PIX_FMT_YUVA444P9  = AV_PIX_FMT_YUVA444P9BE;
-    AV_PIX_FMT_YUVA420P10 = AV_PIX_FMT_YUVA420P10BE;
-    AV_PIX_FMT_YUVA422P10 = AV_PIX_FMT_YUVA422P10BE;
-    AV_PIX_FMT_YUVA444P10 = AV_PIX_FMT_YUVA444P10BE;
-    AV_PIX_FMT_YUVA420P16 = AV_PIX_FMT_YUVA420P16BE;
-    AV_PIX_FMT_YUVA422P16 = AV_PIX_FMT_YUVA422P16BE;
-    AV_PIX_FMT_YUVA444P16 = AV_PIX_FMT_YUVA444P16BE;
-
-    AV_PIX_FMT_XYZ12      = AV_PIX_FMT_XYZ12BE;
-    AV_PIX_FMT_NV20       = AV_PIX_FMT_NV20BE;
-    AV_PIX_FMT_AYUV64     = AV_PIX_FMT_AYUV64BE;
-    AV_PIX_FMT_P010       = AV_PIX_FMT_P010BE;
-    AV_PIX_FMT_P016       = AV_PIX_FMT_P016BE;
-
-{$ELSE}
-    AV_PIX_FMT_RGB32   = AV_PIX_FMT_BGRA;
-    AV_PIX_FMT_RGB32_1 = AV_PIX_FMT_ABGR;
-    AV_PIX_FMT_BGR32   = AV_PIX_FMT_RGBA;
-    AV_PIX_FMT_BGR32_1 = AV_PIX_FMT_ARGB;
-    AV_PIX_FMT_0RGB32  = AV_PIX_FMT_BGR0;
-    AV_PIX_FMT_0BGR32  = AV_PIX_FMT_RGB0;
-
-    AV_PIX_FMT_GRAY9   = AV_PIX_FMT_GRAY9LE;
-    AV_PIX_FMT_GRAY10  = AV_PIX_FMT_GRAY10LE;
-    AV_PIX_FMT_GRAY12  = AV_PIX_FMT_GRAY12LE;
-    AV_PIX_FMT_GRAY16  = AV_PIX_FMT_GRAY16LE;
-		AV_PIX_FMT_YA16    = AV_PIX_FMT_YA16LE;
-    AV_PIX_FMT_RGB48   = AV_PIX_FMT_RGB48LE;
-    AV_PIX_FMT_RGB565  = AV_PIX_FMT_RGB565LE;
-    AV_PIX_FMT_RGB555  = AV_PIX_FMT_RGB555LE;
-    AV_PIX_FMT_RGB444  = AV_PIX_FMT_RGB444LE;
-		AV_PIX_FMT_RGBA64  = AV_PIX_FMT_RGBA64LE;
-    AV_PIX_FMT_BGR48   = AV_PIX_FMT_BGR48LE;
-    AV_PIX_FMT_BGR565  = AV_PIX_FMT_BGR565LE;
-    AV_PIX_FMT_BGR555  = AV_PIX_FMT_BGR555LE;
-    AV_PIX_FMT_BGR444  = AV_PIX_FMT_BGR444LE;
-		AV_PIX_FMT_BGRA64  = AV_PIX_FMT_BGRA64LE;
-
-    AV_PIX_FMT_YUV420P9  = AV_PIX_FMT_YUV420P9LE;
-    AV_PIX_FMT_YUV422P9  = AV_PIX_FMT_YUV422P9LE;
-    AV_PIX_FMT_YUV444P9  = AV_PIX_FMT_YUV444P9LE;
-    AV_PIX_FMT_YUV420P10 = AV_PIX_FMT_YUV420P10LE;
-    AV_PIX_FMT_YUV422P10 = AV_PIX_FMT_YUV422P10LE;
-    AV_PIX_FMT_YUV440P10 = AV_PIX_FMT_YUV440P10LE;
-    AV_PIX_FMT_YUV444P10 = AV_PIX_FMT_YUV444P10LE;
-    AV_PIX_FMT_YUV420P12 = AV_PIX_FMT_YUV420P12LE;
-    AV_PIX_FMT_YUV422P12 = AV_PIX_FMT_YUV422P12LE;
-    AV_PIX_FMT_YUV440P12 = AV_PIX_FMT_YUV440P12LE;
-    AV_PIX_FMT_YUV444P12 = AV_PIX_FMT_YUV444P12LE;
-    AV_PIX_FMT_YUV420P14 = AV_PIX_FMT_YUV420P14LE;
-    AV_PIX_FMT_YUV422P14 = AV_PIX_FMT_YUV422P14LE;
-    AV_PIX_FMT_YUV444P14=  AV_PIX_FMT_YUV444P14LE;
-    AV_PIX_FMT_YUV420P16 = AV_PIX_FMT_YUV420P16LE;
-    AV_PIX_FMT_YUV422P16 = AV_PIX_FMT_YUV422P16LE;
-    AV_PIX_FMT_YUV444P16 = AV_PIX_FMT_YUV444P16LE;
-
-    AV_PIX_FMT_GBRP9  = AV_PIX_FMT_GBRP9LE;
-    AV_PIX_FMT_GBRP10 = AV_PIX_FMT_GBRP10LE;
-    AV_PIX_FMT_GBRP12 = AV_PIX_FMT_GBRP12LE;
-    AV_PIX_FMT_GBRP14 = AV_PIX_FMT_GBRP14LE;
-    AV_PIX_FMT_GBRP16 = AV_PIX_FMT_GBRP16LE;
-    AV_PIX_FMT_GBRAP10 = AV_PIX_FMT_GBRAP10LE;
-    AV_PIX_FMT_GBRAP12 = AV_PIX_FMT_GBRAP12LE;
-    AV_PIX_FMT_GBRAP16 = AV_PIX_FMT_GBRAP16LE;
-
-    AV_PIX_FMT_BAYER_BGGR16 = AV_PIX_FMT_BAYER_BGGR16LE;
-    AV_PIX_FMT_BAYER_RGGB16 = AV_PIX_FMT_BAYER_RGGB16LE;
-    AV_PIX_FMT_BAYER_GBRG16 = AV_PIX_FMT_BAYER_GBRG16LE;
-    AV_PIX_FMT_BAYER_GRBG16 = AV_PIX_FMT_BAYER_GRBG16LE;
-
-    AV_PIX_FMT_GBRPF32  = AV_PIX_FMT_GBRPF32LE;
-    AV_PIX_FMT_GBRAPF32 = AV_PIX_FMT_GBRAPF32LE;
-
-    AV_PIX_FMT_YUVA420P9  = AV_PIX_FMT_YUVA420P9LE;
-    AV_PIX_FMT_YUVA422P9  = AV_PIX_FMT_YUVA422P9LE;
-    AV_PIX_FMT_YUVA444P9  = AV_PIX_FMT_YUVA444P9LE;
-    AV_PIX_FMT_YUVA420P10 = AV_PIX_FMT_YUVA420P10LE;
-    AV_PIX_FMT_YUVA422P10 = AV_PIX_FMT_YUVA422P10LE;
-    AV_PIX_FMT_YUVA444P10 = AV_PIX_FMT_YUVA444P10LE;
-    AV_PIX_FMT_YUVA420P16 = AV_PIX_FMT_YUVA420P16LE;
-    AV_PIX_FMT_YUVA422P16 = AV_PIX_FMT_YUVA422P16LE;
-    AV_PIX_FMT_YUVA444P16 = AV_PIX_FMT_YUVA444P16LE;
-
-    AV_PIX_FMT_XYZ12      = AV_PIX_FMT_XYZ12LE;
-    AV_PIX_FMT_NV20       = AV_PIX_FMT_NV20LE;
-    AV_PIX_FMT_AYUV64     = AV_PIX_FMT_AYUV64LE;
-    AV_PIX_FMT_P010       = AV_PIX_FMT_P010LE;
-    AV_PIX_FMT_P016       = AV_PIX_FMT_P016LE;
-{$ENDIF}
-
-type
-(**
-  * Chromaticity coordinates of the source primaries.
-  * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.
-  *)
-  TAVColorPrimaries = (
-    AVCOL_PRI_RESERVED0   = 0,
-    AVCOL_PRI_BT709       = 1, ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
-    AVCOL_PRI_UNSPECIFIED = 2,
-    AVCOL_PRI_RESERVED    = 3,
-    AVCOL_PRI_BT470M      = 4, ///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
-    AVCOL_PRI_BT470BG     = 5, ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
-    AVCOL_PRI_SMPTE170M   = 6, ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
-    AVCOL_PRI_SMPTE240M   = 7, ///< functionally identical to above
-    AVCOL_PRI_FILM        = 8, ///< colour filters using Illuminant C
-    AVCOL_PRI_BT2020      = 9, ///< ITU-R BT2020
-    AVCOL_PRI_SMPTE428    = 10, ///< SMPTE ST 428-1 (CIE 1931 XYZ)
-    AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
-    AVCOL_PRI_SMPTE431    = 11, ///< SMPTE ST 431-2 (2011) / DCI P3
-    AVCOL_PRI_SMPTE432    = 12, ///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3
-    AVCOL_PRI_JEDEC_P22   = 22, ///< JEDEC P22 phosphors
-    AVCOL_PRI_NB                ///< Not part of ABI
-  );
-
-(**
- * Color Transfer Characteristic.
- * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.
- *)
-  TAVColorTransferCharacteristic = (
-    AVCOL_TRC_RESERVED0    = 0,
-    AVCOL_TRC_BT709        = 1,  ///< also ITU-R BT1361
-    AVCOL_TRC_UNSPECIFIED  = 2,
-    AVCOL_TRC_RESERVED     = 3,
-    AVCOL_TRC_GAMMA22      = 4,  ///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
-    AVCOL_TRC_GAMMA28      = 5,  ///< also ITU-R BT470BG
-    AVCOL_TRC_SMPTE170M    = 6,  ///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
-    AVCOL_TRC_SMPTE240M    = 7,
-    AVCOL_TRC_LINEAR       = 8,  ///< "Linear transfer characteristics"
-    AVCOL_TRC_LOG          = 9,  ///< "Logarithmic transfer characteristic (100:1 range)"
-    AVCOL_TRC_LOG_SQRT     = 10, ///< "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
-    AVCOL_TRC_IEC61966_2_4 = 11, ///< IEC 61966-2-4
-    AVCOL_TRC_BT1361_ECG   = 12, ///< ITU-R BT1361 Extended Colour Gamut
-    AVCOL_TRC_IEC61966_2_1 = 13, ///< IEC 61966-2-1 (sRGB or sYCC)
-    AVCOL_TRC_BT2020_10    = 14, ///< ITU-R BT2020 for 10-bit system
-    AVCOL_TRC_BT2020_12    = 15, ///< ITU-R BT2020 for 12-bit system
-    AVCOL_TRC_SMPTE2084    = 16, ///< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
-    AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
-    AVCOL_TRC_SMPTE428     = 17, ///< SMPTE ST 428-1
-    AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
-    AVCOL_TRC_ARIB_STD_B67 = 18, ///< ARIB STD-B67, known as "Hybrid log-gamma"
-    AVCOL_TRC_NB                 ///< Not part of ABI
-  );
-
-(**
- * YUV colorspace type.
- * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.
- *)
-  TAVColorSpace = (
-    AVCOL_SPC_RGB         = 0,  ///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)
-    AVCOL_SPC_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
-    AVCOL_SPC_UNSPECIFIED = 2,
-    AVCOL_SPC_RESERVED    = 3,
-    AVCOL_SPC_FCC         = 4,  ///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
-    AVCOL_SPC_BT470BG     = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
-    AVCOL_SPC_SMPTE170M   = 6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
-    AVCOL_SPC_SMPTE240M   = 7,  ///< functionally identical to above
-    AVCOL_SPC_YCGCO       = 8,  ///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
-    AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
-    AVCOL_SPC_BT2020_NCL  = 9,  ///< ITU-R BT2020 non-constant luminance system
-    AVCOL_SPC_BT2020_CL   = 10, ///< ITU-R BT2020 constant luminance system
-    AVCOL_SPC_SMPTE2085   = 11, ///< SMPTE 2085, Y'D'zD'x
-    AVCOL_SPC_CHROMA_DERIVED_NCL = 12, ///< Chromaticity-derived non-constant luminance system
-    AVCOL_SPC_CHROMA_DERIVED_CL = 13, ///< Chromaticity-derived constant luminance system
-    AVCOL_SPC_ICTCP       = 14, ///< ITU-R BT.2100-0, ICtCp
-    AVCOL_SPC_NB                ///< Not part of ABI
-  );
-
-type
-(**
- * MPEG vs JPEG YUV range.
- *)
-  TAVColorRange = (
-    AVCOL_RANGE_UNSPECIFIED = 0,
-    AVCOL_RANGE_MPEG        = 1, ///< the normal 219*2^(n-8) "MPEG" YUV ranges
-    AVCOL_RANGE_JPEG        = 2, ///< the normal     2^n-1   "JPEG" YUV ranges
-    AVCOL_RANGE_NB               ///< Not part of ABI
-  );
-
-(**
- * Location of chroma samples.
- *
- * Illustration showing the location of the first (top left) chroma sample of the
- * image, the left shows only luma, the right
- * shows the location of the chroma sample, the 2 could be imagined to overlay
- * each other but are drawn separately due to limitations of ASCII
- *
- *                1st 2nd       1st 2nd horizontal luma sample positions
- *                 v   v         v   v
- *                 ______        ______
- *1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
- *                |             |1 2           1-6 are possible chroma positions
- *2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
- *)
-  TAVChromaLocation = (
-    AVCHROMA_LOC_UNSPECIFIED = 0,
-    AVCHROMA_LOC_LEFT        = 1, ///< MPEG-2/4 4:2:0, H.264 default for 4:2:0
-    AVCHROMA_LOC_CENTER      = 2, ///< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
-    AVCHROMA_LOC_TOPLEFT     = 3, ///< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
-    AVCHROMA_LOC_TOP         = 4,
-    AVCHROMA_LOC_BOTTOMLEFT  = 5,
-    AVCHROMA_LOC_BOTTOM      = 6,
-    AVCHROMA_LOC_NB               ///< Not part of ABI
-  );
diff --git a/src/lib/ffmpeg-4.0/libavutil/samplefmt.pas b/src/lib/ffmpeg-4.0/libavutil/samplefmt.pas
deleted file mode 100644
index 85b113057..000000000
--- a/src/lib/ffmpeg-4.0/libavutil/samplefmt.pas
+++ /dev/null
@@ -1,287 +0,0 @@
-(*
- * SampleFormat
- * copyright (c) 2011 Karl-Michael Schindler <karl-michael.schindler@web.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of the Pascal port of ffmpeg.
- *
- * Conversion of libavutil/samplefmt.h
- * avutil version 54.7.100
- *
- *)
-
-type
-(**
- * @addtogroup lavu_audio
- * @
- *
- * @defgroup lavu_sampfmts Audio sample formats
- *
- * Audio sample format enumeration and related convenience functions.
- * @
- *)
-
-(**
- * Audio sample formats
- *
- * - The data described by the sample format is always in native-endian order.
- *   Sample values can be expressed by native C types, hence the lack of a signed
- *   24-bit sample format even though it is a common raw audio data format.
- *
- * - The floating-point formats are based on full volume being in the range
- *   [-1.0, 1.0]. Any values outside this range are beyond full volume level.
- *
- * - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
- *   (such as AVFrame in libavcodec) is as follows:
- *
- * @par
- * For planar sample formats, each audio channel is in a separate data plane,
- * and linesize is the buffer size, in bytes, for a single plane. All data
- * planes must be the same size. For packed sample formats, only the first data
- * plane is used, and samples for each channel are interleaved. In this case,
- * linesize is the buffer size, in bytes, for the 1 plane.
- *
- *)
-  TAVSampleFormat = (
-    AV_SAMPLE_FMT_NONE = -1,
-    AV_SAMPLE_FMT_U8,          ///< unsigned 8 bits
-    AV_SAMPLE_FMT_S16,         ///< signed 16 bits
-    AV_SAMPLE_FMT_S32,         ///< signed 32 bits
-    AV_SAMPLE_FMT_FLT,         ///< float
-    AV_SAMPLE_FMT_DBL,         ///< double
-
-    AV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar
-    AV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar
-    AV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar
-    AV_SAMPLE_FMT_FLTP,        ///< float, planar
-    AV_SAMPLE_FMT_DBLP,        ///< double, planar
-    AV_SAMPLE_FMT_S64,         ///< signed 64 bits
-    AV_SAMPLE_FMT_S64P,        ///< signed 64 bits, planar
-
-    AV_SAMPLE_FMT_NB           ///< Number of sample formats. DO NOT USE if linking dynamically
-  );
-  TAVSampleFormatArray = array [0 .. MaxInt div SizeOf(TAVSampleFormat) - 1] of TAVSampleFormat;
-  PAVSampleFormatArray = ^TAVSampleFormatArray;
-
-(**
- * Return the name of sample_fmt, or NULL if sample_fmt is not
- * recognized.
- *)
-function av_get_sample_fmt_name(sample_fmt: TAVSampleFormat): {const} PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
- * on error.
- *)
-function av_get_sample_fmt(name: {const} PAnsiChar): TAVSampleFormat;
-  cdecl; external av__util;
-
-(**
- * Return the planar<->packed alternative form of the given sample format, or
- * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
- * requested planar/packed format, the format returned is the same as the
- * input.
- *)
-function av_get_alt_sample_fmt(sample_fmt: TAVSampleFormat; planar: cint): TAVSampleFormat;
-  cdecl; external av__util;
-
-(**
- * Get the packed alternative form of the given sample format.
- *
- * If the passed sample_fmt is already in packed format, the format returned is
- * the same as the input.
- *
- * @return  the packed alternative form of the given sample format or
-            AV_SAMPLE_FMT_NONE on error.
- *)
-function av_get_packed_sample_fmt(sample_fmt: TAVSampleFormat): TAVSampleFormat;
-  cdecl; external av__util;
-
-(**
- * Get the planar alternative form of the given sample format.
- *
- * If the passed sample_fmt is already in planar format, the format returned is
- * the same as the input.
- *
- * @return  the planar alternative form of the given sample format or
-            AV_SAMPLE_FMT_NONE on error.
- *)
-function av_get_planar_sample_fmt(sample_fmt: TAVSampleFormat): TAVSampleFormat;
-  cdecl; external av__util;
-
-(**
- * Generate a string corresponding to the sample format with
- * sample_fmt, or a header if sample_fmt is negative.
- *
- * @param buf the buffer where to write the string
- * @param buf_size the size of buf
- * @param sample_fmt the number of the sample format to print the
- * corresponding info string, or a negative value to print the
- * corresponding header.
- * @return the pointer to the filled buffer or NULL if sample_fmt is
- * unknown or in case of other errors
- *)
-function av_get_sample_fmt_string(buf: PAnsiChar; buf_size: cint; sample_fmt: TAVSampleFormat): PAnsiChar;
-  cdecl; external av__util;
-
-(**
- * Return number of bytes per sample.
- *
- * @param sample_fmt the sample format
- * @return number of bytes per sample or zero if unknown for the given
- * sample format
- *)
-function av_get_bytes_per_sample(sample_fmt: TAVSampleFormat): cint;
-  cdecl; external av__util;
-
-type
-  OctArrayOfPcuint8 = array[0..7] of Pcuint8;
-  OctArrayOfcint    = array[0..7] of cint;
-
-(**
- * Check if the sample format is planar.
- *
- * @param sample_fmt the sample format to inspect
- * @return 1 if the sample format is planar, 0 if it is interleaved
- *)
-function av_sample_fmt_is_planar(sample_fmt: TAVSampleFormat): cint;
-  cdecl; external av__util;
-
-(**
- * Get the required buffer size for the given audio parameters.
- *
- * @param[out] linesize calculated linesize, may be NULL
- * @param nb_channels   the number of channels
- * @param nb_samples    the number of samples in a single channel
- * @param sample_fmt    the sample format
- * @param align         buffer size alignment (0 = default, 1 = no alignment)
- * @return              required buffer size, or negative error code on failure
- *)
-function av_samples_get_buffer_size(linesize: Pcint; nb_channels: cint; nb_samples: cint;
-                                    sample_fmt: TAVSampleFormat; align: cint): cint;
-  cdecl; external av__util;
-
-(**
- * @
- *
- * @defgroup lavu_sampmanip Samples manipulation
- *
- * Functions that manipulate audio samples
- * @
- *)
-
-(**
- * Fill plane data pointers and linesize for samples with sample
- * format sample_fmt.
- *
- * The audio_data array is filled with the pointers to the samples data planes:
- * for planar, set the start point of each channel's data within the buffer,
- * for packed, set the start point of the entire buffer only.
- *
- * The value pointed to by linesize is set to the aligned size of each
- * channel's data buffer for planar layout, or to the aligned size of the
- * buffer for all channels for packed layout.
- *
- * The buffer in buf must be big enough to contain all the samples
- * (use av_samples_get_buffer_size() to compute its minimum size),
- * otherwise the audio_data pointers will point to invalid data.
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param[out] audio_data  array to be filled with the pointer for each channel
- * @param[out] linesize    calculated linesize, may be NULL
- * @param buf              the pointer to a buffer containing the samples
- * @param nb_channels      the number of channels
- * @param nb_samples       the number of samples in a single channel
- * @param sample_fmt       the sample format
- * @param align            buffer size alignment (0 = default, 1 = no alignment)
- * @return                 >=0 on success or a negative error code on failure
- * @todo return minimum size in bytes required for the buffer in case
- * of success at the next bump
- *)
-function av_samples_fill_arrays(var audio_data: Pcuint8; linesize: Pcint;
-                                buf: Pcuint8;
-				nb_channels: cint; nb_samples: cint; 
-                                sample_fmt: TAVSampleFormat; align: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Allocate a samples buffer for nb_samples samples, and fill data pointers and
- * linesize accordingly.
- * The allocated samples buffer can be freed by using av_freep(&audio_data[0])
- *
- * @see enum AVSampleFormat
- * The documentation for AVSampleFormat describes the data layout.
- *
- * @param[out] audio_data  array to be filled with the pointer for each channel
- * @param[out] linesize    aligned size for audio buffer(s), may be NULL
- * @param nb_channels      number of audio channels
- * @param nb_samples       number of samples per channel
- * @param align            buffer size alignment (0 = default, 1 = no alignment)
- * @return                 >=0 on success or a negative error code on failure
- * @todo return the size of the allocated buffer in case of success at the next bump
- * @see av_samples_fill_arrays()
- * @see av_samples_alloc_array_and_samples()
- *)
-function av_samples_alloc(var audio_data: Pcuint8; linesize: Pcint;
-                          nb_channels: cint; nb_samples: cint;
-			  sample_fmt: TAVSampleFormat; align: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Allocate a data pointers array, samples buffer for nb_samples
- * samples, and fill data pointers and linesize accordingly.
- *
- * This is the same as av_samples_alloc(), but also allocates the data
- * pointers array.
- *
- * @see av_samples_alloc()
- *)
-function av_samples_alloc_array_and_samples(var audio_data: Pcuint8; linesize: Pcint;
-                                            nb_channels: cint; nb_samples: cint;
-			                    sample_fmt: TAVSampleFormat; align: cint): cint;
-  cdecl; external av__util;
-
-(**
- * Copy samples from src to dst.
- *
- * @param dst destination array of pointers to data planes
- * @param src source array of pointers to data planes
- * @param dst_offset offset in samples at which the data will be written to dst
- * @param src_offset offset in samples at which the data will be read from src
- * @param nb_samples number of samples to be copied
- * @param nb_channels number of audio channels
- * @param sample_fmt audio sample format
- *)
-function av_samples_copy(var dst: Pcuint8; src: {const} Pcuint8; dst_offset: cint;
-                         src_offset: cint; nb_samples: cint; nb_channels: cint;
-                         sample_fmt: TAVSampleFormat): cint;
-  cdecl; external av__util;
-
-(**
- * Fill an audio buffer with silence.
- *
- * @param audio_data  array of pointers to data planes
- * @param offset      offset in samples at which to start filling
- * @param nb_samples  number of samples to fill
- * @param nb_channels number of audio channels
- * @param sample_fmt  audio sample format
- *)
-function av_samples_set_silence(var audio_data: Pcuint8; offset: cint; nb_samples: cint;
-                                nb_channels: cint; sample_fmt: TAVSampleFormat): cint;
-  cdecl; external av__util;
diff --git a/src/lib/ffmpeg-4.0/rational.pas b/src/lib/ffmpeg-4.0/rational.pas
index d7fcb5b2a..f439dfa43 100644
--- a/src/lib/ffmpeg-4.0/rational.pas
+++ b/src/lib/ffmpeg-4.0/rational.pas
@@ -1,32 +1,3 @@
-(*
- * rational numbers
- * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of libavutil/rational.h
- * avutil version 54.7.100
- *
- *)
-
 unit rational;
 
 {$IFDEF FPC}
@@ -37,234 +8,25 @@
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I switches.inc}
-
 interface
 
 uses
-  ctypes,
-  UConfig;
-
-(**
- * @addtogroup lavu_math
- * @{
- *)
-
+  ctypes;
 type
-(**
- * Rational number (pair of numerator and denominator).
- *)
-  PAVRational = ^TAVRational;
   TAVRational = record
-    num: cint; ///< Numerator
-    den: cint; ///< Denominator
+    num: csint; 
+    den: csint;
   end;
-
-  TAVRationalArray = array[0 .. (MaxInt div SizeOf(TAVRational))-1] of TAVRational;
-  PAVRationalArray = ^TAVRationalArray;
-
-(**
- * Create an AVRational.
- *
- * Useful for compilers that do not support compound literals.
- *
- * @note The return value is not reduced.
- * @see av_reduce()
- */
-static inline AVRational av_make_q(int num, int den)
-{
-      AVRational r = { num, den };
-      return r;
-}
-
-/**)  
-  
-(**
- * Create an AVRational.
- *
- * Useful for compilers that do not support compound literals.
- *
- * @note The return value is not reduced.
- * @see av_reduce()
- *)
-function av_make_q(num, den: cint): TAVRational; {$IFDEF HasInline}inline;{$ENDIF}
-  
-(**
- * Compare two rationals.
- *
- * @param a First rational
- * @param b Second rational
- *
- * @return One of the following values:
- *         - 0 if `a == b`
- *         - 1 if `a > b`
- *         - -1 if `a < b`
- *         - `INT_MIN` if one of the values is of the form `0 / 0`
- *)
-function av_cmp_q(a: TAVRational; b: TAVRational): cint; {$IFDEF HasInline}inline;{$ENDIF}
-
-(**
- * Convert an AVRational to a `double`.
- * @param a AVRational to convert
- * @return `a` in floating-point form
- * @see av_d2q()
- *)
 function av_q2d(a: TAVRational): cdouble; {$IFDEF HasInline}inline;{$ENDIF}
-
-(**
- * Reduce a fraction.
- *
- * This is useful for framerate calculations.
- *
- * @param[out] dst_num Destination numerator
- * @param[out] dst_den Destination denominator
- * @param[in]      num Source numerator
- * @param[in]      den Source denominator
- * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
- * @return 1 if the operation is exact, 0 otherwise
- *)
-function av_reduce(dst_num: PCint; dst_den: PCint; num: cint64; den: cint64; max: cint64): cint;
-  cdecl; external av__util;
-
-(**
- * Multiply two rationals.
- * @param b First rational
- * @param c Second rational
- * @return b*c
- *)
-function av_mul_q(b: TAVRational; c: TAVRational): TAVRational;
-  cdecl; external av__util; {av_const}
-
-(**
- * Divide one rational by another.
- * @param b First rational
- * @param c Second rational
- * @return b/c
- *)
-function av_div_q(b: TAVRational; c: TAVRational): TAVRational;
-  cdecl; external av__util; {av_const}
-
-(**
- * Add two rationals.
- * @param b First rational
- * @param c Second rational
- * @return b+c
- *)
-function av_add_q(b: TAVRational; c: TAVRational): TAVRational;
-  cdecl; external av__util; {av_const}
-
-(**
- * Subtract one rational from another.
- * @param b First rational
- * @param c Second rational
- * @return b-c
- *)
-function av_sub_q(b: TAVRational; c: TAVRational): TAVRational;
-  cdecl; external av__util; {av_const}
-
-(**
- * Invert a rational.
- * @param q value
- * @return 1 / q
- *)
 function av_inv_q(q: TAVRational): TAVRational; {$IFDEF HasInline}inline;{$ENDIF}
-
-(**
- * Convert a double precision floating point number to a rational.
- *
- * In case of infinity, the returned value is expressed as `{1, 0}` or
- * `{-1, 0}` depending on the sign.
- *
- * @param d   `double` to convert
- * @param max Maximum allowed numerator and denominator
- * @return `d` in AVRational form
- * @see av_q2d()
- *)
-function av_d2q(d: cdouble; max: cint): TAVRational;
-  cdecl; external av__util; {av_const}
-
-(**
- * Find which of the two rationals is closer to another rational.
- *
- * @param q     Rational to be compared against
- * @param q1,q2 Rationals to be tested
- * @return One of the following values:
- *         - 1 if `q1` is nearer to `q` than `q2`
- *         - -1 if `q2` is nearer to `q` than `q1`
- *         - 0 if they have the same distance
- *)
-function av_nearer_q(q, q1, q2: TAVRational): cint;
-  cdecl; external av__util;
-
-(**
- * Find the value in a list of rationals nearest a given reference rational.
- *
- * @param q      Reference rational
- * @param q_list Array of rationals terminated by `{0, 0}`
- * @return Index of the nearest value found in the array
- *)
-function av_find_nearest_q_idx(q: TAVRational; q_list: {const} PAVRationalArray): cint;
-  cdecl; external av__util;
-
-(**
- * Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
- * format.
- *
- * @param q Rational to be converted
- * @return Equivalent floating-point value, expressed as an unsigned 32-bit
- *         integer.
- * @note The returned value is platform-indepedant.
- *)
-function av_q2intfloat(q: TAVRational): cuint32;
-  cdecl; external av__util;
-
 implementation
-
-function av_cmp_q (a: TAVRational; b: TAVRational): cint; {$IFDEF HasInline}inline;{$ENDIF}
-var
-  tmp: cint64;
-begin
-  tmp := a.num * cint64(b.den) - b.num * cint64(a.den);
-
-{ old version
-  if (tmp <> 0) then
-    Result := (tmp shr 63) or 1
-  else
-    Result := 0;
-}
-{ C original:
-    if(tmp) return ((tmp ^ a.den ^ b.den)>>63)|1;
-    else if(b.den && a.den) return 0;
-    else if(a.num && b.num) return (a.num>>31) - (b.num>>31);
-    else                    return INT_MIN;
-}
-
-  if tmp <> 0 then
-    Result := ((tmp xor a.den xor b.den) shr 63) or 1
-  else if (b.den and a.den) <> 0 then
-    Result := 0
-  else if (a.num and b.num) <> 0 then
-    Result := (a.num shr 31) - (b.num shr 31)
-  else
-    Result := low(cint);
-
-end;
-
 function av_q2d(a: TAVRational): cdouble; {$IFDEF HasInline}inline;{$ENDIF}
 begin
-  Result := a.num / a.den;
+  av_q2d := a.num / a.den;
 end;
-
 function av_inv_q(q: TAVRational): TAVRational; {$IFDEF HasInline}inline;{$ENDIF}
 begin
-  Result.num := q.den;
-  Result.den := q.num;
+  av_inv_q.num := q.den;
+  av_inv_q.den := q.num;
 end;
-
-function av_make_q(num, den: cint): TAVRational; {$IFDEF HasInline}inline;{$ENDIF}
-begin
-  Result.num := num;
-  Result.den := den;
-end;
-
 end.
diff --git a/src/lib/ffmpeg-4.0/swresample.pas b/src/lib/ffmpeg-4.0/swresample.pas
index 87d30a9f1..49f20d815 100644
--- a/src/lib/ffmpeg-4.0/swresample.pas
+++ b/src/lib/ffmpeg-4.0/swresample.pas
@@ -1,34 +1,3 @@
-(*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * This is a part of Pascal porting of ffmpeg.
- * - Originally by Victor Zinetz for Delphi and Free Pascal on Windows.
- * - For Mac OS X, some modifications were made by The Creative CAT, denoted as CAT
- *   in the source codes.
- * - Changes and updates by the UltraStar Deluxe Team
- *
- * Conversion of
- *
- * libswresample/swresample.h:
- * version: 0.18.100
- *
- *)
-
-
 unit swresample;
 
 {$IFDEF FPC}
@@ -40,58 +9,28 @@
 {$ENDIF}
 
 {$IFDEF DARWIN}
-  {$linklib swresample}
+  {$linklib libswresample}
 {$ENDIF}
 
 interface
 
 uses
-    ctypes,
-    avutil,
-    rational,
-    {$IFDEF UNIX}
-    BaseUnix,
-    {$ENDIF}
-    UConfig;
+  ctypes,
+  avutil,
+  UConfig;
 
 const
-  (*
-   * IMPORTANT: The official FFmpeg C headers change very quickly. Often some
-   * of the data structures are changed so that they become incompatible with
-   * older header files. The Pascal headers have to be adjusted to those changes,
-   * otherwise the application might crash randomly or strange bugs (not
-   * necessarily related to video or audio due to buffer overflows etc.) might
-   * occur.
-   *
-   * In the past users reported problems with USDX that took hours to fix and
-   * the problem was an unsupported version of FFmpeg. So we decided to disable
-   * support for future versions of FFmpeg until the headers are revised by us
-   * for that version as they otherwise most probably will break USDX.
-   *
-   * If the headers do not yet support your FFmpeg version you may want to
-   * adjust the max. version numbers manually but please note: it may work but
-   * in many cases it does not. The USDX team does NOT PROVIDE ANY SUPPORT
-   * for the game if the MAX. VERSION WAS CHANGED.
-   *
-   * The only safe way to support new versions of FFmpeg is to add the changes
-   * of the FFmpeg git repository C headers to the Pascal headers.
-   * You can accelerate this process by posting a patch with the git changes
-   * translated to Pascal to our bug tracker (please join our IRC chat before
-   * you start working on it). Simply adjusting the max. versions is NOT a valid
-   * fix.
-   *)
-
   (* Supported version by this header *)
   LIBSWRESAMPLE_MAX_VERSION_MAJOR   = 3;
-  LIBSWRESAMPLE_MAX_VERSION_MINOR   = 5;
+  LIBSWRESAMPLE_MAX_VERSION_MINOR   = 9;
   LIBSWRESAMPLE_MAX_VERSION_RELEASE = 100;
   LIBSWRESAMPLE_MAX_VERSION = (LIBSWRESAMPLE_MAX_VERSION_MAJOR * VERSION_MAJOR) +
                            (LIBSWRESAMPLE_MAX_VERSION_MINOR * VERSION_MINOR) +
                            (LIBSWRESAMPLE_MAX_VERSION_RELEASE * VERSION_RELEASE);
 
   (* Min. supported version by this header *)
-  LIBSWRESAMPLE_MIN_VERSION_MAJOR   = 3;
-  LIBSWRESAMPLE_MIN_VERSION_MINOR   = 1;
+  LIBSWRESAMPLE_MIN_VERSION_MAJOR   = 0;
+  LIBSWRESAMPLE_MIN_VERSION_MINOR   = 15;
   LIBSWRESAMPLE_MIN_VERSION_RELEASE = 100;
   LIBSWRESAMPLE_MIN_VERSION = (LIBSWRESAMPLE_MIN_VERSION_MAJOR * VERSION_MAJOR) +
                             (LIBSWRESAMPLE_MIN_VERSION_MINOR * VERSION_MINOR) +
@@ -106,362 +45,17 @@ interface
 {$IF (LIBSWRESAMPLE_VERSION > LIBSWRESAMPLE_MAX_VERSION)}
   {$MESSAGE Error 'Linked version of libswresample is not yet supported!'}
 {$IFEND}
-  
-{$IF LIBSWRESAMPLE_VERSION_MAJOR < 1}
-  SWR_CH_MAX = 32;  (* < Maximum number of channels *)
-{$ENDIF}
-  SWR_FLAG_RESAMPLE = 1; (* < Force resampling even if equal sample rate *)
 
 type
-(** Dithering algorithms *)
-  TSwrDitherType = (
-    SWR_DITHER_NONE = 0,
-    SWR_DITHER_RECTANGULAR,
-    SWR_DITHER_TRIANGULAR,
-    SWR_DITHER_TRIANGULAR_HIGHPASS,
-
-    SWR_DITHER_NS = 64,         (* < not part of API/ABI *)
-    SWR_DITHER_NS_LIPSHITZ,
-    SWR_DITHER_NS_F_WEIGHTED,
-    SWR_DITHER_NS_MODIFIED_E_WEIGHTED,
-    SWR_DITHER_NS_IMPROVED_E_WEIGHTED,
-    SWR_DITHER_NS_SHIBATA,
-    SWR_DITHER_NS_LOW_SHIBATA,
-    SWR_DITHER_NS_HIGH_SHIBATA,
-    SWR_DITHER_NB               (* < not part of API/ABI *)
-  );
-
-(** Resampling Engines *)
-  TSwrEngine = (
-    SWR_ENGINE_SWR,             (* < SW Resampler *)
-    SWR_ENGINE_SOXR,            (* < SoX Resampler *)
-    SWR_ENGINE_NB               (* < not part of API/ABI *)
-  );
-
-(** Resampling Filter Types *)
-  TSwrFilterType = (
-    SWR_FILTER_TYPE_CUBIC,              (* < Cubic *)
-    SWR_FILTER_TYPE_BLACKMAN_NUTTALL,   (* < Blackman Nuttall windowed sinc *)
-    SWR_FILTER_TYPE_KAISER              (* < Kaiser windowed sinc *)
-  );
-
-(**
- * The libswresample context. Unlike libavcodec and libavformat, this structure
- * is opaque. This means that if you would like to set options, you must use
- * the @ref avoptions API and cannot directly set values to members of the
- * structure.
- *)
-  PPSwrContext= ^PSwrContext;
   PSwrContext = ^TSwrContext;
+  PPSwrContext = ^PSwrContext;
   TSwrContext = record
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-{$INCLUDE libavcodec/audioconvert.pas}
-
-(**
- * Get the AVClass for swrContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function swr_get_class(): PAVClass;
-  cdecl; external sw__resample;
-
-(**
- * Allocate SwrContext.
- *
- * If you use this function you will need to set the parameters (manually or
- * with swr_alloc_set_opts()) before calling swr_init().
- *
- * @see swr_alloc_set_opts(), swr_init(), swr_free()
- * @return NULL on error, allocated context otherwise
- *)
-function swr_alloc(): PSwrContext;
-  cdecl; external sw__resample;
-
-(**
- * Initialize context after user parameters have been set.
- *
- * @see av_opt_set_int()
- * @see av_opt_set_dict()
- *
- * @param[in,out]   s Swr context to initialize
- * @return AVERROR error code in case of failure.
- *)
-function swr_init(s: PSwrContext): cint;
-  cdecl; external sw__resample;
-
-(**
- * Check whether an swr context has been initialized or not.
- *
- * @param[in]       s Swr context to check
- * @see swr_init()
- * @return positive if it has been initialized, 0 if not initialized
- *)
-function swr_is_initialized(s: PSwrContext): cint;
-  cdecl; external sw__resample;
-  
-(**
- * Allocate SwrContext if needed and set/reset common parameters.
- *
- * This function does not require s to be allocated with swr_alloc(). On the
- * other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters
- * on the allocated context.
- *
- * @param s               existing Swr context if available, or NULL if not
- * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_* )
- * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_* ).
- * @param out_sample_rate output sample rate (frequency in Hz)
- * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_* )
- * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_* ).
- * @param in_sample_rate  input sample rate (frequency in Hz)
- * @param log_offset      logging level offset
- * @param log_ctx         parent logging context, can be NULL
- *
- * @see swr_init(), swr_free()
- * @return NULL on error, allocated context otherwise
- *)
-function swr_alloc_set_opts(s: PSwrContext;
-                            out_ch_layout: cint64; out_sample_fmt: TAVSampleFormat; out_sample_rate: cint;
-                            in_ch_layout:  cint64; in_sample_fmt:  TAVSampleFormat; in_sample_rate:  cint;
-                            log_offset: cint; log_ctx: pointer): PSwrContext;
-  cdecl; external sw__resample;
-
-(**
- * Free the given SwrContext and set the pointer to NULL.
- *
- * @param[in] s a pointer to a pointer to Swr context
- *)
-procedure swr_free(s: PPSwrContext);
-  cdecl; external sw__resample;
-
-(**
- * Closes the context so that swr_is_initialized() returns 0.
- *
- * The context can be brought back to life by running swr_init(),
- * swr_init() can also be used without swr_close().
- * This function is mainly provided for simplifying the usecase
- * where one tries to support libavresample and libswresample.
- *
- * @param[in,out] s Swr context to be closed
- *)
-procedure swr_close(s: PSwrContext);
-  cdecl; external sw__resample;
-
-(**
- * Convert audio.
- *
- * in and in_count can be set to 0 to flush the last few samples out at the
- * end.
- *
- * If more input is provided than output space, then the input will be buffered.
- * You can avoid this buffering by using swr_get_out_samples() to retrieve an
- * upper bound on the required number of output samples for the given number of
- * input samples. Conversion will run directly without copying whenever possible.
- *
- * @param s         allocated Swr context, with parameters set
- * @param out       output buffers, only the first one need be set in case of packed audio
- * @param out_count amount of space available for output in samples per channel
- * @param in        input buffers, only the first one need to be set in case of packed audio
- * @param in_count  number of input samples available in one channel
- *
- * @return number of samples output per channel, negative value on error
- *)
-function swr_convert(s: PSwrContext; var out_: PByte; out_count: cint;
-                     var in_: {const} PByte; in_count: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Convert the next timestamp from input to output
- * timestamps are in 1/(in_sample_rate * out_sample_rate) units.
- *
- * @note There are 2 slightly differently behaving modes.
- *       First is when automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
- *              in this case timestamps will be passed through with delays compensated
- *       Second is when automatic timestamp compensation is used, (min_compensation < FLT_MAX)
- *              in this case the output timestamps will match output sample numbers
- *
- * @param pts   timestamp for the next input sample, INT64_MIN if unknown
- * @return the output timestamp for the next output sample
- *)
-function swr_next_pts(s: PSwrContext; pts: cint64): cint64;
-  cdecl; external sw__resample;
-
-(**
- * Activate resampling compensation ("soft" compensation). This function is
- * internally called when needed in swr_next_pts().
- *
- * @param[in,out] s             allocated Swr context. If it is not initialized,
- *                              or SWR_FLAG_RESAMPLE is not set, swr_init() is
- *                              called with the flag set.
- * @param[in]     sample_delta  delta in PTS per sample
- * @param[in]     compensation_distance number of samples to compensate for
- * @return    >= 0 on success, AVERROR error codes if:
- *            @li @c s is NULL,
- *            @li @c compensation_distance is less than 0,
- *            @li @c compensation_distance is 0 but sample_delta is not,
- *            @li compensation unsupported by resampler, or
- *            @li swr_init() fails when called.
- *)
-function swr_set_compensation(s: PSwrContext; sample_delta: cint; compensation_distance: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Set a customized input channel mapping.
- *
- * @param[in,out] s           allocated Swr context, not yet initialized
- * @param[in]     channel_map customized input channel mapping (array of channel
- *                            indexes, -1 for a muted channel)
- * @return >= 0 on success, or AVERROR error code in case of failure.
- *)
-function swr_set_channel_mapping(s: PSwrContext; {const} channel_map: pcint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Generate a channel mixing matrix.
- *
- * This function is the one used internally by libswresample for building the
- * default mixing matrix. It is made public just as a utility function for
- * building custom matrices.
- *
- * @param in_layout           input channel layout
- * @param out_layout          output channel layout
- * @param center_mix_level    mix level for the center channel
- * @param surround_mix_level  mix level for the surround channel(s)
- * @param lfe_mix_level       mix level for the low-frequency effects channel
- * @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent
- *                            overflow. if INT_MAX, coefficients will not be
- *                            normalized.
- * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
- *                            the weight of input channel i in output channel o.
- * @param stride              distance between adjacent input channels in the
- *                            matrix array
- * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
- * @param log_ctx             parent logging context, can be NULL
- * @return                    0 on success, negative AVERROR code on failure
- *)
-function swr_build_matrix(in_layout: Pcuint64; out_layout: Pcuint64;
-                     center_mix_level: cdouble; surround_mix_level: cdouble;
-                     lfe_mix_level: cdouble; rematrix_maxval: cdouble;
-                     rematrix_volume: cdouble; matrix: Pcdouble;
-                     stride: cint; matrix_encoding: TAVMatrixEncoding;
-                     log_ctx: pointer): cint;
-  cdecl; external sw__resample;
-
-(**
- * Set a customized remix matrix.
- *
- * @param s       allocated Swr context, not yet initialized
- * @param matrix  remix coefficients; matrix[i + stride * o] is
- *                the weight of input channel i in output channel o
- * @param stride  offset between lines of the matrix
- * @return  >= 0 on success, or AVERROR error code in case of failure.
- *)
-function swr_set_matrix(s: PSwrContext; {const} matrix: pcdouble; stride: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Drops the specified number of output samples.
- *
- * This function, along with swr_inject_silence(), is called by swr_next_pts()
- * if needed for "hard" compensation.
- *
- * @param s     allocated Swr context
- * @param count number of samples to be dropped
- *
- * @return >= 0 on success, or a negative AVERROR code on failure
- *)
-function swr_drop_output(s: PSwrContext; count: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Injects the specified number of silence samples.
- *
- * This function, along with swr_drop_output(), is called by swr_next_pts()
- * if needed for "hard" compensation.
- *
- * @param s     allocated Swr context
- * @param count number of samples to be dropped
- *
- * @return >= 0 on success, or a negative AVERROR code on failure
- *)
-function swr_inject_silence(s: PSwrContext; count: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Gets the delay the next input sample will experience relative to the next output sample.
- *
- * Swresample can buffer data if more input has been provided than available
- * output space, also converting between sample rates needs a delay.
- * This function returns the sum of all such delays.
- * The exact delay is not necessarily an integer value in either input or
- * output sample rate. Especially when downsampling by a large value, the
- * output sample rate may be a poor choice to represent the delay, similarly
- * for upsampling and the input sample rate.
- *
- * @param s     swr context
- * @param base  timebase in which the returned delay will be:
- *              @li if it's set to 1 the returned delay is in seconds
- *              @li if it's set to 1000 the returned delay is in milliseconds
- *              @li if it's set to the input sample rate then the returned
- *                  delay is in input samples
- *              @li if it's set to the output sample rate then the returned
- *                  delay is in output samples
- *              @li if it's the least common multiple of in_sample_rate and
- *                  out_sample_rate then an exact rounding-free delay will be
- *                  returned
- * @returns     the delay in 1 / @c base units.
- *)
-function swr_get_delay(s: PSwrContext; base: cint64): cint64;
-  cdecl; external sw__resample;
-
-(**
- * Find an upper bound on the number of samples that the next swr_convert
- * call will output, if called with in_samples of input samples. This
- * depends on the internal state, and anything changing the internal state
- * (like further swr_convert() calls) will may change the number of samples
- * swr_get_out_samples() returns for the same number of input samples.
- *
- * @param in_samples    number of input samples.
- * @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()
- *       or swr_set_compensation() invalidates this limit
- * @note it is recommended to pass the correct available buffer size
- *       to all functions like swr_convert() even if swr_get_out_samples()
- *       indicates that less would be used.
- * @returns an upper bound on the number of samples that the next swr_convert
- *          will output or a negative value to indicate an error
- *)
-function swr_get_out_samples(s: PSwrContext; in_samples: cint): cint;
-  cdecl; external sw__resample;
-
-(**
- * Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
- *
- * This is useful to check if the build-time libswresample has the same version
- * as the run-time one.
- *
- * @returns     the unsigned int-typed version
- *)
-function swresample_version(): cuint;
-  cdecl; external sw__resample;
-
-(**
- * Return the swr build-time configuration.
- *
- * @returns     the build-time @c ./configure flags
- *)
-function swresample_configuration(): PAnsiChar;
-  cdecl; external sw__resample;
-
-(**
- * Return the swr license.
- *
- * @returns     the license of libswresample, determined at build-time
- *)
-function swresample_license(): PAnsiChar;
-  cdecl; external sw__resample;
-
+function swr_alloc(): PSwrContext; cdecl; external 'libswresample';
+function swr_alloc_set_opts(s: PSwrContext; out_ch_layout: cint64; out_sample_fmt: TAVSampleFormat; out_sample_rate: cint; in_ch_layout: cint64; in_sample_fmt: TAVSampleFormat; in_sample_rate: cint; log_offset: cint; log_ctx: pointer): PSwrContext; cdecl; external 'libswresample';
+function swr_init(s: PSwrContext): cint; cdecl; external 'libswresample';
+procedure swr_free(s: PPSwrContext); cdecl; external 'libswresample';
+function swr_convert(s: PSwrContext; var out: pcuint8; out_count: cint; var in_: pcuint8; in_count: cint): cint; cdecl; external 'libswresample';
 implementation
-
 end.
-
diff --git a/src/lib/ffmpeg-4.0/swscale.pas b/src/lib/ffmpeg-4.0/swscale.pas
index 55c74c6cc..df1cc7bec 100644
--- a/src/lib/ffmpeg-4.0/swscale.pas
+++ b/src/lib/ffmpeg-4.0/swscale.pas
@@ -1,41 +1,13 @@
-(*
- * Copyright (C) 2001-2011 Michael Niedermayer <michaelni@gmx.at>
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * FFmpeg Pascal port
- * - Ported by the UltraStar Deluxe Team
- *
- * Conversion of libswscale/swscale.h
- * version: 3.0.100
- *)
- 
 unit swscale;
 
 {$IFDEF FPC}
-  {$MODE DELPHI }
+  {$MODE DELPHI}
   {$PACKENUM 4}    (* use 4-byte enums *)
   {$PACKRECORDS C} (* C/C++-compatible record packing *)
-  {$MACRO ON}      (* Turn macro support on *)
 {$ELSE}
   {$MINENUMSIZE 4} (* use 4-byte enums *)
 {$ENDIF}
 
-{$I switches.inc}  (* for ffmpeg defines *)
-{$I ff_api-defines.inc}  (* FF_API_* defines *)
-
 {$IFDEF DARWIN}
   {$linklib libswscale}
 {$ENDIF}
@@ -45,395 +17,37 @@ interface
 uses
   ctypes,
   avutil,
-  avcodec,
   UConfig;
 
 const
-(*
- * IMPORTANT: The official FFmpeg C headers change very quickly. Often some
- * of the data structures are changed so that they become incompatible with
- * older header files. The Pascal headers have to be adjusted to those changes,
- * otherwise the application might crash randomly or strange bugs (not
- * necessarily related to video or audio due to buffer overflows etc.) might
- * occur.
- *
- * In the past users reported problems with USDX that took hours to fix and
- * the problem was an unsupported version of FFmpeg. So we decided to disable
- * support for future versions of FFmpeg until the headers are revised by us
- * for that version as they otherwise most probably will break USDX.
- *
- * If the headers do not yet support your FFmpeg version you may want to
- * adjust the max. version numbers manually but please note: it may work but
- * in many cases it does not. The USDX team does NOT PROVIDE ANY SUPPORT
- * for the game if the MAX. VERSION WAS CHANGED.
- *
- * The only safe way to support new versions of FFmpeg is to add the changes
- * of the FFmpeg git repository C headers to the Pascal headers.
- * You can accelerate this process by posting a patch with the git changes
- * translated to Pascal to our bug tracker (please join our IRC chat before
- * you start working on it). Simply adjusting the max. versions is NOT a valid
- * fix. 
- *)
-
   (* Max. supported version by this header *)
   LIBSWSCALE_MAX_VERSION_MAJOR   =  5;
-  LIBSWSCALE_MAX_VERSION_MINOR   =  5;
+  LIBSWSCALE_MAX_VERSION_MINOR   =  9;
   LIBSWSCALE_MAX_VERSION_RELEASE =  100;
   LIBSWSCALE_MAX_VERSION = (LIBSWSCALE_MAX_VERSION_MAJOR * VERSION_MAJOR) +
                            (LIBSWSCALE_MAX_VERSION_MINOR * VERSION_MINOR) +
-			   (LIBSWSCALE_MAX_VERSION_RELEASE * VERSION_RELEASE);
+                           (LIBSWSCALE_MAX_VERSION_RELEASE * VERSION_RELEASE);
 
 (* Check if linked versions are supported *)
 {$IF (LIBSWSCALE_VERSION > LIBSWSCALE_MAX_VERSION)}
   {$MESSAGE Error 'Linked version of libswscale is not yet supported!'}
 {$IFEND}
 
-type
-  TQuadCintArray = array[0..3] of cint;
-  PQuadCintArray = ^TQuadCintArray;
-  TCintArray = array[0..0] of cint;
-  PCintArray = ^TCintArray;
-  TPCuint8Array = array[0..0] of PCuint8;
-  PPCuint8Array = ^TPCuint8Array;
-
-(**
- * Return the LIBSWSCALE_VERSION_INT constant.
- *)
-function swscale_version(): cuint;
-  cdecl; external sw__scale;
-
-(**
- * Return the libswscale build-time configuration.
- *)
-function swscale_configuration(): PAnsiChar;
-  cdecl; external sw__scale;
-
-(**
- * Return the libswscale license.
- *)
-function swscale_license(): PAnsiChar;
-  cdecl; external sw__scale;
 
 const
-  (* values for the flags, the stuff on the command line is different *)
-  SWS_FAST_BILINEAR =    1;
-  SWS_BILINEAR      =    2;
-  SWS_BICUBIC       =    4;
-  SWS_X             =    8;
-  SWS_POINT         =  $10;
-  SWS_AREA          =  $20;
-  SWS_BICUBLIN      =  $40;
-  SWS_GAUSS         =  $80;
-  SWS_SINC          = $100;
-  SWS_LANCZOS       = $200;
-  SWS_SPLINE        = $400;
-
-  SWS_SRC_V_CHR_DROP_MASK  = $30000;
-  SWS_SRC_V_CHR_DROP_SHIFT = 16;
-
-  SWS_PARAM_DEFAULT        = 123456;
-
-  SWS_PRINT_INFO           = $1000;
-
-  // the following 3 flags are not completely implemented
-  // internal chrominance subsampling info
-  SWS_FULL_CHR_H_INT    = $2000;
-  // input subsampling info
-  SWS_FULL_CHR_H_INP    = $4000;
-  SWS_DIRECT_BGR        = $8000;
-  SWS_ACCURATE_RND      = $40000;
-  SWS_BITEXACT          = $80000;
-
-  SWS_MAX_REDUCE_CUTOFF = 0.002;
-
-  SWS_CS_ITU709         = 1;
-  SWS_CS_FCC            = 4;
-  SWS_CS_ITU601         = 5;
-  SWS_CS_ITU624         = 5;
-  SWS_CS_SMPTE170M      = 5;
-  SWS_CS_SMPTE240M      = 7;
-  SWS_CS_DEFAULT        = 5;
-  SWS_CS_BT2020         = 9;
-
-(**
- * Return a pointer to yuv<->rgb coefficients for the given colorspace
- * suitable for sws_setColorspaceDetails().
- *
- * @param colorspace One of the SWS_CS_* macros. If invalid,
- * SWS_CS_DEFAULT is used.
- *)
-function sws_getCoefficients(colorspace: cint): Pcint;
-  cdecl; external sw__scale;
-  
+  SWS_FAST_BILINEAR = 1;
 type
-
-  // when used for filters they must have an odd number of elements
-  // coeffs cannot be shared between vectors
-  PSwsVector = ^TSwsVector;
-  TSwsVector = record
-    coeff: PCdouble;    // pointer to the list of coefficients
-    length: cint;       // number of coefficients in the vector
+  PSwsContext = ^TSwsContext;
+  TSwsContext = record
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-  // vectors can be shared
   PSwsFilter = ^TSwsFilter;
   TSwsFilter = record
-    lumH: PSwsVector;
-    lumV: PSwsVector;
-    chrH: PSwsVector;
-    chrV: PSwsVector;
+    do_not_instantiate_this_record: incomplete_record;
   end;
-
-  PSwsContext = ^TSwsContext;
-  TSwsContext = record
-    {internal structure}
-  end;
-
-(**
- * Return a positive value if pix_fmt is a supported input format, 0
- * otherwise.
- *)
-function sws_isSupportedInput(pix_fmt: TAVPixelFormat): cint;
-  cdecl; external sw__scale;
-
-(**
- * Return a positive value if pix_fmt is a supported output format, 0
- * otherwise.
- *)
-function sws_isSupportedOutput(pix_fmt: TAVPixelFormat): cint;
-  cdecl; external sw__scale;
-
-(**
- * @param[in]  pix_fmt the pixel format
- * @return a positive value if an endianness conversion for pix_fmt is
- * supported, 0 otherwise.
- *)
-function sws_isSupportedEndiannessConversion(pix_fmt: TAVPixelFormat): cint;
-  cdecl; external sw__scale;
-
-(**
- * Allocate an empty SwsContext. This must be filled and passed to
- * sws_init_context(). For filling see AVOptions, options.c and
- * sws_setColorspaceDetails().
- *)
-function sws_alloc_context(): PSwsContext;
-  cdecl; external sw__scale;
-
-(**
- * Initialize the swscaler context sws_context.
- *
- * @return zero or positive value on success, a negative value on
- * error
- *)
-function sws_init_context(sws_context: PSwsContext; srcFilter: PSwsFilter; dstFilter: PSwsFilter): cint;
-  cdecl; external sw__scale;
-
-(**
- * Free the swscaler context swsContext.
- * If swsContext is NULL, then does nothing.
- *)
-procedure sws_freeContext(swsContext: PSwsContext);
-  cdecl; external sw__scale;
-
-(**
- * Allocate and return a SwsContext. You need it to perform
- * scaling/conversion operations using sws_scale().
- *
- * @param srcW the width of the source image
- * @param srcH the height of the source image
- * @param srcFormat the source image format
- * @param dstW the width of the destination image
- * @param dstH the height of the destination image
- * @param dstFormat the destination image format
- * @param flags specify which algorithm and options to use for rescaling
- * @param param extra parameters to tune the used scaler
- *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis
- *              function, param[0] tunes f(1) and param[1] f??(1)
- *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff
- *              frequency
- *              For SWS_LANCZOS param[0] tunes the width of the window function
- * @return a pointer to an allocated context, or NULL in case of error
- * @note this function is to be removed after a saner alternative is
- *       written
- *)
-function sws_getContext(srcW: cint; srcH: cint; srcFormat: TAVPixelFormat;
-                        dstW: cint; dstH: cint; dstFormat: TAVPixelFormat;
-                        flags: cint; srcFilter: PSwsFilter;
-                        dstFilter: PSwsFilter; param: {const} PCdouble): PSwsContext;
-  cdecl; external sw__scale;
-
-(**
- * Scale the image slice in srcSlice and put the resulting scaled
- * slice in the image in dst. A slice is a sequence of consecutive
- * rows in an image.
- *
- * Slices have to be provided in sequential order, either in
- * top-bottom or bottom-top order. If slices are provided in
- * non-sequential order the behavior of the function is undefined.
- *
- * @param c         the scaling context previously created with
- *                  sws_getContext()
- * @param srcSlice  the array containing the pointers to the planes of
- *                  the source slice
- * @param srcStride the array containing the strides for each plane of
- *                  the source image
- * @param srcSliceY the position in the source image of the slice to
- *                  process, that is the number (counted starting from
- *                  zero) in the image of the first row of the slice
- * @param srcSliceH the height of the source slice, that is the number
- *                  of rows in the slice
- * @param dst       the array containing the pointers to the planes of
- *                  the destination image
- * @param dstStride the array containing the strides for each plane of
- *                  the destination image
- * @return          the height of the output slice
- *)
-function sws_scale(c: PSwsContext; {const} srcSlice: PPCuint8Array;
-              {const} srcStride: PCintArray; srcSliceY: cint; srcSliceH: cint; 
-              {const} dst: PPCuint8Array; {const} dstStride: PCintArray): cint;
-  cdecl; external sw__scale;
-
-(**
- * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
- * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
- * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
- * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
- * @param brightness 16.16 fixed point brightness correction
- * @param contrast 16.16 fixed point contrast correction
- * @param saturation 16.16 fixed point saturation correction
- * @return -1 if not supported
- *)
-function sws_setColorspaceDetails(c: PSwsContext; inv_table: PQuadCintArray; 
-              srcRange: cint; table: PQuadCintArray; dstRange: cint;
-              brightness: cint; contrast: cint; saturation: cint): cint;
-  cdecl; external sw__scale;
-
-(**
- * @return -1 if not supported
- *)
-function sws_getColorspaceDetails(c: PSwsContext; var inv_table: PQuadCintArray;
-              var srcRange: cint; var table: PQuadCintArray; var dstRange: cint;
-              var brightness: cint; var contrast: cint; var saturation: cint): cint;
-  cdecl; external sw__scale;
-
-(**
- * Allocate and return an uninitialized vector with length coefficients.
- *)
-function sws_allocVec(length: cint): PSwsVector;
-  cdecl; external sw__scale;
-
-(**
- * Return a normalized Gaussian curve used to filter stuff
- * quality = 3 is high quality, lower is lower quality.
- *)
-function sws_getGaussianVec(variance: cdouble; quality: cdouble): PSwsVector;
-  cdecl; external sw__scale;
-
-(**
- * Scale all the coefficients of a by the scalar value.
- *)
-procedure sws_scaleVec(a: PSwsVector; scalar: cdouble);
-  cdecl; external sw__scale;
-
-(**
- * Scale all the coefficients of a so that their sum equals height.
- *)
-procedure sws_normalizeVec(a: PSwsVector; height: cdouble);
-  cdecl; external sw__scale;
-
-{$IFDEF FF_API_SWS_VECTOR}
-function sws_getConstVec(c: cdouble; length: cint): PSwsVector;
-  cdecl; external sw__scale; deprecated;
-function sws_getIdentityVec: PSwsVector;
-  cdecl; external sw__scale; deprecated;
-procedure sws_convVec(a: PSwsVector; b: PSwsVector);
-  cdecl; external sw__scale; deprecated;
-procedure sws_addVec(a: PSwsVector; b: PSwsVector);
-  cdecl; external sw__scale; deprecated;
-procedure sws_subVec(a: PSwsVector; b: PSwsVector);
-  cdecl; external sw__scale; deprecated;
-procedure sws_shiftVec(a: PSwsVector; shift: cint);
-  cdecl; external sw__scale; deprecated;
-function sws_cloneVec(a: PSwsVector): PSwsVector;
-  cdecl; external sw__scale; deprecated;
-procedure sws_printVec2(a:         PSwsVector;
-                        log_ctx:   PAVClass; // PAVClass is declared in avcodec.pas
-                        log_level: cint);
-  cdecl; external sw__scale; deprecated;
-{$ENDIF}
-
-procedure sws_freeVec(a: PSwsVector);
-  cdecl; external sw__scale;
-
-function sws_getDefaultFilter(lumaGBlur: cfloat; chromaGBlur: cfloat; 
-                              lumaSharpen: cfloat; chromaSharpen: cfloat;
-                              chromaHShift: cfloat; chromaVShift: cfloat;
-                              verbose: cint): PSwsFilter;
-  cdecl; external sw__scale;
-
-procedure sws_freeFilter(filter: PSwsFilter);
-  cdecl; external sw__scale;
-
-(**
- * Check if context can be reused, otherwise reallocates a new one.
- * 
- * If context is NULL, just calls sws_getContext() to get a new
- * context. Otherwise, checks if the parameters are the ones already
- * saved in context. If that is the case, returns the current
- * context. Otherwise, frees context and gets a new context with
- * the new parameters.
- * 
- * Be warned that srcFilter and dstFilter are not checked, they
- * are assumed to remain the same.
- *)
-function sws_getCachedContext(context: PSwsContext;
-              srcW: cint; srcH: cint; srcFormat: TAVPixelFormat;
-              dstW: cint; dstH: cint; dstFormat: TAVPixelFormat;
-              flags: cint; srcFilter: PSwsFilter; 
-              dstFilter: PSwsFilter; param: PCdouble): PSwsContext;
-  cdecl; external sw__scale;
-
-(**
- * Convert an 8bit paletted frame into a frame with a color depth of 32-bits.
- *
- * The output frame will have the same packed format as the palette.
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- *)
-procedure sws_convertPalette8ToPacked32({const} src:     PPCuint8Array;
-                                        dst:             PPCuint8Array;
-                                        num_pixels:      cint;
-                                        {const} palette: PPCuint8Array);
-  cdecl; external sw__scale;
-
-(**
- * Convert an 8bit paletted frame into a frame with a color depth of 24 bits.
- *
- * With the palette format "ABCD", the destination frame ends up with the format "ABC".
- *
- * @param src        source frame buffer
- * @param dst        destination frame buffer
- * @param num_pixels number of pixels to convert
- * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
- *)
-procedure sws_convertPalette8ToPacked24({const} src:     PPCuint8Array;
-                                        dst:             PPCuint8Array;
-                                        num_pixels:      cint;
-                                        {const} palette: PPCuint8Array);
-  cdecl; external sw__scale;
-
-(**
- * Get the AVClass for swsContext. It can be used in combination with
- * AV_OPT_SEARCH_FAKE_OBJ for examining options.
- *
- * @see av_opt_find().
- *)
-function sws_get_class(): {const} PAVClass;
-  cdecl; external sw__scale;
-
+function swscale_version(): cuint; cdecl; external 'libswscale';
+function sws_isSupportedInput(pix_fmt: TAVPixelFormat): cint; cdecl; external 'libswscale';
+function sws_scale(c: PSwsContext; srcSlice: ppcuint8; srcStride: pcint; srcSliceY: cint; srcSliceH: cint; dst: ppcuint8; dstStride: pcint): cint; cdecl; external 'libswscale';
+function sws_getContext(srcW: cint; srcH: cint; srcFormat: TAVPixelFormat; dstW: cint; dstH: cint; dstFormat: TAVPixelFormat; flags: cint; srcFilter: PSwsFilter; dstFilter: PSwsFilter; param: pcdouble): PSwsContext; cdecl; external 'libswscale';
 implementation
-
 end.
